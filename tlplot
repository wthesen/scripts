
 
TechlogPlot	index
c:\program files\techlog 2024.2 (r9274463)\pythonscripts\techlogplot.py
# Copyright (c) 2023 SLB
# SLB Confidential


 
Modules
      	 	
remote_techlog

 
Functions
      	 	
adjustH(*args, **kwargs)
adjustH(plotID: Number) -> bool
 
Adjust a cross-plot or a logview horizontally
 
Args:
    plotID (Number): window ID
 
Returns:
    bool: operation exit status
adjustHV(*args, **kwargs)
adjustHV(plotID: Number) -> bool
 
Adjust a cross-plot or a logview horizontally and vertically
 
Args:
    plotID (Number): window ID
 
Returns:
    bool: operation exit status
adjustV(*args, **kwargs)
adjustV(plotID: Number) -> bool
 
Adjust a cross-plot or a logview vertically
 
Args:
    plotID (Number): window ID
 
Returns:
    bool: operation exit status
baseMapAddChart(*args, **kwargs)
baseMapAddChart(plotID: Number, cn: str) -> bool
 
Add chart to the basemap
 
Args:
    plotID (Number): basemap window ID
    cn (str): chart level\chart name. Chart level is optional and can be:
    Techlog (default), Company, User, Project.
 
Returns:
    bool: operation exit status
baseMapAddMap(*args, **kwargs)
baseMapAddMap(plotID: Number, name: str) -> bool
 
Add a map to an existing basemap
 
Args:
    plotID (Number): plot window ID
    name (str): map name
 
Returns:
    bool: operation exit status
baseMapAddWell(*args, **kwargs)
baseMapAddWell(plotID: Number, name: str) -> bool
 
Add a well to an existing basemap
 
Args:
    plotID (Number): plot window ID
    name (str): well name
 
Returns:
    bool: operation exit status
baseMapAdjustToMap(*args, **kwargs)
baseMapAdjustToMap(plotID: Number) -> bool
 
Adjust the basemap to the map
 
Args:
    plotID (Number): plot window ID
 
Returns:
    bool: operation exit status
baseMapCreate(*args, **kwargs)
baseMapCreate(n: str, xn: list=None, map: str=None) -> Number
 
Create a basemap
 
Args:
    n (str): plot name
    xn (list): Optional; list of well name
    map (str): Optional; map name
 
Returns:
    Number: plot ID
baseMapOpen(*args, **kwargs)
baseMapOpen(n: str, f: str=None) -> Number
 
Open an existing basemap
 
Args:
    n (str): plot name
    f (str): Optional; folder
 
Returns:
    Number: plot ID
baseMapRemoveMap(*args, **kwargs)
baseMapRemoveMap(plotID: Number) -> bool
 
Remove the map from an existing basemap
 
Args:
    plotID (Number): plot window ID
 
Returns:
    bool: operation exit status
baseMapRemoveWell(*args, **kwargs)
baseMapRemoveWell(plotID: Number, name: str) -> bool
 
Remove a well from an existing basemap
 
Args:
    plotID (Number): plot window ID
    name (str): well name
 
Returns:
    bool: operation exit status
baseMapSave(*args, **kwargs)
baseMapSave(plotID: Number, n: str, f: str='') -> bool
 
Save the basemap
 
Args:
    plotID (Number): plot window ID
    n (str): file name
    f (str): Optional; folder
 
Returns:
    bool: operation exit status
baseMapSaveMap(*args, **kwargs)
baseMapSaveMap(plotID: Number, n: str, f: str='') -> bool
 
Save the map of a basemap
 
Args:
    plotID (Number): plot window ID
    n (str): file name
    f (str): Optional; folder
 
Returns:
    bool: operation exit status
baseMapSetContourColor(*args, **kwargs)
baseMapSetContourColor(plotID: Number, r: Number, g: Number, b: Number) -> bool
 
Set the contour color on basemap
 
Args:
    plotID (Number): plot window ID
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
baseMapSetContourColorMode(*args, **kwargs)
baseMapSetContourColorMode(plotID: Number, mode: str='UNIFORM') -> bool
 
Set the contour color mode on basemap
 
Args:
    plotID (Number): plot window ID
    mode (str): Optional; {'UNIFORM', 'PALETTE'}
 
Returns:
    bool: operation exit status
baseMapSetContourComputationStep(*args, **kwargs)
baseMapSetContourComputationStep(plotID: Number, value: Number) -> bool
 
Set the contour computation step on basemap
 
Args:
    plotID (Number): plot window ID
    value (Number): step value
 
Returns:
    bool: operation exit status
baseMapSetContourThickness(*args, **kwargs)
baseMapSetContourThickness(plotID: Number, value: Number) -> bool
 
Set the contour thickness on basemap
 
Args:
    plotID (Number): plot window ID
    value (Number): thickness value
 
Returns:
    bool: operation exit status
baseMapSetContourValueVisible(*args, **kwargs)
baseMapSetContourValueVisible(plotID: Number, b: bool) -> bool
 
Set the contour value visibility on basemap
 
Args:
    plotID (Number): plot window ID
    b (bool): contour value visible if True
 
Returns:
    bool: operation exit status
baseMapSetContourVisible(*args, **kwargs)
baseMapSetContourVisible(plotID: Number, b: bool) -> bool
 
Set the contour visibility on basemap
 
Args:
    plotID (Number): plot window ID
    b (bool): contour visible if True
 
Returns:
    bool: operation exit status
baseMapSetContourWithData(*args, **kwargs)
baseMapSetContourWithData(plotID: Number, b: bool) -> bool
 
Set the contour with data on basemap
 
Args:
    plotID (Number): plot window ID
    b (bool): contour with data if True
 
Returns:
    bool: operation exit status
baseMapSetDensitySmooth(*args, **kwargs)
baseMapSetDensitySmooth(plotID: Number, b: bool) -> bool
 
Set the smooth density visibility on basemap
 
Args:
    plotID (Number): plot window ID
    b (bool): smooth density visible if True
 
Returns:
    bool: operation exit status
baseMapSetDensityValuesVisible(*args, **kwargs)
baseMapSetDensityValuesVisible(plotID: Number, b: bool) -> bool
 
Set the density values visibility on basemap
 
Args:
    plotID (Number): plot window ID
    b (bool): density values visible if True
 
Returns:
    bool: operation exit status
baseMapSetDensityVisible(*args, **kwargs)
baseMapSetDensityVisible(plotID: Number, b: bool) -> bool
 
Set the density visibility on basemap
 
Args:
    plotID (Number): plot window ID
    b (bool): density visible if True
 
Returns:
    bool: operation exit status
baseMapSetDerrickColor(*args, **kwargs)
baseMapSetDerrickColor(plotID: Number, r: Number, g: Number, b: Number) -> bool
 
Set the color of the derrick on basemap
 
Args:
    plotID (Number): plot window ID
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
baseMapSetDerrickSize(*args, **kwargs)
baseMapSetDerrickSize(plotID: Number, size: Number) -> bool
 
Set the size of the derrick on basemap
 
Args:
    plotID (Number): plot window ID
    size (Number): size value
 
Returns:
    bool: operation exit status
baseMapSetKeepProportion(*args, **kwargs)
baseMapSetKeepProportion(plotID: Number, b: bool) -> bool
 
Set the keep proportion on basemap
 
Args:
    plotID (Number): plot window ID
    b (bool): keep proportion if True
 
Returns:
    bool: operation exit status
baseMapSetLabelBackgroundVisible(*args, **kwargs)
baseMapSetLabelBackgroundVisible(plotID: Number, visible: bool=False) -> bool
 
Set the visibility of the background of the labels on basemap
 
Args:
    plotID (Number): plot window ID
    visible (bool): Optional; background visible if True
 
Returns:
    bool: operation exit status
baseMapSetLabelColor(*args, **kwargs)
baseMapSetLabelColor(plotID: Number, r: Number, g: Number, b: Number) -> bool
 
Set the color of the labels on basemap
 
Args:
    plotID (Number): plot window ID
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
baseMapSetLabelDisplayMode(*args, **kwargs)
baseMapSetLabelDisplayMode(plotID: Number, type: str='WELL') -> bool
 
Set the display mode of the labels on basemap
 
Args:
    plotID (Number): plot window ID
    type (str): Optional; {'WELL', 'CUSTOM'}
 
Returns:
    bool: operation exit status
baseMapSetLabelFont(*args, **kwargs)
baseMapSetLabelFont(plotID: Number, fontName: str, fontSize: Number, fontBold: bool=False, fontItalic: bool=False, fontUnderline: bool=False, fontStrikeOut: bool=False) -> bool
 
Set the font of the labels on basemap
 
Args:
    plotID (Number): plot window ID
    fontName (str): name of the family font
    fontSize (Number): size of the font
    fontBold (bool): Optional; font in bold or not
    fontItalic (bool): Optional; font in italic or not
    fontUnderline (bool): Optional; underline font or not
    fontStrikeOut (bool): Optional; strike out font or not
 
Returns:
    bool: operation exit status
baseMapSetLabelPositionType(*args, **kwargs)
baseMapSetLabelPositionType(plotID: Number, type: str='TOP') -> bool
 
Set the position type of the labels on basemap
 
Args:
    plotID (Number): plot window ID
    type (str): Optional; {'NONE', 'TOP', 'BOTTOM', 'BOTH'}
 
Returns:
    bool: operation exit status
baseMapSetLabelWellProperties(*args, **kwargs)
baseMapSetLabelWellProperties(plotID: Number, s: str) -> bool
 
Set the well properties of the labels on basemap
 
Args:
    plotID (Number): plot window ID
    s (str): well properties
 
Returns:
    bool: operation exit status
baseMapSetOpacityActivated(*args, **kwargs)
baseMapSetOpacityActivated(plotID: Number, b: bool) -> bool
 
Set the opacity activation on basemap
 
Args:
    plotID (Number): plot window ID
    b (bool): opacity activated if True
 
Returns:
    bool: operation exit status
baseMapSetOpacityValue(*args, **kwargs)
baseMapSetOpacityValue(plotID: Number, f: Number) -> bool
 
Set the opacity value on basemap
 
Args:
    plotID (Number): plot window ID
    f (Number): opacity value
 
Returns:
    bool: operation exit status
baseMapSetReferentialBorderColor(*args, **kwargs)
baseMapSetReferentialBorderColor(plotID: Number, r: Number, g: Number, b: Number) -> bool
 
Set the border color of the referential on basemap
 
Args:
    plotID (Number): plot window ID
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
baseMapSetReferentialColor(*args, **kwargs)
baseMapSetReferentialColor(plotID: Number, r: Number, g: Number, b: Number) -> bool
 
Set the color of the referential on basemap
 
Args:
    plotID (Number): plot window ID
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
baseMapSetReferentialFont(*args, **kwargs)
baseMapSetReferentialFont(plotID: Number, fontName: str, fontSize: Number, fontBold: bool=False, fontItalic: bool=False, fontUnderline: bool=False, fontStrikeOut: bool=False) -> bool
 
Set the font of the referential on basemap
 
Args:
    plotID (Number): plot window ID
    fontName (str): name of the family font
    fontSize (Number): size of the font
    fontBold (bool): Optional; font in bold or not
    fontItalic (bool): Optional; font in italic or not
    fontUnderline (bool): Optional; underline font or not
    fontStrikeOut (bool): Optional; strike out font or not
 
Returns:
    bool: operation exit status
baseMapSetReferentialPosition(*args, **kwargs)
baseMapSetReferentialPosition(plotID: Number, x: Number, y: Number) -> bool
 
Set the position of the referential on basemap
 
Args:
    plotID (Number): plot window ID
    x (Number): x position
    y (Number): y position
 
Returns:
    bool: operation exit status
baseMapSetReferentialSize(*args, **kwargs)
baseMapSetReferentialSize(plotID: Number, f: Number) -> bool
 
Set the size of the referential on basemap
 
Args:
    plotID (Number): plot window ID
    f (Number): size
 
Returns:
    bool: operation exit status
baseMapSetReferentialVisible(*args, **kwargs)
baseMapSetReferentialVisible(plotID: Number, b: bool) -> bool
 
Set the visibility of the referential on basemap
 
Args:
    plotID (Number): plot window ID
    b (bool): value
 
Returns:
    bool: operation exit status
baseMapSetScaleColor(*args, **kwargs)
baseMapSetScaleColor(plotID: Number, r: Number, g: Number, b: Number) -> bool
 
Set the color of the scale on basemap
 
Args:
    plotID (Number): plot window ID
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
baseMapSetScaleFont(*args, **kwargs)
baseMapSetScaleFont(plotID: Number, fontName: str, fontSize: Number, fontBold: bool=False, fontItalic: bool=False, fontUnderline: bool=False, fontStrikeOut: bool=False) -> bool
 
Set the font of the scale on basemap
 
Args:
    plotID (Number): plot window ID
    fontName (str): name of the family font
    fontSize (Number): size of the font
    fontBold (bool): Optional; font in bold or not
    fontItalic (bool): Optional; font in italic or not
    fontUnderline (bool): Optional; underline font or not
    fontStrikeOut (bool): Optional; strike out font or not
 
Returns:
    bool: operation exit status
baseMapSetScaleVisible(*args, **kwargs)
baseMapSetScaleVisible(plotID: Number, visible: bool=False) -> bool
 
Set the visibility of the scale on basemap
 
Args:
    plotID (Number): plot window ID
    visible (bool): Optional; scale visible if True
 
Returns:
    bool: operation exit status
baseMapSetSymbolDisplayMode(*args, **kwargs)
baseMapSetSymbolDisplayMode(plotID: Number, type: str='DERRICK') -> bool
 
Set the symbol display mode on basemap
 
Args:
    plotID (Number): plot window ID
    type (str): Optional; {'DERRICK', 'STATUS', 'CUSTOM'}
 
Returns:
    bool: operation exit status
baseMapSetSymbolSize(*args, **kwargs)
baseMapSetSymbolSize(plotID: Number, size: Number) -> bool
 
Set the symbol size on basemap
 
Args:
    plotID (Number): plot window ID
    size (Number): size value
 
Returns:
    bool: operation exit status
baseMapSetSymbolWellProperties(*args, **kwargs)
baseMapSetSymbolWellProperties(plotID: Number, s: str) -> bool
 
Set the symbol well properties on basemap
 
Args:
    plotID (Number): plot window ID
    s (str): well properties
 
Returns:
    bool: operation exit status
baseMapSetTrajectoryColor(*args, **kwargs)
baseMapSetTrajectoryColor(plotID: Number, r: Number, g: Number, b: Number) -> bool
 
Set the color of the trajectory on basemap
 
Args:
    plotID (Number): plot window ID
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
baseMapSetTrajectoryMappedValue(*args, **kwargs)
baseMapSetTrajectoryMappedValue(plotID: Number, visible: bool=False) -> bool
 
Set the visibility of the mapped value on basemap
 
Args:
    plotID (Number): plot window ID
    visible (bool): Optional; mapped value visible if True
 
Returns:
    bool: operation exit status
baseMapSetTrajectoryThickness(*args, **kwargs)
baseMapSetTrajectoryThickness(plotID: Number, thickness: Number) -> bool
 
Set the thickness of the trajectory on basemap
 
Args:
    plotID (Number): plot window ID
    thickness (Number): thickness value
 
Returns:
    bool: operation exit status
baseMapSetTrajectoryVisible(*args, **kwargs)
baseMapSetTrajectoryVisible(plotID: Number, visible: bool=False) -> bool
 
Set the visibility of the trajectory on basemap
 
Args:
    plotID (Number): plot window ID
    visible (bool): Optional; trajectory visible if True
 
Returns:
    bool: operation exit status
baseMapSetWellColorVisible(*args, **kwargs)
baseMapSetWellColorVisible(plotID: Number, b: bool) -> bool
 
Set the well color visibility on basemap
 
Args:
    plotID (Number): plot window ID
    b (bool): well color visible if True
 
Returns:
    bool: operation exit status
baseMapSetXAxisGraduations(*args, **kwargs)
baseMapSetXAxisGraduations(plotID: Number, f: Number) -> bool
 
Set x axis graduations on basemap
 
Args:
    plotID (Number): plot window ID
    f (Number): graduations
 
Returns:
    bool: operation exit status
baseMapSetXAxisType(*args, **kwargs)
baseMapSetXAxisType(plotID: Number, type: str='VARIABLE') -> bool
 
Set x axis type on basemap
 
Args:
    plotID (Number): plot window ID
    type (str): Optional; {'VARIABLE', 'USER'}
 
Returns:
    bool: operation exit status
baseMapSetXAxisUserLimits(*args, **kwargs)
baseMapSetXAxisUserLimits(plotID: Number, min: Number, max: Number) -> bool
 
Set x axis user limits on basemap
 
Args:
    plotID (Number): plot window ID
    min (Number): min user value
    max (Number): max user value
 
Returns:
    bool: operation exit status
baseMapSetXYUnit(*args, **kwargs)
baseMapSetXYUnit(plotID: Number, unit: str) -> bool
 
Set x and y unit on basemap
 
Args:
    plotID (Number): plot window ID
    unit (str): unit value
 
Returns:
    bool: operation exit status
baseMapSetYAxisGraduations(*args, **kwargs)
baseMapSetYAxisGraduations(plotID: Number, f: Number) -> bool
 
Set y axis graduations on basemap
 
Args:
    plotID (Number): plot window ID
    f (Number): graduations
 
Returns:
    bool: operation exit status
baseMapSetYAxisType(*args, **kwargs)
baseMapSetYAxisType(plotID: Number, type: str='VARIABLE') -> bool
 
Set y axis type on basemap
 
Args:
    plotID (Number): plot window ID
    type (str): Optional; {'VARIABLE', 'USER'}
 
Returns:
    bool: operation exit status
baseMapSetYAxisUserLimits(*args, **kwargs)
baseMapSetYAxisUserLimits(plotID: Number, min: Number, max: Number) -> bool
 
Set y axis user limits on basemap
 
Args:
    plotID (Number): plot window ID
    min (Number): min user value
    max (Number): max user value
 
Returns:
    bool: operation exit status
boreholeSectionPlotOpen(*args, **kwargs)
boreholeSectionPlotOpen(n: str, f: str=None) -> Number
 
Open an existing borehole section plot
 
Args:
    n (str): plot name
    f (str): Optional; folder
 
Returns:
    Number: plot ID
boxPlotAddZone(*args, **kwargs)
boxPlotAddZone(plotID: Number, z: str) -> bool
 
Add a zone in the selection to the box-plot
 
Args:
    plotID (Number): box-plot window ID
    z (str): zone name
 
Returns:
    bool: operation exit status
boxPlotApplyTo(*args, **kwargs)
boxPlotApplyTo(plotID: Number, ds: list) -> list
 
Apply the box-plot to a data set list
 
Args:
    plotID (Number): box-plot window ID
    ds (list): dataset ID (wellName.datasetName)
 
Returns:
    list: list of plotID
boxPlotCleanZonation(*args, **kwargs)
boxPlotCleanZonation(plotID: Number, d: str) -> bool
 
Remove the zonation dataset from the box-plot - any display of zone must previously have been cancelled
 
Args:
    plotID (Number): box-plot window ID
    d (str): zonation dataset name
 
Returns:
    bool: operation exit status
boxPlotCleanZone(*args, **kwargs)
boxPlotCleanZone(plotID: Number, z: str) -> bool
 
Remove a zone in the selection from the box-plot
 
Args:
    plotID (Number): box-plot window ID
    z (str): zone name
 
Returns:
    bool: operation exit status
boxPlotCreate(*args, **kwargs)
boxPlotCreate(n: str, vl: list=None, f: str='') -> Number
 
Create a new box-plot
 
Args:
    n (str): box-plot window name
    vl (list): Optional; variable list
    f (str): Optional; filter variable ID
 
Returns:
    Number: box-plot window ID
boxPlotDeleteFilterValues(*args, **kwargs)
boxPlotDeleteFilterValues(plotID: Number) -> bool
 
Delete the filter variable of the box-plot
 
Args:
    plotID (Number): box-plot window ID
 
Returns:
    bool: operation exit status
boxPlotDeleteVariables(*args, **kwargs)
boxPlotDeleteVariables(plotID: Number, vn: list) -> bool
 
Delete the variable list of the box-plot
 
Args:
    plotID (Number): box-plot window ID
    vn (list): variable list
 
Returns:
    bool: operation exit status
boxPlotDuplicate(*args, **kwargs)
boxPlotDuplicate(plotID: Number) -> Number
 
Duplicate the box-plot
 
Args:
    plotID (Number): box-plot window ID
 
Returns:
    Number: new plot id or -1
boxPlotGetIdByName(*args, **kwargs)
boxPlotGetIdByName(n: str) -> Number
 
Find the ID of a name-known box-plot
 
Args:
    n (str): box-plot name
 
Returns:
    Number: box-plot window ID
boxPlotLockAxisY(*args, **kwargs)
boxPlotLockAxisY(plotID: Number, locked: bool) -> bool
 
Lock y-axis limits of the box-plot
 
Args:
    plotID (Number): box-plot window ID
    locked (bool): True if locked, False else
 
Returns:
    bool: operation exit status
boxPlotLockLegendY(*args, **kwargs)
boxPlotLockLegendY(plotID: Number, locked: bool) -> bool
 
Lock y-axis legend of the box-plot
 
Args:
    plotID (Number): box-plot window ID
    locked (bool): True if locked, False else
 
Returns:
    bool: operation exit status
boxPlotLockTitle(*args, **kwargs)
boxPlotLockTitle(plotID: Number, locked: bool) -> bool
 
Lock title of the box-plot
 
Args:
    plotID (Number): box-plot window ID
    locked (bool): True if locked, False else
 
Returns:
    bool: operation exit status
boxPlotMeanColor(*args, **kwargs)
boxPlotMeanColor(plotID: Number, r: Number, g: Number, b: Number) -> bool
 
Change mean markers color in box-plot
 
Args:
    plotID (Number): box-plot window ID
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
boxPlotMeanColour(*args, **kwargs)
boxPlotMeanColour(plotID: Number, r: Number, g: Number, b: Number) -> bool
 
[DEPRECATED] (use boxPlotMeanColor instead) Change mean markers color in box-plot
 
Args:
    plotID (Number): box-plot window ID
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
boxPlotMeanMarkers(*args, **kwargs)
boxPlotMeanMarkers(plotID: Number, type: int, size: Number=8) -> bool
 
Change mean markers in box-plot
 
Args:
    plotID (Number): box-plot window ID
    type (int): markers type {'MARKER_CIRCLE', 'MARKER_SQUARE', 'MARKER_DIAMOND',
       'MARKER_TRIANGLE', 'MARKER_TRIANGLE_DOWN', 'MARKER_TRIANGLE_LEFT',
       'MARKER_TRIANGLE_RIGHT', 'MARKER_EMPTY_CIRCLE', 'MARKER_EMPTY_SQUARE',
       'MARKER_EMPTY_DIAMOND', 'MARKER_EMPTY_TRIANGLE', 'MARKER_EMPTY_TRIANGLE_DOWN',
       'MARKER_EMPTY_TRIANGLE_LEFT', 'MARKER_EMPTY_TRIANGLE_RIGHT', 'MARKER_SHURIKEN',
       'MARKER_EMPTY_SHURIKEN', 'MARKER_PLUS', 'MARKER_CROSS',
       'MARKER_STAR', 'MARKER_RIG', 'NB_MARKER'}
    size (Number): Optional; markers size (between 2 & 30)
 
Returns:
    bool: operation exit status
boxPlotMeanStdDeviation(*args, **kwargs)
boxPlotMeanStdDeviation(plotID: Number, show: bool) -> bool
 
Mean & standard deviation display in box-plot
 
Args:
    plotID (Number): box-plot window ID
    show (bool): True if show, False else
 
Returns:
    bool: operation exit status
boxPlotMultiWellAddData(*args, **kwargs)
boxPlotMultiWellAddData(plotID: Number, ds: str) -> bool
 
Add a dataset to a multi well box-plot
 
Args:
    plotID (Number): box-plot window ID
    ds (str): dataset name
 
Returns:
    bool: operation exit status
boxPlotMultiWellAddZone(*args, **kwargs)
boxPlotMultiWellAddZone(plotID: Number, z: str) -> bool
 
Add a zone in the selection to the box-plot
 
Args:
    plotID (Number): box-plot window ID
    z (str): zone name
 
Returns:
    bool: operation exit status
boxPlotMultiWellCleanZonation(*args, **kwargs)
boxPlotMultiWellCleanZonation(plotID: Number, d: str) -> bool
 
Remove the zonation dataset from the box-plot - any display of zone must previously have been cancelled
 
Args:
    plotID (Number): box-plot window ID
    d (str): zonation dataset name
 
Returns:
    bool: operation exit status
boxPlotMultiWellCleanZone(*args, **kwargs)
boxPlotMultiWellCleanZone(plotID: Number, z: str) -> bool
 
Remove a zone in the selection from the box-plot
 
Args:
    plotID (Number): box-plot window ID
    z (str): zone name
 
Returns:
    bool: operation exit status
boxPlotMultiWellCreate(*args, **kwargs)
boxPlotMultiWellCreate(ml: list) -> Number
 
Create a multi well box-plot
 
Args:
    ml (list): mnemonic list
 
Returns:
    Number: plot window ID
boxPlotMultiWellDuplicate(*args, **kwargs)
boxPlotMultiWellDuplicate(plotID: Number) -> Number
 
Duplicate the box-plot
 
Args:
    plotID (Number): box-plot window ID
 
Returns:
    Number: new plot id or -1
boxPlotMultiWellGetIdByName(*args, **kwargs)
boxPlotMultiWellGetIdByName(n: str) -> Number
 
Find the ID of a name-known box-plot
 
Args:
    n (str): box-plot name
 
Returns:
    Number: box-plot window ID
boxPlotMultiWellMeanColor(*args, **kwargs)
boxPlotMultiWellMeanColor(plotID: Number, r: Number, g: Number, b: Number) -> bool
 
Change mean markers color in box-plot
 
Args:
    plotID (Number): box-plot window ID
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
boxPlotMultiWellMeanColour(*args, **kwargs)
boxPlotMultiWellMeanColour(plotID: Number, r: Number, g: Number, b: Number) -> bool
 
[DEPRECATED] (Use boxPlotMultiWellMeanColor instead) Change mean markers color in box-plot
 
Args:
    plotID (Number): box-plot window ID
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
boxPlotMultiWellMeanMarkers(*args, **kwargs)
boxPlotMultiWellMeanMarkers(plotID: Number, type: int, size: Number=8) -> bool
 
Change mean markers in box-plot
 
Args:
    plotID (Number): box-plot window ID
    type (int): markers type {'MARKER_CIRCLE', 'MARKER_SQUARE', 'MARKER_DIAMOND',
       'MARKER_TRIANGLE', 'MARKER_TRIANGLE_DOWN', 'MARKER_TRIANGLE_LEFT',
       'MARKER_TRIANGLE_RIGHT', 'MARKER_EMPTY_CIRCLE', 'MARKER_EMPTY_SQUARE',
       'MARKER_EMPTY_DIAMOND', 'MARKER_EMPTY_TRIANGLE', 'MARKER_EMPTY_TRIANGLE_DOWN',
       'MARKER_EMPTY_TRIANGLE_LEFT', 'MARKER_EMPTY_TRIANGLE_RIGHT', 'MARKER_SHURIKEN',
       'MARKER_EMPTY_SHURIKEN', 'MARKER_PLUS', 'MARKER_CROSS',
       'MARKER_STAR', 'MARKER_RIG', 'NB_MARKER'}
    size (Number): Optional; markers size (between 2 & 30)
 
Returns:
    bool: operation exit status
boxPlotMultiWellMeanStdDeviation(*args, **kwargs)
boxPlotMultiWellMeanStdDeviation(plotID: Number, show: bool) -> bool
 
Mean & standard deviation display in box-plot
 
Args:
    plotID (Number): box-plot window ID
    show (bool): True if show, False else
 
Returns:
    bool: operation exit status
boxPlotMultiWellOpen(*args, **kwargs)
boxPlotMultiWellOpen(n: str, f: str='') -> bool
 
Open an existing box-plot
 
Args:
    n (str): box-plot name
    f (str): Optional; folder
 
Returns:
    bool: operation exit status
boxPlotMultiWellQuantile1Value(*args, **kwargs)
boxPlotMultiWellQuantile1Value(plotID: Number, q1: Number) -> bool
 
Set user value for quantile 1
 
Args:
    plotID (Number): box-plot window ID
    q1 (Number): quantile 1 percentage
 
Returns:
    bool: operation exit status
boxPlotMultiWellQuantile2Value(*args, **kwargs)
boxPlotMultiWellQuantile2Value(plotID: Number, q2: Number) -> bool
 
Set user value for quantile 2
 
Args:
    plotID (Number): box-plot window ID
    q2 (Number): quantile 2 percentage
 
Returns:
    bool: operation exit status
boxPlotMultiWellQuantile3Value(*args, **kwargs)
boxPlotMultiWellQuantile3Value(plotID: Number, q3: Number) -> bool
 
Set user value for quantile 3
 
Args:
    plotID (Number): box-plot window ID
    q3 (Number): quantile 3 percentage
 
Returns:
    bool: operation exit status
boxPlotMultiWellQuantile4Value(*args, **kwargs)
boxPlotMultiWellQuantile4Value(plotID: Number, q4: Number) -> bool
 
Set user value for quantile 4
 
Args:
    plotID (Number): box-plot window ID
    q4 (Number): quantile 4 percentage
 
Returns:
    bool: operation exit status
boxPlotMultiWellQuantile5Value(*args, **kwargs)
boxPlotMultiWellQuantile5Value(plotID: Number, q5: Number) -> bool
 
Set user value for quantile 5
 
Args:
    plotID (Number): box-plot window ID
    q5 (Number): quantile 5 percentage
 
Returns:
    bool: operation exit status
boxPlotMultiWellQuantileValues(*args, **kwargs)
boxPlotMultiWellQuantileValues(plotID: Number, q1: Number, q2: Number, q3: Number, q4: Number, q5: Number) -> bool
 
Set user values to the box-plot quantiles
 
Args:
    plotID (Number): box-plot window ID
    q1 (Number): quantile 1 percentage
    q2 (Number): quantile 2 percentage
    q3 (Number): quantile 3 percentage
    q4 (Number): quantile 4 percentage
    q5 (Number): quantile 5 percentage
 
Returns:
    bool: operation exit status
boxPlotMultiWellRemoveDataset(*args, **kwargs)
boxPlotMultiWellRemoveDataset(plotID: Number, ds: str) -> bool
 
Remove a dataset from a multi well box-plot
 
Args:
    plotID (Number): box-plot window ID
    ds (str): dataset name
 
Returns:
    bool: operation exit status
boxPlotMultiWellRemoveWell(*args, **kwargs)
boxPlotMultiWellRemoveWell(plotID: Number, we: str) -> bool
 
Remove a well from a multi well box-plot
 
Args:
    plotID (Number): box-plot window ID
    we (str): well name
 
Returns:
    bool: operation exit status
boxPlotMultiWellSave(*args, **kwargs)
boxPlotMultiWellSave(plotID: Number, n: str, f: str='') -> bool
 
Save the box-plot
 
Args:
    plotID (Number): box-plot window ID
    n (str): box-plot window name
    f (str): Optional; folder
 
Returns:
    bool: operation exit status
boxPlotMultiWellSelectVar(*args, **kwargs)
boxPlotMultiWellSelectVar(plotID: Number, we: str, ds: str, famId: Number, vr: str) -> bool
 
[DEPRECATED] (use boxPlotMultiWellSelectVariable instead) Change the variable selected among one family's variables in a multi well box-plot
 
Args:
    plotID (Number): box-plot window ID
    we (str): well name
    ds (str): dataset name
    famId (Number): ID of the family in which you wish to change variable
    vr (str): new variable name
 
Returns:
    bool: operation exit status
boxPlotMultiWellSelectVariable(*args, **kwargs)
boxPlotMultiWellSelectVariable(plotID: Number, we: str, ds: str, famId: Number, vr: str) -> bool
 
Change the variable selected among one family's variables in a multi well box-plot
 
Args:
    plotID (Number): box-plot window ID
    we (str): well name
    ds (str): dataset name
    famId (Number): ID of the family in which you wish to change variable
    vr (str): new variable name
 
Returns:
    bool: operation exit status
boxPlotMultiWellSetAxisInverse(*args, **kwargs)
boxPlotMultiWellSetAxisInverse(plotID: Number, inv: bool) -> bool
 
Inverse a box-plot variable scale
 
Args:
    plotID (Number): box-plot window ID
    inv (bool): True if inversed, False else
 
Returns:
    bool: operation exit status
boxPlotMultiWellSetBoxBorder(*args, **kwargs)
boxPlotMultiWellSetBoxBorder(plotID: Number, r: Number, g: Number, b: Number) -> bool
 
Change boxes border color
 
Args:
    plotID (Number): box-plot window ID
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
boxPlotMultiWellSetBoxColor(*args, **kwargs)
boxPlotMultiWellSetBoxColor(plotID: Number, v: str, r: Number, g: Number, b: Number) -> bool
 
Change boxes color
 
Args:
    plotID (Number): box-plot window ID
    v (str): variable name
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
boxPlotMultiWellSetBoxColour(*args, **kwargs)
boxPlotMultiWellSetBoxColour(plotID: Number, v: str, r: Number, g: Number, b: Number) -> bool
 
[DEPRECATED] (use boxPlotMultiWellSetBoxColor instead) Change boxes color
 
Args:
    plotID (Number): box-plot window ID
    v (str): variable name
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
boxPlotMultiWellSetBoxDisplay(*args, **kwargs)
boxPlotMultiWellSetBoxDisplay(plotID: Number, type: int, size: Number=8) -> bool
 
Change boxes general display
 
Args:
    plotID (Number): box-plot window ID
    type (int): markers type {'MARKER_CIRCLE', 'MARKER_SQUARE', 'MARKER_DIAMOND',
       'MARKER_TRIANGLE', 'MARKER_TRIANGLE_DOWN', 'MARKER_TRIANGLE_LEFT',
       'MARKER_TRIANGLE_RIGHT', 'MARKER_EMPTY_CIRCLE', 'MARKER_EMPTY_SQUARE',
       'MARKER_EMPTY_DIAMOND', 'MARKER_EMPTY_TRIANGLE', 'MARKER_EMPTY_TRIANGLE_DOWN',
       'MARKER_EMPTY_TRIANGLE_LEFT', 'MARKER_EMPTY_TRIANGLE_RIGHT', 'MARKER_SHURIKEN',
       'MARKER_EMPTY_SHURIKEN', 'MARKER_PLUS', 'MARKER_CROSS',
       'MARKER_STAR', 'MARKER_RIG', 'NB_MARKER'}
    size (Number): Optional; markers size (between 2 & 30)
 
Returns:
    bool: operation exit status
boxPlotMultiWellSetName(*args, **kwargs)
boxPlotMultiWellSetName(plotID: Number, n: str) -> bool
 
Change the name of the box-plot
 
Args:
    plotID (Number): box-plot window ID
    n (str): new box-plot window name
 
Returns:
    bool: operation exit status
boxPlotMultiWellSetXAxisScale(*args, **kwargs)
boxPlotMultiWellSetXAxisScale(plotID: Number, sc: int) -> bool
 
Change a box-plot variable Y axis scale
 
Args:
    plotID (Number): box-plot window ID
    sc (int): scale type {0 = 'LINEAR', 1 = 'LOGARITHMIC'}
 
Returns:
    bool: operation exit status
boxPlotMultiWellSetXAxisType(*args, **kwargs)
boxPlotMultiWellSetXAxisType(plotID: Number, t: int) -> bool
 
Change the type of a box-plot variable Y axis
 
Args:
    plotID (Number): box-plot window ID
    t (int): Y axis type {0 = 'VAR', 1 = 'USER', 2 = 'FAMILY'}
 
Returns:
    bool: operation exit status
boxPlotMultiWellSetXAxisUnit(*args, **kwargs)
boxPlotMultiWellSetXAxisUnit(plotID: Number, u: str) -> bool
 
Change the unit of a box-plot variable Y axis
 
Args:
    plotID (Number): box-plot window ID
    u (str): Y axis unit
 
Returns:
    bool: operation exit status
boxPlotMultiWellSetXAxisUserLimits(*args, **kwargs)
boxPlotMultiWellSetXAxisUserLimits(plotID: Number, min: Number, max: Number) -> bool
 
Set min & max values of a box-plot variable Y axis
 
Args:
    plotID (Number): box-plot window ID
    min (Number): Y axis minimum
    max (Number): Y axis maximum
 
Returns:
    bool: operation exit status
boxPlotMultiWellSetZonation(*args, **kwargs)
boxPlotMultiWellSetZonation(plotID: Number, d: str) -> bool
 
Set the zonation dataset to the box-plot
 
Args:
    plotID (Number): box-plot window ID
    d (str): zonation dataset name
 
Returns:
    bool: operation exit status
boxPlotMultiWellStdDevColor(*args, **kwargs)
boxPlotMultiWellStdDevColor(plotID: Number, r: Number, g: Number, b: Number) -> bool
 
Change standard deviation markers color in box-plot
 
Args:
    plotID (Number): box-plot window ID
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
boxPlotMultiWellStdDevColour(*args, **kwargs)
boxPlotMultiWellStdDevColour(plotID: Number, r: Number, g: Number, b: Number) -> bool
 
[DEPRECATED] (use boxPlotMultiWellStdDevColor instead) Change standard deviation markers color in box-plot
 
Args:
    plotID (Number): box-plot window ID
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
boxPlotMultiWellStdDevMarkers(*args, **kwargs)
boxPlotMultiWellStdDevMarkers(plotID: Number, type: int, size: Number=8) -> bool
 
Change standard deviation markers in box-plot
 
Args:
    plotID (Number): box-plot window ID
    type (int): markers type {'MARKER_CIRCLE', 'MARKER_SQUARE', 'MARKER_DIAMOND',
       'MARKER_TRIANGLE', 'MARKER_TRIANGLE_DOWN', 'MARKER_TRIANGLE_LEFT',
       'MARKER_TRIANGLE_RIGHT', 'MARKER_EMPTY_CIRCLE', 'MARKER_EMPTY_SQUARE',
       'MARKER_EMPTY_DIAMOND', 'MARKER_EMPTY_TRIANGLE', 'MARKER_EMPTY_TRIANGLE_DOWN',
       'MARKER_EMPTY_TRIANGLE_LEFT', 'MARKER_EMPTY_TRIANGLE_RIGHT', 'MARKER_SHURIKEN',
       'MARKER_EMPTY_SHURIKEN', 'MARKER_PLUS', 'MARKER_CROSS',
       'MARKER_STAR', 'MARKER_RIG', 'NB_MARKER'}
    size (Number): Optional; markers size (between 2 & 30)
 
Returns:
    bool: operation exit status
boxPlotMultiWellStddevMarkers(*args, **kwargs)
boxPlotMultiWellStddevMarkers(plotID: Number, type: int, size: Number=8) -> bool
 
[DEPRECATED] (use boxPlotMultiWellStdDevMarkers instead) Change standard deviation markers in box-plot
 
Args:
    plotID (Number): box-plot window ID
    type (int): markers type {'MARKER_CIRCLE', 'MARKER_SQUARE', 'MARKER_DIAMOND',
       'MARKER_TRIANGLE', 'MARKER_TRIANGLE_DOWN', 'MARKER_TRIANGLE_LEFT',
       'MARKER_TRIANGLE_RIGHT', 'MARKER_EMPTY_CIRCLE', 'MARKER_EMPTY_SQUARE',
       'MARKER_EMPTY_DIAMOND', 'MARKER_EMPTY_TRIANGLE', 'MARKER_EMPTY_TRIANGLE_DOWN',
       'MARKER_EMPTY_TRIANGLE_LEFT', 'MARKER_EMPTY_TRIANGLE_RIGHT', 'MARKER_SHURIKEN',
       'MARKER_EMPTY_SHURIKEN', 'MARKER_PLUS', 'MARKER_CROSS',
       'MARKER_STAR', 'MARKER_RIG', 'NB_MARKER'}
    size (Number): Optional; markers size (between 2 & 30)
 
Returns:
    bool: operation exit status
boxPlotOpen(*args, **kwargs)
boxPlotOpen(n: str, f: str='') -> bool
 
Open an existing box-plot
 
Args:
    n (str): box-plot name
    f (str): Optional; folder
 
Returns:
    bool: operation exit status
boxPlotQuantile1Value(*args, **kwargs)
boxPlotQuantile1Value(plotID: Number, q1: Number) -> bool
 
Set user value for quantile 1
 
Args:
    plotID (Number): box-plot window ID
    q1 (Number): quantile 1 percentage
 
Returns:
    bool: operation exit status
boxPlotQuantile2Value(*args, **kwargs)
boxPlotQuantile2Value(plotID: Number, q2: Number) -> bool
 
Set user value for quantile 2
 
Args:
    plotID (Number): box-plot window ID
    q2 (Number): quantile 2 percentage
 
Returns:
    bool: operation exit status
boxPlotQuantile3Value(*args, **kwargs)
boxPlotQuantile3Value(plotID: Number, q3: Number) -> bool
 
Set user value for quantile 3
 
Args:
    plotID (Number): box-plot window ID
    q3 (Number): quantile 3 percentage
 
Returns:
    bool: operation exit status
boxPlotQuantile4Value(*args, **kwargs)
boxPlotQuantile4Value(plotID: Number, q4: Number) -> bool
 
Set user value for quantile 4
 
Args:
    plotID (Number): box-plot window ID
    q4 (Number): quantile 4 percentage
 
Returns:
    bool: operation exit status
boxPlotQuantile5Value(*args, **kwargs)
boxPlotQuantile5Value(plotID: Number, q5: Number) -> bool
 
Set user value for quantile 5
 
Args:
    plotID (Number): box-plot window ID
    q5 (Number): quantile 5 percentage
 
Returns:
    bool: operation exit status
boxPlotQuantileValues(*args, **kwargs)
boxPlotQuantileValues(plotID: Number, q1: Number, q2: Number, q3: Number, q4: Number, q5: Number) -> bool
 
Set user values to the box-plot quantiles
 
Args:
    plotID (Number): box-plot window ID
    q1 (Number): quantile 1 percentage
    q2 (Number): quantile 2 percentage
    q3 (Number): quantile 3 percentage
    q4 (Number): quantile 4 percentage
    q5 (Number): quantile 5 percentage
 
Returns:
    bool: operation exit status
boxPlotSave(*args, **kwargs)
boxPlotSave(plotID: Number, n: str, f: str='') -> bool
 
Save the box-plot
 
Args:
    plotID (Number): box-plot window ID
    n (str): box-plot window name
    f (str): Optional; folder
 
Returns:
    bool: operation exit status
boxPlotSelectFilter(*args, **kwargs)
boxPlotSelectFilter(plotID: Number, FilterValues: list) -> bool
 
Select the filter values
 
Args:
    plotID (Number): box-plot window ID
    FilterValues (list): filter values
 
Returns:
    bool: operation exit status
boxPlotSetAxisInverse(*args, **kwargs)
boxPlotSetAxisInverse(plotID: Number, v: str, inv: bool) -> bool
 
Inverse a box-plot variable scale
 
Args:
    plotID (Number): box-plot window ID
    v (str): variable name
    inv (bool): True if inversed, False else
 
Returns:
    bool: operation exit status
boxPlotSetBoxBorder(*args, **kwargs)
boxPlotSetBoxBorder(plotID: Number, r: Number, g: Number, b: Number) -> bool
 
Change boxes border color
 
Args:
    plotID (Number): box-plot window ID
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
boxPlotSetBoxColor(*args, **kwargs)
boxPlotSetBoxColor(plotID: Number, v: str, r: Number, g: Number, b: Number) -> bool
 
Change boxes color
 
Args:
    plotID (Number): box-plot window ID
    v (str): variable name
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
boxPlotSetBoxColour(*args, **kwargs)
boxPlotSetBoxColour(plotID: Number, v: str, r: Number, g: Number, b: Number) -> bool
 
[DEPRECATED] (use boxPlotSetBoxColor instead) Change boxes color
 
Args:
    plotID (Number): box-plot window ID
    v (str): variable name
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
boxPlotSetBoxDisplay(*args, **kwargs)
boxPlotSetBoxDisplay(plotID: Number, type: int, size: Number=8) -> bool
 
Change boxes general display
 
Args:
    plotID (Number): box-plot window ID
    type (int): markers type {'MARKER_CIRCLE', 'MARKER_SQUARE', 'MARKER_DIAMOND',
       'MARKER_TRIANGLE', 'MARKER_TRIANGLE_DOWN', 'MARKER_TRIANGLE_LEFT',
       'MARKER_TRIANGLE_RIGHT', 'MARKER_EMPTY_CIRCLE', 'MARKER_EMPTY_SQUARE',
       'MARKER_EMPTY_DIAMOND', 'MARKER_EMPTY_TRIANGLE', 'MARKER_EMPTY_TRIANGLE_DOWN',
       'MARKER_EMPTY_TRIANGLE_LEFT', 'MARKER_EMPTY_TRIANGLE_RIGHT', 'MARKER_SHURIKEN',
       'MARKER_EMPTY_SHURIKEN', 'MARKER_PLUS', 'MARKER_CROSS',
       'MARKER_STAR', 'MARKER_RIG', 'NB_MARKER'}
    size (Number): Optional; markers size (between 2 & 30)
 
Returns:
    bool: operation exit status
boxPlotSetDatum(*args, **kwargs)
boxPlotSetDatum(plotID: Number, lim: bool, min: Number=0, max: Number=0) -> bool
 
Change the reference limitation on box-plot
 
Args:
    plotID (Number): box-plot window ID
    lim (bool): True for user's limitaion, False else
    min (Number): Optional; top limit
    max (Number): Optional; bottom limit
 
Returns:
    bool: operation exit status
boxPlotSetFilter(*args, **kwargs)
boxPlotSetFilter(plotID: Number, f: str) -> bool
 
Set the variable as a filter
 
Args:
    plotID (Number): box-plot window ID
    f (str): variable filter
 
Returns:
    bool: operation exit status
boxPlotSetName(*args, **kwargs)
boxPlotSetName(plotID: Number, n: str) -> bool
 
Change the name of the box-plot
 
Args:
    plotID (Number): box-plot window ID
    n (str): new box-plot window name
 
Returns:
    bool: operation exit status
boxPlotSetVariablesList(*args, **kwargs)
boxPlotSetVariablesList(plotID: Number, vn: list) -> bool
 
Set the variable list to the box-plot
 
Args:
    plotID (Number): box-plot window ID
    vn (list): variable list
 
Returns:
    bool: operation exit status
boxPlotSetXAxisScale(*args, **kwargs)
boxPlotSetXAxisScale(plotID: Number, v: str, sc: int) -> bool
 
Change a box-plot variable Y axis scale
 
Args:
    plotID (Number): box-plot window ID
    v (str): variable name
    sc (int): scale type {0 = 'LINEAR', 1 = 'LOGARITHMIC'}
 
Returns:
    bool: operation exit status
boxPlotSetXAxisType(*args, **kwargs)
boxPlotSetXAxisType(plotID: Number, v: str, t: int) -> bool
 
Change the type of a box-plot variable Y axis
 
Args:
    plotID (Number): box-plot window ID
    v (str): variable name
    t (int): X axis type {0 = 'VAR', 1 = 'USER', 2 = 'FAMILY'}
 
Returns:
    bool: operation exit status
boxPlotSetXAxisUnit(*args, **kwargs)
boxPlotSetXAxisUnit(plotID: Number, v: str, u: str) -> bool
 
Change the unit of a box-plot variable Y axis
 
Args:
    plotID (Number): box-plot window ID
    v (str): variable name
    u (str): X axis unit
 
Returns:
    bool: operation exit status
boxPlotSetXAxisUserLimits(*args, **kwargs)
boxPlotSetXAxisUserLimits(plotID: Number, v: str, min: Number, max: Number) -> bool
 
Set min & max values of a box-plot variable Y axis
 
Args:
    plotID (Number): box-plot window ID
    v (str): variable name
    min (Number): X axis minimum
    max (Number): X axis maximum
 
Returns:
    bool: operation exit status
boxPlotSetZonation(*args, **kwargs)
boxPlotSetZonation(plotID: Number, d: str) -> bool
 
Set the zonation dataset to the box-plot
 
Args:
    plotID (Number): box-plot window ID
    d (str): zonation dataset name
 
Returns:
    bool: operation exit status
boxPlotStdDevColor(*args, **kwargs)
boxPlotStdDevColor(plotID: Number, r: Number, g: Number, b: Number) -> bool
 
Change standard deviation markers color in box-plot
 
Args:
    plotID (Number): box-plot window ID
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
boxPlotStdDevColour(*args, **kwargs)
boxPlotStdDevColour(plotID: Number, r: Number, g: Number, b: Number) -> bool
 
[DEPRECATED] (use boxPlotStdDevColor instead) Change standard deviation markers color in box-plot
 
Args:
    plotID (Number): box-plot window ID
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
boxPlotStdDevMarkers(*args, **kwargs)
boxPlotStdDevMarkers(plotID: Number, type: int, size: Number=8) -> bool
 
Change standard deviation markers in box-plot
 
Args:
    plotID (Number): box-plot window ID
    type (int): markers type {'MARKER_CIRCLE', 'MARKER_SQUARE', 'MARKER_DIAMOND',
       'MARKER_TRIANGLE', 'MARKER_TRIANGLE_DOWN', 'MARKER_TRIANGLE_LEFT',
       'MARKER_TRIANGLE_RIGHT', 'MARKER_EMPTY_CIRCLE', 'MARKER_EMPTY_SQUARE',
       'MARKER_EMPTY_DIAMOND', 'MARKER_EMPTY_TRIANGLE', 'MARKER_EMPTY_TRIANGLE_DOWN',
       'MARKER_EMPTY_TRIANGLE_LEFT', 'MARKER_EMPTY_TRIANGLE_RIGHT', 'MARKER_SHURIKEN',
       'MARKER_EMPTY_SHURIKEN', 'MARKER_PLUS', 'MARKER_CROSS',
       'MARKER_STAR', 'MARKER_RIG', 'NB_MARKER'}
    size (Number): Optional; markers size (between 2 & 30)
 
Returns:
    bool: operation exit status
boxPlotStddevMarkers(*args, **kwargs)
boxPlotStddevMarkers(plotID: Number, type: int, size: Number=8) -> bool
 
[DEPRECATED] (use boxPlotStdDevMarkers instead) Change standard deviation markers in box-plot
 
Args:
    plotID (Number): box-plot window ID
    type (int): markers type {'MARKER_CIRCLE', 'MARKER_SQUARE', 'MARKER_DIAMOND',
       'MARKER_TRIANGLE', 'MARKER_TRIANGLE_DOWN', 'MARKER_TRIANGLE_LEFT',
       'MARKER_TRIANGLE_RIGHT', 'MARKER_EMPTY_CIRCLE', 'MARKER_EMPTY_SQUARE',
       'MARKER_EMPTY_DIAMOND', 'MARKER_EMPTY_TRIANGLE', 'MARKER_EMPTY_TRIANGLE_DOWN',
       'MARKER_EMPTY_TRIANGLE_LEFT', 'MARKER_EMPTY_TRIANGLE_RIGHT', 'MARKER_SHURIKEN',
       'MARKER_EMPTY_SHURIKEN', 'MARKER_PLUS', 'MARKER_CROSS',
       'MARKER_STAR', 'MARKER_RIG', 'NB_MARKER'}
    size (Number): Optional; markers size (between 2 & 30)
 
Returns:
    bool: operation exit status
captureToFile(*args, **kwargs)
captureToFile(plotID: Number, captureType: str, outputFormat: str, outputName: str, resolution_dpi: Number=300) -> bool
 
Capture the plot into a file
 
Args:
    plotID (Number): object ID
    captureType (str): 'quick', 'export'
    outputFormat (str): 'jpg', 'png', 'bmp', 'cgm', 'cgm_office', 'cgm_non_unicode', 'emf', 'svg' or 'tif'
    outputName (str): file name (saved in 'Various' folder by default)
    resolution_dpi (Number): Optional; dpi resolution for export 72, 96, 150 or 300
 
Returns:
    bool: operation exit status
close(*args, **kwargs)
close(plotID: Number, vb: bool=True) -> bool
 
Close a plot
 
Args:
    plotID (Number): plot window ID
    vb (bool): Optional; ask to save
 
Returns:
    bool: operation exit status
compositePrintingAddObject(*args, **kwargs)
compositePrintingAddObject(composerID: Number, name: str, type: Number, folder: str=None) -> bool
 
Add an object to the composer
 
Args:
    composerID (Number): composer window ID
    name (str): object name
    type (Number): 0 = Header; 1 = Layout; 2 = CrossPlot; 3 = Histogram; 4 = Picture
    folder (str): Optional; object folder
 
Returns:
    bool: operation exit status
compositePrintingCreate(*args, **kwargs)
compositePrintingCreate() -> Number
 
Create a new composer
 
Returns:
    Number: plot ID
compositePrintingLayoutObjectScale(*args, **kwargs)
compositePrintingLayoutObjectScale(composerID: Number, objectIndex: Number, scale: Number) -> bool
 
Change the scale of a layout object of the composer
 
Args:
    composerID (Number): composer window ID
    objectIndex (Number): index (from 0) of the object in the list of objects
    scale (Number): new scale of the layout
 
Returns:
    bool: operation exit status
compositePrintingMoveObjectDown(*args, **kwargs)
compositePrintingMoveObjectDown(composerID: Number, objectIndex: Number) -> bool
 
Move an object down in the composer
 
Args:
    composerID (Number): composer window ID
    objectIndex (Number): index (from 0) of the object in the list of objects
 
Returns:
    bool: operation exit status
compositePrintingMoveObjectUp(*args, **kwargs)
compositePrintingMoveObjectUp(composerID: Number, objectIndex: Number) -> bool
 
Move an object up in the composer
 
Args:
    composerID (Number): composer window ID
    objectIndex (Number): index (from 0) of the object in the list of objects
 
Returns:
    bool: operation exit status
compositePrintingNew(*args, **kwargs)
compositePrintingNew(composerID: Number) -> bool
 
Reset the composer
 
Args:
    composerID (Number): composer window ID
 
Returns:
    bool: operation exit status
compositePrintingObjectApplyTo(*args, **kwargs)
compositePrintingObjectApplyTo(composerID: Number, objectIndex: Number, well: str=None, dataset: str=None) -> Number
 
Apply the object preview of the composer to a particular well and dataset
 
Args:
    composerID (Number): composer window ID
    objectIndex (Number): index (from 0) of the object in the list of objects
    well (str): Optional; well name
    dataset (str): Optional; dataset name
 
Returns:
    Number: plot ID
compositePrintingOpen(*args, **kwargs)
compositePrintingOpen(n: str, f: str=None) -> Number
 
Open an existing composer
 
Args:
    n (str): composer name
    f (str): Optional; folder
 
Returns:
    Number: plot ID
compositePrintingPreview(*args, **kwargs)
compositePrintingPreview(composerID: Number) -> bool
 
Preview the composer
 
Args:
    composerID (Number): composer window ID
 
Returns:
    bool: operation exit status
compositePrintingPreviewApplyTo(*args, **kwargs)
compositePrintingPreviewApplyTo(composerID: Number, well: str=None, dataset: str=None) -> Number
 
Apply the composer preview to a particular well and dataset
 
Args:
    composerID (Number): composer window ID
    well (str): Optional; well name
    dataset (str): Optional; dataset name
 
Returns:
    Number: plot ID
compositePrintingPreviewGet(*args, **kwargs)
compositePrintingPreviewGet() -> Number
 
Get the plot ID of the composer preview
 
Returns:
    Number: plot ID
compositePrintingPreviewPrint(*args, **kwargs)
compositePrintingPreviewPrint(hideDialog: bool) -> bool
 
Print the composer preview
 
Args:
    hideDialog (bool): 1 = hide dialog box; 0 = show dialog box
 
Returns:
    bool: operation exit status
compositePrintingPreviewSetHorizontalRulerVisibility(*args, **kwargs)
compositePrintingPreviewSetHorizontalRulerVisibility(visible: bool) -> bool
 
Change the horizontal ruler visibility of the composer preview
 
Args:
    visible (bool): 1 = show; 0 = hide
 
Returns:
    bool: operation exit status
compositePrintingPreviewSetUnit(*args, **kwargs)
compositePrintingPreviewSetUnit(unit: str) -> bool
 
Set the unit of the composer preview
 
Args:
    unit (str): new unit
 
Returns:
    bool: operation exit status
compositePrintingPreviewSetVerticalRulerVisibility(*args, **kwargs)
compositePrintingPreviewSetVerticalRulerVisibility(visible: bool) -> bool
 
Change the vertical ruler visibility of the composer preview
 
Args:
    visible (bool): 1 = show; 0 = hide
 
Returns:
    bool: operation exit status
compositePrintingRemoveObject(*args, **kwargs)
compositePrintingRemoveObject(composerID: Number, objectIndex: Number) -> bool
 
Remove an object from composer
 
Args:
    composerID (Number): composer window ID
    objectIndex (Number): index (from 0) of the object in the list of objects
 
Returns:
    bool: operation exit status
compositePrintingSave(*args, **kwargs)
compositePrintingSave(composerID: Number, n: str, f: str=None) -> bool
 
Save the composer
 
Args:
    composerID (Number): composer window ID
    n (str): composer name
    f (str): Optional; folder
 
Returns:
    bool: operation exit status
containerAddCell(*args, **kwargs)
containerAddCell(containerID: Number, cellID: Number, row: Number, column: Number, rowSpan: Number, columnSpan: Number)
 
Add the cell in specified column and row
 
Args:
    containerID (Number): container instance ID
    cellID (Number): cell ID
    row (Number): cell row
    column (Number): cell column
    rowSpan (Number): [optional] cell row span
    columnSpan (Number): [optional] cell column span
containerCellExist(*args, **kwargs)
containerCellExist(containerID: Number, cellID: Number) -> bool
 
Check if the cell exist or not
 
Args:
    containerID (Number): container instance ID
    cellID (Number): cell ID
 
Returns:
    bool: cell exist (true) or not
containerCreate(*args, **kwargs)
containerCreate(name: str, title: str) -> Number
 
Create a new container
 
Args:
    name (str): container name
    title (str): container title
 
Returns:
    Number: container ID
containerFindCell(*args, **kwargs)
containerFindCell(containerID: Number, cellID: Number) -> bool or Position
 
Find container cell by column and row
 
Args:
    containerID (Number): container instance ID
    cellID (Number): cell ID
 
Returns:
    bool or Position: if cell exist position (0 -> column, 1 -> row) else False
containerGetCell(*args, **kwargs)
containerGetCell(containerID: Number, row: Number, column: Number) -> Number
 
Get container cell by row and column
 
Args:
    containerID (Number): container instance ID
    row (Number): cell row
    column (Number): cell column
 
Returns:
    Number: cell ID
containerGetTitle(*args, **kwargs)
containerGetTitle(containerID: Number) -> str
 
Get container title
 
Args:
    containerID (Number): container instance ID
 
Returns:
    str: container title
containerGetTitleAreaHeight(*args, **kwargs)
containerGetTitleAreaHeight(containerID: Number) -> Number
 
Get container title height
 
Args:
    containerID (Number): container instance ID
 
Returns:
    Number: container title height
containerGetTitleVisible(*args, **kwargs)
containerGetTitleVisible(containerID: Number) -> bool
 
Get container visibility
 
Args:
    containerID (Number): container instance ID
 
Returns:
    bool: operation exit status
containerMoveCell(*args, **kwargs)
containerMoveCell(containerID: Number, cellID: Number, row: Number, column: Number, rowSpan: Number, columnSpan: Number)
 
Move the cell in specified column and row
 
Args:
    containerID (Number): container instance ID
    cellID (Number): cell ID
    row (Number): cell row
    column (Number): cell column
    rowSpan (Number): [optional] cell row span
    columnSpan (Number): [optional] cell column span
containerRemoveCell(*args, **kwargs)
containerRemoveCell(containerID: Number, cellID: Number)
 
Remove specified cell by ID
 
Args:
    containerID (Number): container instance ID
    cellID (Number): cell ID
containerRemoveCellFromPos(*args, **kwargs)
containerRemoveCellFromPos(containerID: Number, row: Number, column: Number)
 
[DEPRECATED] (use containerRemoveCellFromPosition instead) Remove cell in specified column and row
 
Args:
    containerID (Number): container instance ID
    row (Number): cell row
    column (Number): cell column
containerRemoveCellFromPosition(*args, **kwargs)
containerRemoveCellFromPosition(containerID: Number, row: Number, column: Number)
 
[DEPRECATED] Remove cell in specified column and row
 
Args:
    containerID (Number): container instance ID
    row (Number): cell row
    column (Number): cell column
containerSetTitle(*args, **kwargs)
containerSetTitle(containerID: Number, title: str)
 
Set container title
 
Args:
    containerID (Number): container instance ID
    title (str): container title
containerSetTitleVisible(*args, **kwargs)
containerSetTitleVisible(containerID: Number, visible: bool)
 
Set container visibility
 
Args:
    containerID (Number): container instance ID
    visible (bool): visibility state
crossPlot2ndScaleMarkers(*args, **kwargs)
crossPlot2ndScaleMarkers(plotID: Number, type: int, size: Number=5) -> bool
 
[DEPRECATED] Set type & size of cross-plot second scale's markers
 
Args:
    plotID (Number): cross-plot window ID
    type (int): markers type {'MARKER_CIRCLE', 'MARKER_SQUARE', 'MARKER_DIAMOND',
       'MARKER_TRIANGLE', 'MARKER_TRIANGLE_DOWN', 'MARKER_TRIANGLE_LEFT',
       'MARKER_TRIANGLE_RIGHT', 'MARKER_EMPTY_CIRCLE', 'MARKER_EMPTY_SQUARE',
       'MARKER_EMPTY_DIAMOND', 'MARKER_EMPTY_TRIANGLE', 'MARKER_EMPTY_TRIANGLE_DOWN',
       'MARKER_EMPTY_TRIANGLE_LEFT', 'MARKER_EMPTY_TRIANGLE_RIGHT', 'MARKER_SHURIKEN',
       'MARKER_EMPTY_SHURIKEN', 'MARKER_PLUS', 'MARKER_CROSS',
       'MARKER_STAR', 'MARKER_RIG', 'NB_MARKER'}
    size (Number): Optional; markers size
 
Returns:
    bool: operation exit status
crossPlot2ndScaleMarkersColor(*args, **kwargs)
crossPlot2ndScaleMarkersColor(plotID: Number, r: Number, g: Number, b: Number) -> bool
 
[DEPRECATED] Choose the cross-plot second scale's markers color
 
Args:
    plotID (Number): cross-plot window ID
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
crossPlot2ndScaleMarkersColour(*args, **kwargs)
crossPlot2ndScaleMarkersColour(plotID: Number, r: Number, g: Number, b: Number) -> bool
 
[DEPRECATED] (use crossPlot2ndScaleMarkersColor instead) Choose the cross-plot second scale's markers color
 
Args:
    plotID (Number): cross-plot window ID
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
crossPlot3DMonoWellDuplicate(*args, **kwargs)
crossPlot3DMonoWellDuplicate(plotID: Number) -> Number
 
Duplicate the 3D cross-plot
 
Args:
    plotID (Number): 3D cross-plot window ID
 
Returns:
    Number: new plot id or -1
crossPlot3DMultiWellDuplicate(*args, **kwargs)
crossPlot3DMultiWellDuplicate(plotID: Number) -> Number
 
Duplicate the 3D cross-plot
 
Args:
    plotID (Number): 3D cross-plot window ID
 
Returns:
    Number: new plot id or -1
crossPlotAAAddEquation(*args, **kwargs)
crossPlotAAAddEquation(plotID: Number, eq: str, n: str='', c: str='black') -> bool
 
Add an equation on cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
    eq (str): equation formula
    n (str): Optional; equation name
    c (str): Optional; color Qt name
 
Returns:
    bool: operation exit status
crossPlotAAAddRegression(*args, **kwargs)
crossPlotAAAddRegression(plotID: Number, r: Number=0, g: Number=0, b: Number=0) -> bool
 
Add a regression in a cross-plotAA & sets the color
 
Args:
    plotID (Number): cross-plotAA window ID
    r (Number): Optional; red
    g (Number): Optional; green
    b (Number): Optional; blue
 
Returns:
    bool: operation exit status
crossPlotAAAddZone(*args, **kwargs)
crossPlotAAAddZone(plotID: Number, z: str) -> bool
 
Display of a zone from cross-plotAA dataset zonation
 
Args:
    plotID (Number): cross-plotAA window ID
    z (str): zone name
 
Returns:
    bool: operation exit status
crossPlotAAApplyTo(*args, **kwargs)
crossPlotAAApplyTo(plotID: Number, ds: list) -> list
 
Apply the cross-plot AA to a data set list
 
Args:
    plotID (Number): cross-plotAA window ID
    ds (list): dataset ID (wellName.datasetName)
 
Returns:
    list: list of plotID
crossPlotAACleanZonation(*args, **kwargs)
crossPlotAACleanZonation(plotID: Number, ds: str) -> bool
 
Remove a zonation dataset from cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
    ds (str): zonation dataset
 
Returns:
    bool: operation exit status
crossPlotAACleanZone(*args, **kwargs)
crossPlotAACleanZone(plotID: Number, z: str) -> bool
 
Remove the display of a zone from cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
    z (str): zone name
 
Returns:
    bool: operation exit status
crossPlotAAClearAdvancedFilter(*args, **kwargs)
crossPlotAAClearAdvancedFilter(plotID: Number) -> bool
 
Clear the advanced filter of the cross plot
 
Args:
    plotID (Number): cross-plot window ID
 
Returns:
    bool: operation exit status
crossPlotAACreate(*args, **kwargs)
crossPlotAACreate(n: str, xn: str='', yn: str='', f: str='', xn2: str='', yn2: str='', matrixID: Number=None) -> Number
 
Create a new cross-plot AA
 
Args:
    n (str): cross-plotAA window name
    xn (str): Optional; array X name
    yn (str): Optional; array Y name
    f (str): Optional; filter variable name
    xn2 (str): Optional; second X array name
    yn2 (str): Optional; second Y array name
    matrixID (Number): Optional; if the cross-plot will be inserted into a matrix, give matrix ID
 
Returns:
    Number: cross-plotAA window ID
crossPlotAADeleteColor2Values(*args, **kwargs)
crossPlotAADeleteColor2Values(plotID: Number) -> bool
 
Delete the variable present on the second color scale of a cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
 
Returns:
    bool: operation exit status
crossPlotAADeleteColorValues(*args, **kwargs)
crossPlotAADeleteColorValues(plotID: Number) -> bool
 
Delete the variable present on the color scale of a cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
 
Returns:
    bool: operation exit status
crossPlotAADeleteFilterValues(*args, **kwargs)
crossPlotAADeleteFilterValues(plotID: Number) -> bool
 
Delete the filter variable of a cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
 
Returns:
    bool: operation exit status
crossPlotAADeleteLabelValues(*args, **kwargs)
crossPlotAADeleteLabelValues(plotID: Number) -> bool
 
Delete the variable present on the label scale of a cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
 
Returns:
    bool: operation exit status
crossPlotAADeleteX2Values(*args, **kwargs)
crossPlotAADeleteX2Values(plotID: Number) -> bool
 
Delete the variable present on the second X axis of a cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
 
Returns:
    bool: operation exit status
crossPlotAADeleteXValues(*args, **kwargs)
crossPlotAADeleteXValues(plotID: Number) -> bool
 
Delete the variable present on the X axis of a cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
 
Returns:
    bool: operation exit status
crossPlotAADeleteY2Values(*args, **kwargs)
crossPlotAADeleteY2Values(plotID: Number) -> bool
 
Delete the variable present on the second Y axis of a cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
 
Returns:
    bool: operation exit status
crossPlotAADeleteYValues(*args, **kwargs)
crossPlotAADeleteYValues(plotID: Number) -> bool
 
Delete the variable present on the Y axis of a cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
 
Returns:
    bool: operation exit status
crossPlotAADensityGridHorizontal(*args, **kwargs)
crossPlotAADensityGridHorizontal(plotID: Number, type: int, xmin: Number=0, xmax: Number=0, dim: Number=50) -> bool
 
Set characteristics of X density grid
 
Args:
    plotID (Number): cross-plotAA window ID
    type (int): type {0 = 'VARIABLE', 1 = 'USER', 2 = 'FAMILY'}
    xmin (Number): Optional; X axis minimum
    xmax (Number): Optional; X axis maximum
    dim (Number): Optional; box dimension
 
Returns:
    bool: operation exit status
crossPlotAADensityGridVertical(*args, **kwargs)
crossPlotAADensityGridVertical(plotID: Number, type: int, ymin: Number=0, ymax: Number=0, dim: Number=50) -> bool
 
Set characteristics of Y density grid
 
Args:
    plotID (Number): cross-plotAA window ID
    type (int): type {0 = 'VARIABLE', 1 = 'USER', 2 = 'FAMILY'}
    ymin (Number): Optional; Y axis minimum
    ymax (Number): Optional; Y axis maximum
    dim (Number): Optional; box dimension
 
Returns:
    bool: operation exit status
crossPlotAADensitySmooth(*args, **kwargs)
crossPlotAADensitySmooth(plotID: Number, smooth: bool) -> bool
 
Display of smoothed density values
 
Args:
    plotID (Number): cross-plotAA window ID
    smooth (bool): 1 = smooth else 0
 
Returns:
    bool: operation exit status
crossPlotAADensityType(*args, **kwargs)
crossPlotAADensityType(plotID: Number, dst: bool) -> bool
 
Display of the cross-plot in normal or density type
 
Args:
    plotID (Number): cross-plotAA window ID
    dst (bool): 1 = density display else 0
 
Returns:
    bool: operation exit status
crossPlotAADensityValue(*args, **kwargs)
crossPlotAADensityValue(plotID: Number, value: bool, percent: bool=False) -> bool
 
Display of data density values
 
Args:
    plotID (Number): cross-plotAA window ID
    value (bool): 1 = display of density value else 0
    percent (bool): Optional; 1 = display in percent else 0
 
Returns:
    bool: operation exit status
crossPlotAADisplaySecondVarOver(*args, **kwargs)
crossPlotAADisplaySecondVarOver(plotID: Number, activate: bool) -> bool
 
[DEPRECATED] (use crossPlotAADisplaySecondVariableOver instead) Display cross-plotAA second axis over the first axis
 
Args:
    plotID (Number): cross-plotAA window ID
    activate (bool): True if activated, False else
 
Returns:
    bool: operation exit status
crossPlotAADisplaySecondVariableOver(*args, **kwargs)
crossPlotAADisplaySecondVariableOver(plotID: Number, activate: bool) -> bool
 
Display cross-plotAA second axis over the first axis
 
Args:
    plotID (Number): cross-plotAA window ID
    activate (bool): True if activated, False else
 
Returns:
    bool: operation exit status
crossPlotAADuplicate(*args, **kwargs)
crossPlotAADuplicate(plotID: Number) -> Number
 
Duplicate the cross-plot AA
 
Args:
    plotID (Number): cross-plotAA window ID
 
Returns:
    Number: new plot id or -1
crossPlotAAGetAdvancedFilter(*args, **kwargs)
crossPlotAAGetAdvancedFilter(plotID: Number) -> str
 
Get the advanced filter of the cross plot
 
Args:
    plotID (Number): cross-plot window ID
 
Returns:
    str: the filter equation
crossPlotAAGetRegressions(*args, **kwargs)
crossPlotAAGetRegressions(plotID: Number) -> dict
 
get a dictionary of regressions in a cross-plot AA
 
Args:
    plotID (Number): cross-plotAA window ID
 
Returns:
    dict: dictionary of regressions
crossPlotAALinkThickness(*args, **kwargs)
crossPlotAALinkThickness(plotID: Number, thk: Number=0) -> Number
 
Link thickness cross-plotAA markers
 
Args:
    plotID (Number): cross-plotAA window ID
    thk (Number): Optional; link thikness
 
Returns:
    Number: matrix window ID
crossPlotAALockAxisX(*args, **kwargs)
crossPlotAALockAxisX(plotID: Number, locked: bool) -> bool
 
Lock x-axis limits of the cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
    locked (bool): True if locked, False else
 
Returns:
    bool: operation exit status
crossPlotAALockAxisY(*args, **kwargs)
crossPlotAALockAxisY(plotID: Number, locked: bool) -> bool
 
Lock y-axis limits of the cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
    locked (bool): True if locked, False else
 
Returns:
    bool: operation exit status
crossPlotAALockLegendX(*args, **kwargs)
crossPlotAALockLegendX(plotID: Number, locked: bool) -> bool
 
Lock x-axis legend of the cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
    locked (bool): True if locked, False else
 
Returns:
    bool: operation exit status
crossPlotAALockLegendY(*args, **kwargs)
crossPlotAALockLegendY(plotID: Number, locked: bool) -> bool
 
Lock y-axis legend of the cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
    locked (bool): True if locked, False else
 
Returns:
    bool: operation exit status
crossPlotAALockPalette(*args, **kwargs)
crossPlotAALockPalette(plotID: Number, locked: bool) -> bool
 
Lock palette of the cross-plotAV
 
Args:
    plotID (Number): cross-plotAA window ID
    locked (bool): True if locked, False else
 
Returns:
    bool: operation exit status
crossPlotAALockTitle(*args, **kwargs)
crossPlotAALockTitle(plotID: Number, locked: bool) -> bool
 
Lock title of the cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
    locked (bool): True if locked, False else
 
Returns:
    bool: operation exit status
crossPlotAAMarkers(*args, **kwargs)
crossPlotAAMarkers(plotID: Number, type: int, size: Number=5) -> bool
 
Set type & size of cross-plotAA markers
 
Args:
    plotID (Number): cross-plotAA window ID
    type (int): markers type {'MARKER_CIRCLE', 'MARKER_SQUARE', 'MARKER_DIAMOND',
       'MARKER_TRIANGLE', 'MARKER_TRIANGLE_DOWN', 'MARKER_TRIANGLE_LEFT',
       'MARKER_TRIANGLE_RIGHT', 'MARKER_EMPTY_CIRCLE', 'MARKER_EMPTY_SQUARE',
       'MARKER_EMPTY_DIAMOND', 'MARKER_EMPTY_TRIANGLE', 'MARKER_EMPTY_TRIANGLE_DOWN',
       'MARKER_EMPTY_TRIANGLE_LEFT', 'MARKER_EMPTY_TRIANGLE_RIGHT', 'MARKER_SHURIKEN',
       'MARKER_EMPTY_SHURIKEN', 'MARKER_PLUS', 'MARKER_CROSS',
       'MARKER_STAR', 'MARKER_RIG', 'NB_MARKER'}
    size (Number): Optional; markers size
 
Returns:
    bool: operation exit status
crossPlotAAMarkers2ndScale(*args, **kwargs)
crossPlotAAMarkers2ndScale(plotID: Number, type: int, size: Number=5) -> bool
 
Set type & size of cross-plotAA second scale markers
 
Args:
    plotID (Number): cross-plotAA window ID
    type (int): markers type {'MARKER_CIRCLE', 'MARKER_SQUARE', 'MARKER_DIAMOND',
       'MARKER_TRIANGLE', 'MARKER_TRIANGLE_DOWN', 'MARKER_TRIANGLE_LEFT',
       'MARKER_TRIANGLE_RIGHT', 'MARKER_EMPTY_CIRCLE', 'MARKER_EMPTY_SQUARE',
       'MARKER_EMPTY_DIAMOND', 'MARKER_EMPTY_TRIANGLE', 'MARKER_EMPTY_TRIANGLE_DOWN',
       'MARKER_EMPTY_TRIANGLE_LEFT', 'MARKER_EMPTY_TRIANGLE_RIGHT', 'MARKER_SHURIKEN',
       'MARKER_EMPTY_SHURIKEN', 'MARKER_PLUS', 'MARKER_CROSS',
       'MARKER_STAR', 'MARKER_RIG', 'NB_MARKER'}
    size (Number): Optional; markers size
 
Returns:
    bool: operation exit status
crossPlotAAMarkers2ndScaleColor(*args, **kwargs)
crossPlotAAMarkers2ndScaleColor(plotID: Number, r: Number, g: Number, b: Number) -> bool
 
Choose the cross-plotAA second scale markers color
 
Args:
    plotID (Number): cross-plotAA window ID
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
crossPlotAAMarkers2ndScaleColour(*args, **kwargs)
crossPlotAAMarkers2ndScaleColour(plotID: Number, r: Number, g: Number, b: Number) -> bool
 
[DEPRECATED] (use crossPlotAAMarkers2ndScaleColor instead) Choose the cross-plotAA second scale markers color
 
Args:
    plotID (Number): cross-plotAA window ID
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
crossPlotAAMarkersColor(*args, **kwargs)
crossPlotAAMarkersColor(plotID: Number, r: Number, g: Number, b: Number) -> bool
 
Choose the cross-plotAA markers color
 
Args:
    plotID (Number): cross-plotAA window ID
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
crossPlotAAMarkersColour(*args, **kwargs)
crossPlotAAMarkersColour(plotID: Number, r: Number, g: Number, b: Number) -> bool
 
[DEPRECATED] (use crossPlotAAMarkersColor instead) Choose the cross-plotAA markers color
 
Args:
    plotID (Number): cross-plotAA window ID
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
crossPlotAAMarkersDisplay(*args, **kwargs)
crossPlotAAMarkersDisplay(plotID: Number, display: bool=True) -> Number
 
Display of cross-plotAA markers
 
Args:
    plotID (Number): cross-plotAA window ID
    display (bool): Optional; markers display
 
Returns:
    Number: matrix window ID
crossPlotAAMultiWellAddData(*args, **kwargs)
crossPlotAAMultiWellAddData(plotID: Number, ds: list) -> bool
 
Add a dataset to a multi well cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
    ds (list): dataset ID (wellName.datasetName)
 
Returns:
    bool: operation exit status
crossPlotAAMultiWellAddEquation(*args, **kwargs)
crossPlotAAMultiWellAddEquation(plotID: Number, eq: str, n: str='', c: str='black') -> bool
 
Add an equation to an existing cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
    eq (str): equation formula
    n (str): Optional; equation name
    c (str): Optional; color Qt name
 
Returns:
    bool: operation exit status
crossPlotAAMultiWellAddRegression(*args, **kwargs)
crossPlotAAMultiWellAddRegression(plotID: Number, r: Number=0, g: Number=0, b: Number=0) -> bool
 
Add a regression in a cross-plotAA & sets the color
 
Args:
    plotID (Number): cross-plotAA window ID
    r (Number): Optional; red
    g (Number): Optional; green
    b (Number): Optional; blue
 
Returns:
    bool: operation exit status
crossPlotAAMultiWellAddRegressionByWell(*args, **kwargs)
crossPlotAAMultiWellAddRegressionByWell(plotID: Number) -> bool
 
Add a regression by well in a cross-plotAA
 
Args:
    plotID (Number): cross-plot windowAA ID
 
Returns:
    bool: operation exit status
crossPlotAAMultiWellAddRegressionByZone(*args, **kwargs)
crossPlotAAMultiWellAddRegressionByZone(plotID: Number) -> bool
 
Add a regression by zone in a cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
 
Returns:
    bool: operation exit status
crossPlotAAMultiWellAddZone(*args, **kwargs)
crossPlotAAMultiWellAddZone(plotID: Number, z: str) -> bool
 
Add a zone in the selection to the cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
    z (str): zone name
 
Returns:
    bool: operation exit status
crossPlotAAMultiWellCleanZonation(*args, **kwargs)
crossPlotAAMultiWellCleanZonation(plotID: Number, d: str) -> bool
 
Remove the zonation dataset from the cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
    d (str): zonation dataset name
 
Returns:
    bool: operation exit status
crossPlotAAMultiWellCleanZone(*args, **kwargs)
crossPlotAAMultiWellCleanZone(plotID: Number, z: str) -> bool
 
Remove a zone in the selection from the cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
    z (str): zone name
 
Returns:
    bool: operation exit status
crossPlotAAMultiWellCreate(*args, **kwargs)
crossPlotAAMultiWellCreate(ml: list) -> Number
 
Create a multi well cross-plotAA
 
Args:
    ml (list): mnemonic list
 
Returns:
    Number: cross-plotAA window ID
crossPlotAAMultiWellDensityGridHorizontal(*args, **kwargs)
crossPlotAAMultiWellDensityGridHorizontal(plotID: Number, type: int, xmin: Number=0, xmax: Number=0, dim: Number=50) -> bool
 
Set characteristics of X density grid
 
Args:
    plotID (Number): cross-plotAA window ID
    type (int): type {0 = 'VARIABLE', 1 = 'USER', 2 = 'FAMILY'}
    xmin (Number): Optional; X axis minimum
    xmax (Number): Optional; X axis maximum
    dim (Number): Optional; box dimension
 
Returns:
    bool: operation exit status
crossPlotAAMultiWellDensityGridVertical(*args, **kwargs)
crossPlotAAMultiWellDensityGridVertical(plotID: Number, type: int, ymin: Number=0, ymax: Number=0, dim: Number=50) -> bool
 
Set characteristics of Y density grid
 
Args:
    plotID (Number): cross-plotAA window ID
    type (int): type {0 = 'VARIABLE', 1 = 'USER', 2 = 'FAMILY'}
    ymin (Number): Optional; Y axis minimum
    ymax (Number): Optional; Y axis maximum
    dim (Number): Optional; box dimension
 
Returns:
    bool: operation exit status
crossPlotAAMultiWellDensitySmooth(*args, **kwargs)
crossPlotAAMultiWellDensitySmooth(plotID: Number, smooth: bool) -> bool
 
Display of smoothed density values
 
Args:
    plotID (Number): cross-plotAA window ID
    smooth (bool): 1 = smooth else 0
 
Returns:
    bool: operation exit status
crossPlotAAMultiWellDensityType(*args, **kwargs)
crossPlotAAMultiWellDensityType(plotID: Number, dst: bool) -> bool
 
Display of the cross-plotAA in normal or density type
 
Args:
    plotID (Number): cross-plotAA window ID
    dst (bool): 1 = density display else 0
 
Returns:
    bool: operation exit status
crossPlotAAMultiWellDensityValue(*args, **kwargs)
crossPlotAAMultiWellDensityValue(plotID: Number, value: bool, percent: bool=False) -> bool
 
Display of data density values
 
Args:
    plotID (Number): cross-plotAA window ID
    value (bool): 1 = display of density value else 0
    percent (bool): Optional; 1 = display in percent else 0
 
Returns:
    bool: operation exit status
crossPlotAAMultiWellDuplicate(*args, **kwargs)
crossPlotAAMultiWellDuplicate(plotID: Number) -> Number
 
Duplicate the cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
 
Returns:
    Number: new plot id or -1
crossPlotAAMultiWellIDFindByName(*args, **kwargs)
crossPlotAAMultiWellIDFindByName(n: str) -> Number
 
Find the ID of a name-known cross-plotAA
 
Args:
    n (str): cross-plotAA window name
 
Returns:
    Number: cross-plotAA window ID
crossPlotAAMultiWellLockAxisX(*args, **kwargs)
crossPlotAAMultiWellLockAxisX(plotID: Number, locked: bool) -> bool
 
Lock x-axis limits of the cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
    locked (bool): True if locked, False else
 
Returns:
    bool: operation exit status
crossPlotAAMultiWellLockAxisY(*args, **kwargs)
crossPlotAAMultiWellLockAxisY(plotID: Number, locked: bool) -> bool
 
Lock y-axis limits of the cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
    locked (bool): True if locked, False else
 
Returns:
    bool: operation exit status
crossPlotAAMultiWellLockLegendX(*args, **kwargs)
crossPlotAAMultiWellLockLegendX(plotID: Number, locked: bool) -> bool
 
Lock x-axis legend of the cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
    locked (bool): True if locked, False else
 
Returns:
    bool: operation exit status
crossPlotAAMultiWellLockLegendY(*args, **kwargs)
crossPlotAAMultiWellLockLegendY(plotID: Number, locked: bool) -> bool
 
Lock y-axis legend of the cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
    locked (bool): True if locked, False else
 
Returns:
    bool: operation exit status
crossPlotAAMultiWellLockPalette(*args, **kwargs)
crossPlotAAMultiWellLockPalette(plotID: Number, locked: bool) -> bool
 
Lock palette of the cross-plotAV
 
Args:
    plotID (Number): cross-plotAA window ID
    locked (bool): True if locked, False else
 
Returns:
    bool: operation exit status
crossPlotAAMultiWellLockTitle(*args, **kwargs)
crossPlotAAMultiWellLockTitle(plotID: Number, locked: bool) -> bool
 
Lock title of the cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
    locked (bool): True if locked, False else
 
Returns:
    bool: operation exit status
crossPlotAAMultiWellOpen(*args, **kwargs)
crossPlotAAMultiWellOpen(n: str, f: str=None) -> bool
 
Open an existing cross-plotAA multi-well
 
Args:
    n (str): cross-plotAA multi-well name
    f (str): Optional; folder
 
Returns:
    bool: operation exit status
crossPlotAAMultiWellRemoveAllEquations(*args, **kwargs)
crossPlotAAMultiWellRemoveAllEquations(plotID: Number) -> bool
 
Remove all equations from an existing cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
 
Returns:
    bool: operation exit status
crossPlotAAMultiWellRemoveDataset(*args, **kwargs)
crossPlotAAMultiWellRemoveDataset(plotID: Number, we: str) -> bool
 
Remove a dataset from a multi well cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
    we (str): dataset name
 
Returns:
    bool: operation exit status
crossPlotAAMultiWellRemoveEquation(*args, **kwargs)
crossPlotAAMultiWellRemoveEquation(plotID: Number, eq: str) -> bool
 
Remove an equation from an existing cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
    eq (str): equation name
 
Returns:
    bool: operation exit status
crossPlotAAMultiWellRemoveWell(*args, **kwargs)
crossPlotAAMultiWellRemoveWell(plotID: Number, we: str) -> bool
 
Remove a well from a multi well cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
    we (str): well name
 
Returns:
    bool: operation exit status
crossPlotAAMultiWellReverseAxes(*args, **kwargs)
crossPlotAAMultiWellReverseAxes(plotID: Number) -> bool
 
Reverse the cross-plotAA axes
 
Args:
    plotID (Number): cross-plotAA window ID
 
Returns:
    bool: operation exit status
crossPlotAAMultiWellSave(*args, **kwargs)
crossPlotAAMultiWellSave(plotID: Number, n: str, f: str='') -> bool
 
Save the cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
    n (str): cross-plotAA name
    f (str): Optional; folder
 
Returns:
    bool: operation exit status
crossPlotAAMultiWellSelectVar(*args, **kwargs)
crossPlotAAMultiWellSelectVar(plotID: Number, we: str, ds: str, famId: Number, vr: str) -> bool
 
Change the variable selected among one family's variables in a multi well cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
    we (str): well name
    ds (str): dataset name
    famId (Number): ID of the family in which you wish to change variable
    vr (str): new variable name
 
Returns:
    bool: operation exit status
crossPlotAAMultiWellSetName(*args, **kwargs)
crossPlotAAMultiWellSetName(plotID: Number, n: str) -> bool
 
Change the name of multiwell cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
    n (str): new cross-plotAA name
 
Returns:
    bool: operation exit status
crossPlotAAMultiWellSetPaletteBoundaries(*args, **kwargs)
crossPlotAAMultiWellSetPaletteBoundaries(plotID: Number, min: Number, max: Number) -> bool
 
Set the boundaries of the palette for a multi-well cross plot AA.
 
Args:
    plotID (Number): plot window ID
    min (Number): minimum of the palette
    max (Number): maximum of the palette
 
Returns:
    bool: operation exit status
crossPlotAAMultiWellSetXAxisInverse(*args, **kwargs)
crossPlotAAMultiWellSetXAxisInverse(plotID: Number, xainv: bool) -> bool
 
Inverse the cross-plotAA X axis
 
Args:
    plotID (Number): cross-plotAA window ID
    xainv (bool): 1 = inverse else 0
 
Returns:
    bool: operation exit status
crossPlotAAMultiWellSetXAxisScale(*args, **kwargs)
crossPlotAAMultiWellSetXAxisScale(plotID: Number, xasc: int) -> bool
 
Set the cross-plotAA X axis scale
 
Args:
    plotID (Number): cross-plotAA window ID
    xasc (int): scale type {0 = 'LINEAR', 1 = 'LOGARITHMIC'}
 
Returns:
    bool: operation exit status
crossPlotAAMultiWellSetXAxisType(*args, **kwargs)
crossPlotAAMultiWellSetXAxisType(plotID: Number, xat: int) -> bool
 
Change the type of cross-plotAA X axis
 
Args:
    plotID (Number): cross-plotAA window ID
    xat (int): X axis type {0 = 'VAR', 1 = 'USER', 2 = 'FAMILY'}
 
Returns:
    bool: operation exit status
crossPlotAAMultiWellSetXAxisUnit(*args, **kwargs)
crossPlotAAMultiWellSetXAxisUnit(plotID: Number, xau: str) -> bool
 
Change the unit of cross-plotAA X axis
 
Args:
    plotID (Number): cross-plotAA window ID
    xau (str): X axis unit
 
Returns:
    bool: operation exit status
crossPlotAAMultiWellSetXAxisUserLimits(*args, **kwargs)
crossPlotAAMultiWellSetXAxisUserLimits(plotID: Number, xamin: Number, xamax: Number) -> bool
 
Set min & max values of cross-plotAA X axis
 
Args:
    plotID (Number): cross-plotAA window ID
    xamin (Number): X axis minimum
    xamax (Number): X axis maximum
 
Returns:
    bool: operation exit status
crossPlotAAMultiWellSetYAxisInverse(*args, **kwargs)
crossPlotAAMultiWellSetYAxisInverse(plotID: Number, yainv: bool) -> bool
 
Inverse the cross-plotAA Y axis
 
Args:
    plotID (Number): cross-plotAA window ID
    yainv (bool): 1 = inverse else 0
 
Returns:
    bool: operation exit status
crossPlotAAMultiWellSetYAxisScale(*args, **kwargs)
crossPlotAAMultiWellSetYAxisScale(plotID: Number, yasc: int) -> bool
 
Set the cross-plotAA Y axis scale
 
Args:
    plotID (Number): cross-plotAA window ID
    yasc (int): scale type {0 = 'LINEAR', 1 = 'LOGARITHMIC'}
 
Returns:
    bool: operation exit status
crossPlotAAMultiWellSetYAxisType(*args, **kwargs)
crossPlotAAMultiWellSetYAxisType(plotID: Number, yat: int) -> bool
 
Change the type of cross-plotAA Y axis
 
Args:
    plotID (Number): cross-plotAA window ID
    yat (int): Y axis type {0 = 'VAR', 1 = 'USER', 2 = 'FAMILY'}
 
Returns:
    bool: operation exit status
crossPlotAAMultiWellSetYAxisUnit(*args, **kwargs)
crossPlotAAMultiWellSetYAxisUnit(plotID: Number, yau: str) -> bool
 
Change the unit of cross-plotAA Y axis
 
Args:
    plotID (Number): cross-plotAA window ID
    yau (str): Y axis unit
 
Returns:
    bool: operation exit status
crossPlotAAMultiWellSetYAxisUserLimits(*args, **kwargs)
crossPlotAAMultiWellSetYAxisUserLimits(plotID: Number, yamin: Number, yamax: Number) -> bool
 
Set min & max values of cross-plotAA Y axis
 
Args:
    plotID (Number): cross-plotAA window ID
    yamin (Number): Y axis minimum
    yamax (Number): Y axis maximum
 
Returns:
    bool: operation exit status
crossPlotAAMultiWellSetZonation(*args, **kwargs)
crossPlotAAMultiWellSetZonation(plotID: Number, d: str) -> bool
 
Set the zonation dataset to the cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
    d (str): zonation dataset name
 
Returns:
    bool: operation exit status
crossPlotAAOpen(*args, **kwargs)
crossPlotAAOpen(n: str, f: str='') -> bool
 
Open an existing cross-plotAA
 
Args:
    n (str): cross-plotAA name
    f (str): Optional; folder
 
Returns:
    bool: operation exit status
crossPlotAARemoveAllEquations(*args, **kwargs)
crossPlotAARemoveAllEquations(plotID: Number) -> bool
 
Remove all equations from an existing cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
 
Returns:
    bool: operation exit status
crossPlotAARemoveEquation(*args, **kwargs)
crossPlotAARemoveEquation(plotID: Number, eq: str) -> bool
 
Remove an equation from an existing cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
    eq (str): equation name
 
Returns:
    bool: operation exit status
crossPlotAAReverseAxes(*args, **kwargs)
crossPlotAAReverseAxes(plotID: Number) -> bool
 
Reverse the cross-plotAA axes
 
Args:
    plotID (Number): cross-plotAA window ID
 
Returns:
    bool: operation exit status
crossPlotAASave(*args, **kwargs)
crossPlotAASave(plotID: Number, n: str, f: str='') -> bool
 
Save a cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
    n (str): saving name
    f (str): Optional; folder
 
Returns:
    bool: operation exit status
crossPlotAASelectFilter(*args, **kwargs)
crossPlotAASelectFilter(plotID: Number, FilterValues: list) -> bool
 
Select the filter values
 
Args:
    plotID (Number): cross-plotAA window ID
    FilterValues (list): filter values
 
Returns:
    bool: operation exit status
crossPlotAASetAdvancedFilter(*args, **kwargs)
crossPlotAASetAdvancedFilter(plotID: Number, Equation: str) -> bool
 
Set an advanced filter on the cross plot
 
Args:
    plotID (Number): cross-plot window ID
    Equation (str): equation defining the filter
 
Returns:
    bool: operation exit status
crossPlotAASetColor(*args, **kwargs)
crossPlotAASetColor(plotID: Number, vn: str) -> bool
 
Set a color variable to cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
    vn (str): variable ID
 
Returns:
    bool: operation exit status
crossPlotAASetColor2(*args, **kwargs)
crossPlotAASetColor2(plotID: Number, vn: str) -> bool
 
Set a color variable to the second axis of a cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
    vn (str): variable ID
 
Returns:
    bool: operation exit status
crossPlotAASetDatum(*args, **kwargs)
crossPlotAASetDatum(plotID: Number, lim: bool, min: Number=0, max: Number) -> bool
 
Change the reference limitation on cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
    lim (bool): True for user's limitaion, False else
    min (Number): Optional; top limit
    max (Number): bottom limit
 
Returns:
    bool: operation exit status
crossPlotAASetFilter(*args, **kwargs)
crossPlotAASetFilter(plotID: Number, vn: str) -> bool
 
Set filter to cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
    vn (str): array name
 
Returns:
    bool: operation exit status
crossPlotAASetLabel(*args, **kwargs)
crossPlotAASetLabel(plotID: Number, vn: str) -> bool
 
Set a label variable to cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
    vn (str): variable ID
 
Returns:
    bool: operation exit status
crossPlotAASetName(*args, **kwargs)
crossPlotAASetName(plotID: Number, n: str) -> bool
 
Change cross-plotAA window name
 
Args:
    plotID (Number): cross-plotAA window ID
    n (str): new name
 
Returns:
    bool: operation exit status
crossPlotAASetPaletteBoundaries(*args, **kwargs)
crossPlotAASetPaletteBoundaries(plotID: Number, min: Number, max: Number) -> bool
 
Set the boundaries of the palette for a single-well cross plot AA.
 
Args:
    plotID (Number): plot window ID
    min (Number): minimum of the palette
    max (Number): maximum of the palette
 
Returns:
    bool: operation exit status
crossPlotAASetSecondYScale(*args, **kwargs)
crossPlotAASetSecondYScale(plotID: Number, vn: str) -> bool
 
Set array variable to second Y axis of a cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
    vn (str): array variable ID
 
Returns:
    bool: operation exit status
crossPlotAASetX(*args, **kwargs)
crossPlotAASetX(plotID: Number, vn: str) -> bool
 
Set array variable to X axis of a cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
    vn (str): array variable ID
 
Returns:
    bool: operation exit status
crossPlotAASetX2(*args, **kwargs)
crossPlotAASetX2(plotID: Number, vn: str) -> bool
 
Set array variable to the second X axis of a cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
    vn (str): array variable ID
 
Returns:
    bool: operation exit status
crossPlotAASetX2Values(*args, **kwargs)
crossPlotAASetX2Values(plotID: Number, vn: str, vl: list, fam: str='', un: str='') -> bool
 
Set a fictive set of user variables to the second X axis of a cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
    vn (str): array name
    vl (list): list of values
    fam (str): Optional; array family
    un (str): Optional; array unit
 
Returns:
    bool: operation exit status
crossPlotAASetXAxisInverse(*args, **kwargs)
crossPlotAASetXAxisInverse(plotID: Number, xainv: bool) -> bool
 
Inverse the cross-plotAA X axis
 
Args:
    plotID (Number): cross-plotAA window ID
    xainv (bool): 1 = inverse else 0
 
Returns:
    bool: operation exit status
crossPlotAASetXAxisScale(*args, **kwargs)
crossPlotAASetXAxisScale(plotID: Number, xasc: int) -> bool
 
Set the cross-plotAA X axis scale
 
Args:
    plotID (Number): cross-plotAA window ID
    xasc (int): scale type {0 = 'LINEAR', 1 = 'LOGARITHMIC'}
 
Returns:
    bool: operation exit status
crossPlotAASetXAxisType(*args, **kwargs)
crossPlotAASetXAxisType(plotID: Number, xat: int) -> bool
 
Change the type of cross-plotAA X axis
 
Args:
    plotID (Number): cross-plotAA window ID
    xat (int): X axis type {0 = 'VAR', 1 = 'USER', 2 = 'FAMILY'}
 
Returns:
    bool: operation exit status
crossPlotAASetXAxisUnit(*args, **kwargs)
crossPlotAASetXAxisUnit(plotID: Number, xau: str) -> bool
 
Change the unit of cross-plotAA X axis
 
Args:
    plotID (Number): cross-plotAA window ID
    xau (str): X axis unit
 
Returns:
    bool: operation exit status
crossPlotAASetXAxisUserLimits(*args, **kwargs)
crossPlotAASetXAxisUserLimits(plotID: Number, xamin: Number, xamax: Number) -> bool
 
Set min & max values of cross-plotAA X axis
 
Args:
    plotID (Number): cross-plotAA window ID
    xamin (Number): X axis minimum
    xamax (Number): X axis maximum
 
Returns:
    bool: operation exit status
crossPlotAASetXValues(*args, **kwargs)
crossPlotAASetXValues(plotID: Number, vn: str, vl: list, fam: str='', un: str='') -> bool
 
Set a fictive set of user variables to the X axis of a cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
    vn (str): array name
    vl (list): list of values
    fam (str): Optional; array family
    un (str): Optional; array unit
 
Returns:
    bool: operation exit status
crossPlotAASetY(*args, **kwargs)
crossPlotAASetY(plotID: Number, vn: str) -> bool
 
Set array variable to Y axis of a cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
    vn (str): array variable ID
 
Returns:
    bool: operation exit status
crossPlotAASetY2(*args, **kwargs)
crossPlotAASetY2(plotID: Number, vn: str) -> bool
 
Set array variable to the second Y axis of a cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
    vn (str): array variable ID
 
Returns:
    bool: operation exit status
crossPlotAASetY2Values(*args, **kwargs)
crossPlotAASetY2Values(plotID: Number, vn: str, vl: list, fam: str='', un: str='') -> bool
 
Set a fictive set of user variables to the second Y axis of a cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
    vn (str): array name
    vl (list): list of values
    fam (str): Optional; array family
    un (str): Optional; array unit
 
Returns:
    bool: operation exit status
crossPlotAASetYAxisInverse(*args, **kwargs)
crossPlotAASetYAxisInverse(plotID: Number, yainv: bool) -> bool
 
Inverse the cross-plotAA Y axis
 
Args:
    plotID (Number): cross-plotAA window ID
    yainv (bool): 1 = inverse else 0
 
Returns:
    bool: operation exit status
crossPlotAASetYAxisScale(*args, **kwargs)
crossPlotAASetYAxisScale(plotID: Number, yasc: int) -> bool
 
Set the cross-plotAA Y axis scale
 
Args:
    plotID (Number): cross-plotAA window ID
    yasc (int): scale type {0 = 'LINEAR', 1 = 'LOGARITHMIC'}
 
Returns:
    bool: operation exit status
crossPlotAASetYAxisType(*args, **kwargs)
crossPlotAASetYAxisType(plotID: Number, yat: int) -> bool
 
Change the type of cross-plotAA Y axis
 
Args:
    plotID (Number): cross-plotAA window ID
    yat (int): Y axis type {0 = 'VAR', 1 = 'USER', 2 = 'FAMILY'}
 
Returns:
    bool: operation exit status
crossPlotAASetYAxisUnit(*args, **kwargs)
crossPlotAASetYAxisUnit(plotID: Number, yau: str) -> bool
 
Change the unit of cross-plotAA Y axis
 
Args:
    plotID (Number): cross-plotAA window ID
    yau (str): Y axis unit
 
Returns:
    bool: operation exit status
crossPlotAASetYAxisUserLimits(*args, **kwargs)
crossPlotAASetYAxisUserLimits(plotID: Number, yamin: Number, yamax: Number) -> bool
 
Set min & max values of cross-plotAA Y axis
 
Args:
    plotID (Number): cross-plotAA window ID
    yamin (Number): Y axis minimum
    yamax (Number): Y axis maximum
 
Returns:
    bool: operation exit status
crossPlotAASetYValues(*args, **kwargs)
crossPlotAASetYValues(plotID: Number, vn: str, vl: list, fam: str='', un: str='') -> bool
 
Set a fictive set of user variables to the Y axis of a cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
    vn (str): array name
    vl (list): list of values
    fam (str): Optional; array family
    un (str): Optional; array unit
 
Returns:
    bool: operation exit status
crossPlotAASetZonation(*args, **kwargs)
crossPlotAASetZonation(plotID: Number, ds: str) -> bool
 
Apply a zonation dataset to cross-plotAA
 
Args:
    plotID (Number): cross-plotAA window ID
    ds (str): zonation dataset
 
Returns:
    bool: operation exit status
crossPlotAVAAddEquation(*args, **kwargs)
crossPlotAVAAddEquation(plotID: Number, eq: str, n: str='', c: str='black') -> bool
 
Add an equation to an existing cross-plotAVA
 
Args:
    plotID (Number): cross-plotAVA window ID
    eq (str): equation formula
    n (str): Optional; equation name
    c (str): Optional; color Qt name
 
Returns:
    bool: operation exit status
crossPlotAVAAddRegression(*args, **kwargs)
crossPlotAVAAddRegression(plotID: Number, r: Number=0, g: Number=0, b: Number=0) -> bool
 
Add a regression in a cross-plotAVA & sets the color
 
Args:
    plotID (Number): cross-plotAVA window ID
    r (Number): Optional; red
    g (Number): Optional; green
    b (Number): Optional; blue
 
Returns:
    bool: operation exit status
crossPlotAVAAddZone(*args, **kwargs)
crossPlotAVAAddZone(plotID: Number, z: str) -> bool
 
Add a zone in the selection to the cross-plotAVA
 
Args:
    plotID (Number): cross-plotAVA window ID
    z (str): zone name
 
Returns:
    bool: operation exit status
crossPlotAVAApplyTo(*args, **kwargs)
crossPlotAVAApplyTo(plotID: Number, ds: list) -> list
 
Apply the cross-plotAVAto a data set list
 
Args:
    plotID (Number): cross-plotAVA window ID
    ds (list): dataset ID (wellName.datasetName)
 
Returns:
    list: list of plotID
crossPlotAVACleanZonation(*args, **kwargs)
crossPlotAVACleanZonation(plotID: Number, d: str) -> bool
 
Remove the zonation dataset from the cross-plotAVA
 
Args:
    plotID (Number): cross-plotAVA window ID
    d (str): zonation dataset name
 
Returns:
    bool: operation exit status
crossPlotAVACleanZone(*args, **kwargs)
crossPlotAVACleanZone(plotID: Number, z: str) -> bool
 
Remove a zone in the selection from the cross-plotAVA
 
Args:
    plotID (Number): cross-plotAVA window ID
    z (str): zone name
 
Returns:
    bool: operation exit status
crossPlotAVAClearAdvancedFilter(*args, **kwargs)
crossPlotAVAClearAdvancedFilter(plotID: Number) -> bool
 
Clear the advanced filter of the cross plot
 
Args:
    plotID (Number): cross-plot window ID
 
Returns:
    bool: operation exit status
crossPlotAVACreate(*args, **kwargs)
crossPlotAVACreate(n: str, xn: str='', yn: str='', f: str='', matrixID: Number=None) -> Number
 
Create a new cross-plotAVA
 
Args:
    n (str): cross-plotAVA window name
    xn (str): Optional; variable X name
    yn (str): Optional; variable Y name
    f (str): Optional; filter variable name
    matrixID (Number): Optional; if the cross-plot will be inserted into a matrix, give matrix ID
 
Returns:
    Number: cross-plotAVA window ID
crossPlotAVADeleteColorValues(*args, **kwargs)
crossPlotAVADeleteColorValues(plotID: Number) -> bool
 
Delete the variable present on the color scale of a cross-plotAVA
 
Args:
    plotID (Number): cross-plotAVA window ID
 
Returns:
    bool: operation exit status
crossPlotAVADeleteFilterValues(*args, **kwargs)
crossPlotAVADeleteFilterValues(plotID: Number) -> bool
 
Delete the filter variable of a cross-plotAVA
 
Args:
    plotID (Number): cross-plotAVA window ID
 
Returns:
    bool: operation exit status
crossPlotAVADeleteXValues(*args, **kwargs)
crossPlotAVADeleteXValues(plotID: Number) -> bool
 
Delete the variable present on the X axis of a cross-plotAVA
 
Args:
    plotID (Number): cross-plotAVA window ID
 
Returns:
    bool: operation exit status
crossPlotAVADeleteYValues(*args, **kwargs)
crossPlotAVADeleteYValues(plotID: Number) -> bool
 
Delete the variable present on the Y axis of a cross-plotAVA
 
Args:
    plotID (Number): cross-plotAVA window ID
 
Returns:
    bool: operation exit status
crossPlotAVADensityGridHorizontal(*args, **kwargs)
crossPlotAVADensityGridHorizontal(plotID: Number, type: int, xmin: Number=0, xmax: Number=0, dim: Number=50) -> bool
 
Set characteristics of X density grid
 
Args:
    plotID (Number): cross-plotAVA window ID
    type (int): type {0 = 'VARIABLE', 1 = 'USER', 2 = 'FAMILY'}
    xmin (Number): Optional; X axis minimum
    xmax (Number): Optional; X axis maximum
    dim (Number): Optional; box dimension
 
Returns:
    bool: operation exit status
crossPlotAVADensityGridVertical(*args, **kwargs)
crossPlotAVADensityGridVertical(plotID: Number, type: int, ymin: Number=0, ymax: Number=0, dim: Number=50) -> bool
 
Set characteristics of Y density grid
 
Args:
    plotID (Number): cross-plotAVA window ID
    type (int): type {0 = 'VARIABLE', 1 = 'USER', 2 = 'FAMILY'}
    ymin (Number): Optional; Y axis minimum
    ymax (Number): Optional; Y axis maximum
    dim (Number): Optional; box dimension
 
Returns:
    bool: operation exit status
crossPlotAVADensitySmooth(*args, **kwargs)
crossPlotAVADensitySmooth(plotID: Number, smooth: bool) -> bool
 
Display of smoothed density values
 
Args:
    plotID (Number): cross-plotAVA window ID
    smooth (bool): 1 = smooth else 0
 
Returns:
    bool: operation exit status
crossPlotAVADensityType(*args, **kwargs)
crossPlotAVADensityType(plotID: Number, dst: bool) -> bool
 
Display of the cross-plotAVA in normal or density type
 
Args:
    plotID (Number): cross-plotAVA window ID
    dst (bool): 1 = density display else 0
 
Returns:
    bool: operation exit status
crossPlotAVADensityValue(*args, **kwargs)
crossPlotAVADensityValue(plotID: Number, value: bool, percent: bool=False) -> bool
 
Display of data density values
 
Args:
    plotID (Number): cross-plotAVA window ID
    value (bool): 1 = display of density value else 0
    percent (bool): Optional; 1 = display in percent else 0
 
Returns:
    bool: operation exit status
crossPlotAVADuplicate(*args, **kwargs)
crossPlotAVADuplicate(plotID: Number) -> Number
 
Duplicate the cross-plotAVA
 
Args:
    plotID (Number): cross-plotAVA window ID
 
Returns:
    Number: new plot id or -1
crossPlotAVAGetAdvancedFilter(*args, **kwargs)
crossPlotAVAGetAdvancedFilter(plotID: Number) -> str
 
Get the advanced filter of the cross plot
 
Args:
    plotID (Number): cross-plot window ID
 
Returns:
    str: the filter equation
crossPlotAVAGetIdByName(*args, **kwargs)
crossPlotAVAGetIdByName(n: str) -> Number
 
Find the ID of a name-known cross-plotAVA
 
Args:
    n (str): cross-plotAVA window name
 
Returns:
    Number: cross-plotAVA window ID
crossPlotAVAGetRegressions(*args, **kwargs)
crossPlotAVAGetRegressions(plotID: Number) -> dict
 
get a dictionary of regressions in a cross-plot AVA
 
Args:
    plotID (Number): cross-plot window ID
 
Returns:
    dict: dictionary of regressions
crossPlotAVALockAxisX(*args, **kwargs)
crossPlotAVALockAxisX(plotID: Number, locked: bool) -> bool
 
Lock x-axis limits of the cross-plotAVA
 
Args:
    plotID (Number): cross-plotAVA window ID
    locked (bool): True if locked, False else
 
Returns:
    bool: operation exit status
crossPlotAVALockAxisY(*args, **kwargs)
crossPlotAVALockAxisY(plotID: Number, locked: bool) -> bool
 
Lock y-axis limits of the cross-plotAVA
 
Args:
    plotID (Number): cross-plotAVA window ID
    locked (bool): True if locked, False else
 
Returns:
    bool: operation exit status
crossPlotAVALockLegendX(*args, **kwargs)
crossPlotAVALockLegendX(plotID: Number, locked: bool) -> bool
 
Lock x-axis legend of the cross-plotAVA
 
Args:
    plotID (Number): cross-plotAVA window ID
    locked (bool): True if locked, False else
 
Returns:
    bool: operation exit status
crossPlotAVALockLegendY(*args, **kwargs)
crossPlotAVALockLegendY(plotID: Number, locked: bool) -> bool
 
Lock y-axis legend of the cross-plotAVA
 
Args:
    plotID (Number): cross-plotAVA window ID
    locked (bool): True if locked, False else
 
Returns:
    bool: operation exit status
crossPlotAVALockPalette(*args, **kwargs)
crossPlotAVALockPalette(plotID: Number, locked: bool) -> bool
 
Lock palette of the cross-plotAVA
 
Args:
    plotID (Number): cross-plotAVA window ID
    locked (bool): True if locked, False else
 
Returns:
    bool: operation exit status
crossPlotAVALockTitle(*args, **kwargs)
crossPlotAVALockTitle(plotID: Number, locked: bool) -> bool
 
Lock title of the cross-plotAVA
 
Args:
    plotID (Number): cross-plotAVA window ID
    locked (bool): True if locked, False else
 
Returns:
    bool: operation exit status
crossPlotAVAMarkers(*args, **kwargs)
crossPlotAVAMarkers(plotID: Number, type: int, size: Number=5) -> bool
 
Set type & size of cross-plotAVA markers
 
Args:
    plotID (Number): cross-plotAVA window ID
    type (int): markers type {'MARKER_CIRCLE', 'MARKER_SQUARE', 'MARKER_DIAMOND',
       'MARKER_TRIANGLE', 'MARKER_TRIANGLE_DOWN', 'MARKER_TRIANGLE_LEFT',
       'MARKER_TRIANGLE_RIGHT', 'MARKER_EMPTY_CIRCLE', 'MARKER_EMPTY_SQUARE',
       'MARKER_EMPTY_DIAMOND', 'MARKER_EMPTY_TRIANGLE', 'MARKER_EMPTY_TRIANGLE_DOWN',
       'MARKER_EMPTY_TRIANGLE_LEFT', 'MARKER_EMPTY_TRIANGLE_RIGHT', 'MARKER_SHURIKEN',
       'MARKER_EMPTY_SHURIKEN', 'MARKER_PLUS', 'MARKER_CROSS',
       'MARKER_STAR', 'MARKER_RIG', 'NB_MARKER'}
    size (Number): Optional; markers size
 
Returns:
    bool: operation exit status
crossPlotAVAMarkersColor(*args, **kwargs)
crossPlotAVAMarkersColor(plotID: Number, r: Number, g: Number, b: Number) -> bool
 
Choose the cross-plotAVA markers color
 
Args:
    plotID (Number): cross-plotAVA window ID
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
crossPlotAVAMarkersColour(*args, **kwargs)
crossPlotAVAMarkersColour(plotID: Number, r: Number, g: Number, b: Number) -> bool
 
[DEPRECATED] (use crossPlotAVAMarkersColor instead) Choose the cross-plotAVA markers color
 
Args:
    plotID (Number): cross-plotAVA window ID
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
crossPlotAVAOpen(*args, **kwargs)
crossPlotAVAOpen(n: str, f: str='') -> Number
 
Open an existing cross-plotAVA
 
Args:
    n (str): cross-plotAVA name
    f (str): Optional; folder
 
Returns:
    Number: cross-plotAVA window ID
crossPlotAVARemoveAllEquations(*args, **kwargs)
crossPlotAVARemoveAllEquations(plotID: Number) -> bool
 
Remove all equations from an existing cross-plotAVA
 
Args:
    plotID (Number): cross-plotAVA window ID
 
Returns:
    bool: operation exit status
crossPlotAVARemoveEquation(*args, **kwargs)
crossPlotAVARemoveEquation(plotID: Number, eq: str) -> bool
 
Remove an equation from an existing cross-plotAVA
 
Args:
    plotID (Number): cross-plotAVA window ID
    eq (str): equation name
 
Returns:
    bool: operation exit status
crossPlotAVAReverseAxes(*args, **kwargs)
crossPlotAVAReverseAxes(plotID: Number) -> bool
 
Reverse the cross-plotAVA axes
 
Args:
    plotID (Number): cross-plotAVA window ID
 
Returns:
    bool: operation exit status
crossPlotAVASave(*args, **kwargs)
crossPlotAVASave(plotID: Number, n: str, f: str='') -> bool
 
Save the cross-plotAVA
 
Args:
    plotID (Number): cross-plotAVA window ID
    n (str): cross-plotAVA name
    f (str): Optional; folder
 
Returns:
    bool: operation exit status
crossPlotAVASelectFilter(*args, **kwargs)
crossPlotAVASelectFilter(plotID: Number, FilterValues: list) -> bool
 
Select the filter values
 
Args:
    plotID (Number): cross-plotAVA window ID
    FilterValues (list): filter values
 
Returns:
    bool: operation exit status
crossPlotAVASetAdvancedFilter(*args, **kwargs)
crossPlotAVASetAdvancedFilter(plotID: Number, Equation: str) -> bool
 
Set an advanced filter on the cross plot
 
Args:
    plotID (Number): cross-plot window ID
    Equation (str): equation defining the filter
 
Returns:
    bool: operation exit status
crossPlotAVASetColor(*args, **kwargs)
crossPlotAVASetColor(plotID: Number, Vname: str) -> bool
 
Set the color to an existing cross-plotAVA
 
Args:
    plotID (Number): cross-plotAVA window ID
    Vname (str): variable name for the color
 
Returns:
    bool: operation exit status
crossPlotAVASetFilter(*args, **kwargs)
crossPlotAVASetFilter(plotID: Number, Vname: str) -> bool
 
Set the variable as a filter
 
Args:
    plotID (Number): cross-plotAVA window ID
    Vname (str): filter variable name
 
Returns:
    bool: operation exit status
crossPlotAVASetName(*args, **kwargs)
crossPlotAVASetName(plotID: Number, n: str) -> bool
 
Change the name of mono cross-plotAVA
 
Args:
    plotID (Number): cross-plotAVA window ID
    n (str): new cross-plotAVAname
 
Returns:
    bool: operation exit status
crossPlotAVASetPaletteBoundaries(*args, **kwargs)
crossPlotAVASetPaletteBoundaries(plotID: Number, min: Number, max: Number) -> bool
 
Set the boundaries of the palette for a cross plot AVA.
 
Args:
    plotID (Number): plot window ID
    min (Number): minimum of the palette
    max (Number): maximum of the palette
 
Returns:
    bool: operation exit status
crossPlotAVASetX(*args, **kwargs)
crossPlotAVASetX(plotID: Number, Vname: str) -> bool
 
Set the variable to X axis
 
Args:
    plotID (Number): cross-plotAVA window ID
    Vname (str): variable X name
 
Returns:
    bool: operation exit status
crossPlotAVASetXAxisInverse(*args, **kwargs)
crossPlotAVASetXAxisInverse(plotID: Number, xainv: bool) -> bool
 
Inverse the cross-plotAVA X axis
 
Args:
    plotID (Number): cross-plotAVA window ID
    xainv (bool): 1 = inverse else 0
 
Returns:
    bool: operation exit status
crossPlotAVASetXAxisScale(*args, **kwargs)
crossPlotAVASetXAxisScale(plotID: Number, xasc: int) -> bool
 
Set the cross-plotAVA X axis scale
 
Args:
    plotID (Number): cross-plotAVA window ID
    xasc (int): scale type {0 = 'LINEAR', 1 = 'LOGARITHMIC'}
 
Returns:
    bool: operation exit status
crossPlotAVASetXAxisType(*args, **kwargs)
crossPlotAVASetXAxisType(plotID: Number, xat: int) -> bool
 
Change the type of cross-plotAVA X axis
 
Args:
    plotID (Number): cross-plotAVA window ID
    xat (int): X axis type {0 = 'VAR', 1 = 'USER', 2 = 'FAMILY'}
 
Returns:
    bool: operation exit status
crossPlotAVASetXAxisUnit(*args, **kwargs)
crossPlotAVASetXAxisUnit(plotID: Number, xau: str) -> bool
 
Change the unit of cross-plotAVA X axis
 
Args:
    plotID (Number): cross-plotAVA window ID
    xau (str): X axis unit
 
Returns:
    bool: operation exit status
crossPlotAVASetXAxisUserLimits(*args, **kwargs)
crossPlotAVASetXAxisUserLimits(plotID: Number, xamin: Number, xamax: Number) -> bool
 
Set min & max values of cross-plotAVA X axis
 
Args:
    plotID (Number): cross-plotAVA window ID
    xamin (Number): X axis minimum
    xamax (Number): X axis maximum
 
Returns:
    bool: operation exit status
crossPlotAVASetY(*args, **kwargs)
crossPlotAVASetY(plotID: Number, Vname: str) -> bool
 
Set the variable to Y axis
 
Args:
    plotID (Number): cross-plotAVA window ID
    Vname (str): variable Y name
 
Returns:
    bool: operation exit status
crossPlotAVASetYAxisInverse(*args, **kwargs)
crossPlotAVASetYAxisInverse(plotID: Number, yainv: bool) -> bool
 
Inverse the cross-plotAVA Y axis
 
Args:
    plotID (Number): cross-plotAVA window ID
    yainv (bool): 1 = inverse else 0
 
Returns:
    bool: operation exit status
crossPlotAVASetYAxisScale(*args, **kwargs)
crossPlotAVASetYAxisScale(plotID: Number, yasc: int) -> bool
 
Set the cross-plotAVA Y axis scale
 
Args:
    plotID (Number): cross-plotAVA window ID
    yasc (int): scale type {0 = 'LINEAR', 1 = 'LOGARITHMIC'}
 
Returns:
    bool: operation exit status
crossPlotAVASetYAxisType(*args, **kwargs)
crossPlotAVASetYAxisType(plotID: Number, yat: int) -> bool
 
Change the type of cross-plotAVA Y axis
 
Args:
    plotID (Number): cross-plotAVA window ID
    yat (int): Y axis type {0 = 'VAR', 1 = 'USER', 2 = 'FAMILY'}
 
Returns:
    bool: operation exit status
crossPlotAVASetYAxisUnit(*args, **kwargs)
crossPlotAVASetYAxisUnit(plotID: Number, yau: str) -> bool
 
Change the unit of cross-plotAVA Y axis
 
Args:
    plotID (Number): cross-plotAVA window ID
    yau (str): Y axis unit
 
Returns:
    bool: operation exit status
crossPlotAVASetYAxisUserLimits(*args, **kwargs)
crossPlotAVASetYAxisUserLimits(plotID: Number, yamin: Number, yamax: Number) -> bool
 
Set min & max values of cross-plotAVA Y axis
 
Args:
    plotID (Number): cross-plotAVA window ID
    yamin (Number): Y axis minimum
    yamax (Number): Y axis maximum
 
Returns:
    bool: operation exit status
crossPlotAVASetZonation(*args, **kwargs)
crossPlotAVASetZonation(plotID: Number, d: str) -> bool
 
Set the zonation dataset to the cross-plot
 
Args:
    plotID (Number): cross-plotAVA window ID
    d (str): zonation dataset name
 
Returns:
    bool: operation exit status
crossPlotActivateSecondAxe(*args, **kwargs)
crossPlotActivateSecondAxe(plotID: Number, activate: bool=False) -> bool
 
[DEPRECATED] Activate the second axis in the cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    activate (bool): Optional; activate
 
Returns:
    bool: operation exit status
crossPlotAddChart(*args, **kwargs)
crossPlotAddChart(plotID: Number, cn: str) -> bool
 
Add a chart to the cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    cn (str): chart level\chart name. Chart level is optional and can be:
    Techlog (default), Company, User, Project.
 
Returns:
    bool: operation exit status
crossPlotAddEquation(*args, **kwargs)
crossPlotAddEquation(plotID: Number, eq: str, n: str='', c: str='black') -> bool
 
Add an equation to an existing cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    eq (str): equation formula
    n (str): Optional; equation name
    c (str): Optional; color Qt name
 
Returns:
    bool: operation exit status
crossPlotAddParameterLineX(*args, **kwargs)
crossPlotAddParameterLineX(plotID: Number, well: str, dataset: str, zonation: str, zone: str, pn1: str, val1: Number, min1: Number, max1: Number, cminx: Number=MissingValue, cmaxx: Number=MissingValue, cminy: Number=MissingValue, cmaxy: Number=MissingValue, update: bool=True) -> Number
 
Add a parameter line to the cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    well (str): well name
    dataset (str): dataset name
    zonation (str): zonation dataset name
    zone (str): zone name
    pn1 (str): name of  Xparameter
    val1 (Number): value of X parameter
    min1 (Number): minimum of X parameter
    max1 (Number): maximum of X parameter
    cminx (Number): Optional; x min of constraint
    cmaxx (Number): Optional; x max of constraint
    cminy (Number): Optional; y min of constraint
    cmaxy (Number): Optional; y max of constraint
    update (bool): Optional; True if overwrite, false else
 
Returns:
    Number: parameter point id
crossPlotAddParameterLineY(*args, **kwargs)
crossPlotAddParameterLineY(plotID: Number, well: str, dataset: str, zonation: str, zone: str, pn1: str, val1: Number, min1: Number, max1: Number, cminx: Number=MissingValue, cmaxx: Number=MissingValue, cminy: Number=MissingValue, cmaxy: Number=MissingValue, update: bool=True) -> Number
 
Add parameter point to the cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    well (str): well name
    dataset (str): dataset name
    zonation (str): zonation dataset name
    zone (str): zone name
    pn1 (str): name of Y parameter
    val1 (Number): value of Y parameter
    min1 (Number): minimum of Y parameter
    max1 (Number): maximum of Y parameter
    cminx (Number): Optional; x min of constraint
    cmaxx (Number): Optional; x max of constraint
    cminy (Number): Optional; y min of constraint
    cmaxy (Number): Optional; y max of constraint
    update (bool): Optional; True if overwrite, false else
 
Returns:
    Number: parameter point id
crossPlotAddParameterPointLink(*args, **kwargs)
crossPlotAddParameterPointLink(plotID: Number, ppid1: str, ppid2: str, lt: Number=0) -> bool
 
Add a link between two parameter point in the cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    ppid1 (str): first parameter point id
    ppid2 (str): second parameter point id
    lt (Number): Optional; link style {0 = 'AtoB', 1 = 'BtoA', 2 = 'BOTH', 3 = 'NOARROW'
 
Returns:
    bool: operation exit status
crossPlotAddParameterPointXY(*args, **kwargs)
crossPlotAddParameterPointXY(plotID: Number, well: str, dataset: str, zonation: str, zone: str, pn1: str, val1: Number, min1: Number, max1: Number, pn2: str, val2: Number, min2: Number, max2: Number, cminx: Number=MissingValue, cmaxx: Number=MissingValue, cminy: Number=MissingValue, cmaxy: Number=MissingValue, update: bool=True) -> str
 
Add a parameter point to the cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    well (str): well name
    dataset (str): dataset name
    zonation (str): zonation dataset name
    zone (str): zone name
    pn1 (str): name of first parameter
    val1 (Number): value of first parameter
    min1 (Number): minimum of first parameter
    max1 (Number): maximum of first parameter
    pn2 (str): name of second parameter
    val2 (Number): value of second parameter
    min2 (Number): minimum of second parameter
    max2 (Number): maximum of second parameter
    cminx (Number): Optional; x min of constraint
    cmaxx (Number): Optional; x max of constraint
    cminy (Number): Optional; y min of constraint
    cmaxy (Number): Optional; y max of constraint
    update (bool): Optional; True if overwrite, false else
 
Returns:
    str: parameter point id's
crossPlotAddRegressionByFilter(*args, **kwargs)
crossPlotAddRegressionByFilter(plotID: Number) -> bool
 
Add a regression by filter in a cross-plot
 
Args:
    plotID (Number): cross-plot window ID
 
Returns:
    bool: operation exit status
crossPlotAddRegressionByZone(*args, **kwargs)
crossPlotAddRegressionByZone(plotID: Number) -> bool
 
Add a regression by zone in a cross-plot
 
Args:
    plotID (Number): cross-plot window ID
 
Returns:
    bool: operation exit status
crossPlotAddZone(*args, **kwargs)
crossPlotAddZone(plotID: Number, z: str) -> bool
 
Add a zone in the selection to the cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    z (str): zone name
 
Returns:
    bool: operation exit status
crossPlotApplyTo(*args, **kwargs)
crossPlotApplyTo(plotID: Number, ds: list) -> list
 
Apply the cross-plot to a data set list
 
Args:
    plotID (Number): cross-plot window ID
    ds (list): dataset ID (wellName.datasetName)
 
Returns:
    list: list of plotID
crossPlotChartList(*args, **kwargs)
crossPlotChartList()
 
Return the list of available charts
crossPlotCleanZonation(*args, **kwargs)
crossPlotCleanZonation(plotID: Number, d: str) -> bool
 
Remove the zonation dataset from the cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    d (str): zonation dataset name
 
Returns:
    bool: operation exit status
crossPlotCleanZone(*args, **kwargs)
crossPlotCleanZone(plotID: Number, z: str) -> bool
 
Remove a zone in the selection from the cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    z (str): zone name
 
Returns:
    bool: operation exit status
crossPlotClearAdvancedFilter(*args, **kwargs)
crossPlotClearAdvancedFilter(plotID: Number) -> bool
 
Clear the advanced filter of the cross plot
 
Args:
    plotID (Number): cross-plot window ID
 
Returns:
    bool: operation exit status
crossPlotCreate(*args, **kwargs)
crossPlotCreate(n: str, xn: str='', yn: str='', f: str='', xn2: str='', yn2: str='', widgetID: Number=None) -> Number
 
Create a new cross-plot
 
Args:
    n (str): cross-plot window name
    xn (str): Optional; variable X name
    yn (str): Optional; variable Y name
    f (str): Optional; filter variable name
    xn2 (str): Optional; [DEPRECATED] second X variable name (unused since 2011.2)
    yn2 (str): Optional; [DEPRECATED] second Y variable name (unused since 2011.2)
    widgetID (Number): Optional; if the cross-plot will be inserted into a widget, give widget ID
 
Returns:
    Number: cross-plot window ID
crossPlotDeleteColor2Values(*args, **kwargs)
crossPlotDeleteColor2Values(plotID: Number) -> bool
 
[DEPRECATED] Delete the variable present on the second color scale of a cross-plot
 
Args:
    plotID (Number): cross-plot window ID
 
Returns:
    bool: operation exit status
crossPlotDeleteColorValues(*args, **kwargs)
crossPlotDeleteColorValues(plotID: Number, ScaleId: str='') -> bool
 
Delete the variable present on the color scale of a cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    ScaleId (str): Optional; Scale id
 
Returns:
    bool: operation exit status
crossPlotDeleteFilterValues(*args, **kwargs)
crossPlotDeleteFilterValues(plotID: Number) -> bool
 
Delete the filter variable of a cross-plot
 
Args:
    plotID (Number): cross-plot window ID
 
Returns:
    bool: operation exit status
crossPlotDeleteLabelValues(*args, **kwargs)
crossPlotDeleteLabelValues(plotID: Number) -> bool
 
Delete the label variable of a cross-plot
 
Args:
    plotID (Number): cross-plot window ID
 
Returns:
    bool: operation exit status
crossPlotDeletePointSizeValues(*args, **kwargs)
crossPlotDeletePointSizeValues(plotID: Number, ScaleId: str='') -> bool
 
Delete the variable present on the point size scale of a cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    ScaleId (str): Optional; Scale id
 
Returns:
    bool: operation exit status
crossPlotDeleteX2Values(*args, **kwargs)
crossPlotDeleteX2Values(plotID: Number) -> bool
 
Delete the variable present on the second X axis of a cross-plot
 
Args:
    plotID (Number): cross-plot window ID
 
Returns:
    bool: operation exit status
crossPlotDeleteXValues(*args, **kwargs)
crossPlotDeleteXValues(plotID: Number, ScaleId: str='') -> bool
 
Delete the variable present on the X axis of a cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    ScaleId (str): Optional; Scale id
 
Returns:
    bool: operation exit status
crossPlotDeleteY2Values(*args, **kwargs)
crossPlotDeleteY2Values(plotID: Number) -> bool
 
Delete the variable present on the second Y axis of a cross-plot
 
Args:
    plotID (Number): cross-plot window ID
 
Returns:
    bool: operation exit status
crossPlotDeleteYValues(*args, **kwargs)
crossPlotDeleteYValues(plotID: Number, ScaleId: str='') -> bool
 
Delete the variable present on the Y axis of a cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    ScaleId (str): Optional; Scale id
 
Returns:
    bool: operation exit status
crossPlotDensityGridHorizontal(*args, **kwargs)
crossPlotDensityGridHorizontal(plotID: Number, type: int, xmin: Number=0, xmax: Number=0, dim: Number=50) -> bool
 
Set characteristics of X density grid
 
Args:
    plotID (Number): cross-plot window ID
    type (int): type {0 = 'VARIABLE', 1 = 'USER', 2 = 'FAMILY'}
    xmin (Number): Optional; X axis minimum
    xmax (Number): Optional; X axis maximum
    dim (Number): Optional; box dimension
 
Returns:
    bool: operation exit status
crossPlotDensityGridVertical(*args, **kwargs)
crossPlotDensityGridVertical(plotID: Number, type: int, ymin: Number=0, ymax: Number=0, dim: Number=50) -> bool
 
Set characteristics of Y density grid
 
Args:
    plotID (Number): cross-plot window ID
    type (int): type {0 = 'VARIABLE', 1 = 'USER', 2 = 'FAMILY'}
    ymin (Number): Optional; Y axis minimum
    ymax (Number): Optional; Y axis maximum
    dim (Number): Optional; box dimension
 
Returns:
    bool: operation exit status
crossPlotDensitySmooth(*args, **kwargs)
crossPlotDensitySmooth(plotID: Number, smooth: bool) -> bool
 
Display of smoothed density values
 
Args:
    plotID (Number): cross-plot window ID
    smooth (bool): 1 = smooth else 0
 
Returns:
    bool: operation exit status
crossPlotDensityType(*args, **kwargs)
crossPlotDensityType(plotID: Number, dst: bool) -> bool
 
Display of the cross-plot in normal or density type
 
Args:
    plotID (Number): cross-plot window ID
    dst (bool): 1 = density display else 0
 
Returns:
    bool: operation exit status
crossPlotDensityValue(*args, **kwargs)
crossPlotDensityValue(plotID: Number, value: bool, percent: bool=False) -> bool
 
Display of data density values
 
Args:
    plotID (Number): cross-plot window ID
    value (bool): 1 = display of density value else 0
    percent (bool): Optional; 1 = display in percent else 0
 
Returns:
    bool: operation exit status
crossPlotDuplicate(*args, **kwargs)
crossPlotDuplicate(plotID: Number) -> Number
 
Duplicate the cross-plot
 
Args:
    plotID (Number): cross-plot window ID
 
Returns:
    Number: new plot id or -1
crossPlotGetAdvancedFilter(*args, **kwargs)
crossPlotGetAdvancedFilter(plotID: Number) -> str
 
Get the advanced filter of the cross plot
 
Args:
    plotID (Number): cross-plot window ID
 
Returns:
    str: the filter equation
crossPlotGetChartPolylinesInfo(*args, **kwargs)
crossPlotGetChartPolylinesInfo(plotID: Number)
 
Get the polylines information of all the charts loaded in the cross-plot
 
Args:
    plotID (Number): cross-plot window ID
Output dict:
    str: chart level\chart name
    str: polyline id if defined
    str: polyline name if defined
    list: list of X coordinate of the polyline points in the cross-plot X axis unit
    list: list of Y coordinate of the polyline points in the cross-plot Y axis unit
    list: list of the graduation values for each polyline points
    Number: value of the first constant of the polyline indexed by its name
    Number: value of the ... constant of the polyline indexed by its name
    Number: value of the first parameter of the polyline indexed by its name
    Number: value of the ... parameter of the polyline indexed by its name
crossPlotGetColorVariable(*args, **kwargs)
crossPlotGetColorVariable(plotID: int, ScaleId: str='') -> str
 
Get the name of the variable of the axis "color" of a single well cross plot scale
 
Args:
    plotID (int): cross plot window ID
    ScaleId (str): Optional; Scale id - Scale 1 by default
 
Returns:
    str: name of the color variable "Well.Dataset.Variable"
crossPlotGetLabelVariable(*args, **kwargs)
crossPlotGetLabelVariable(plotID: int, ScaleId: str='') -> str
 
Get the name of the variable of the axis "label" of a single well cross plot scale
 
Args:
    plotID (int): cross plot window ID
    ScaleId (str): Optional; Scale id - Scale 1 by default
 
Returns:
    str: name of the label variable "Well.Dataset.Variable"
crossPlotGetParameterPointXValue(*args, **kwargs)
crossPlotGetParameterPointXValue(plotID: Number, ppid1: str) -> Number
 
Return X value of a parameter point in the cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    ppid1 (str): parameter point id
 
Returns:
    Number: x value of parameter point
crossPlotGetParameterPointYValue(*args, **kwargs)
crossPlotGetParameterPointYValue(plotID: Number, ppid1: str) -> Number
 
Return Y value of a parameter point in the cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    ppid1 (str): parameter point id
 
Returns:
    Number: y value of parameter point
crossPlotGetPointSizeVariable(*args, **kwargs)
crossPlotGetPointSizeVariable(plotID: int, ScaleId: str='') -> str
 
Get the name of the variable of the axis "point size" of a single well cross plot scale
 
Args:
    plotID (int): cross plot window ID
    ScaleId (str): Optional; Scale id - Scale 1 by default
 
Returns:
    str: name of the point size variable "Well.Dataset.Variable"
crossPlotGetRegressions(*args, **kwargs)
crossPlotGetRegressions(plotID: Number) -> dict
 
get a dictionary of regressions in a cross-plot
 
Args:
    plotID (Number): cross-plot window ID
 
Returns:
    dict: dictionary of regressions
crossPlotGetScaleList(*args, **kwargs)
crossPlotGetScaleList(plotID: int) -> List[str]
 
Get the list of scale names of a single well cross plot
 
Args:
    plotID (int): cross plot window ID
 
Returns:
    List[str]: list of scale names
crossPlotGetXHistogramBinCount(*args, **kwargs)
crossPlotGetXHistogramBinCount(plotID: Number) -> int
 
Getter for bin count on histogram Horizontal
 
Args:
    plotID (Number): cross-plot window ID
 
Returns:
    int: histogram horizontal bin count (NONE if the given plotID doesn't exist)}
crossPlotGetXVariableList(*args, **kwargs)
crossPlotGetXVariableList(plotID: int, ScaleId: str='') -> List[str]
 
Get the name of the variables of the axis "x" of a single well cross plot scale
 
Args:
    plotID (int): cross plot window ID
    ScaleId (str): Optional; Scale id - Scale 1 by default
 
Returns:
    List[str]: list of variable names in x ["Well.Dataset.Variable"]
crossPlotGetYHistogramBinCount(*args, **kwargs)
crossPlotGetYHistogramBinCount(plotID: Number) -> int
 
Getter for bin count on histogram Vertical
 
Args:
    plotID (Number): cross-plot window ID
 
Returns:
    int: histogram vertical bin count (NONE if the given plotID doesn't exist)}
crossPlotGetYVariableList(*args, **kwargs)
crossPlotGetYVariableList(plotID: int, ScaleId: str='') -> List[str]
 
Get the name of the variables of the axis "y" of a single well cross plot scale
 
Args:
    plotID (int): cross plot window ID
    ScaleId (str): Optional; Scale id - Scale 1 by default
 
Returns:
    List[str]: list of variable names in y ["Well.Dataset.Variable"]
crossPlotIDFindByName(*args, **kwargs)
crossPlotIDFindByName(n: str) -> Number
 
Find the ID of a name-known cross-plot
 
Args:
    n (str): cross-plot window name
 
Returns:
    Number: cross-plot window ID
crossPlotIsXHistogramCumulativeFrequencyVisible(*args, **kwargs)
crossPlotIsXHistogramCumulativeFrequencyVisible(plotID: Number) -> bool
 
Getter for cumulative frequency visibility state on histogram Horizontal
 
Args:
    plotID (Number): cross-plot window ID
 
Returns:
    bool: histogram horizontal cumulative frequency visibility state (NONE if the given plotID doesn't exist)}
crossPlotIsYHistogramCumulativeFrequencyVisible(*args, **kwargs)
crossPlotIsYHistogramCumulativeFrequencyVisible(plotID: Number) -> bool
 
Getter for cumulative frequency visibility state on histogram Vertical
 
Args:
    plotID (Number): cross-plot window ID
 
Returns:
    bool: histogram vertical cumulative frequency visibility state (NONE if the given plotID doesn't exist)}
crossPlotLink(*args, **kwargs)
crossPlotLink(plotID: Number, link: bool) -> Number
 
Link cross-plot markers
 
Args:
    plotID (Number): cross-plot window ID
    link (bool): True if linked, False else
 
Returns:
    Number: matrix window ID
crossPlotLockAxisX(*args, **kwargs)
crossPlotLockAxisX(plotID: Number, locked: bool) -> bool
 
Lock x-axis limits of the cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    locked (bool): True if locked, False else
 
Returns:
    bool: operation exit status
crossPlotLockAxisY(*args, **kwargs)
crossPlotLockAxisY(plotID: Number, locked: bool) -> bool
 
Lock y-axis limits of the cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    locked (bool): True if locked, False else
 
Returns:
    bool: operation exit status
crossPlotLockLegendX(*args, **kwargs)
crossPlotLockLegendX(plotID: Number, locked: bool) -> bool
 
Lock x-axis legend of the cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    locked (bool): True if locked, False else
 
Returns:
    bool: operation exit status
crossPlotLockLegendY(*args, **kwargs)
crossPlotLockLegendY(plotID: Number, locked: bool) -> bool
 
Lock y-axis legend of the cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    locked (bool): True if locked, False else
 
Returns:
    bool: operation exit status
crossPlotLockPalette(*args, **kwargs)
crossPlotLockPalette(plotID: Number, locked: bool) -> bool
 
Lock palette of the cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    locked (bool): True if locked, False else
 
Returns:
    bool: operation exit status
crossPlotLockTitle(*args, **kwargs)
crossPlotLockTitle(plotID: Number, locked: bool) -> bool
 
Lock title of the cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    locked (bool): True if locked, False else
 
Returns:
    bool: operation exit status
crossPlotMarkers(*args, **kwargs)
crossPlotMarkers(plotID: Number, type: int, size: Number=5) -> bool
 
Set type & size of cross-plot markers
 
Args:
    plotID (Number): cross-plot window ID
    type (int): markers type {'MARKER_CIRCLE', 'MARKER_SQUARE', 'MARKER_DIAMOND',
       'MARKER_TRIANGLE', 'MARKER_TRIANGLE_DOWN', 'MARKER_TRIANGLE_LEFT',
       'MARKER_TRIANGLE_RIGHT', 'MARKER_EMPTY_CIRCLE', 'MARKER_EMPTY_SQUARE',
       'MARKER_EMPTY_DIAMOND', 'MARKER_EMPTY_TRIANGLE', 'MARKER_EMPTY_TRIANGLE_DOWN',
       'MARKER_EMPTY_TRIANGLE_LEFT', 'MARKER_EMPTY_TRIANGLE_RIGHT', 'MARKER_SHURIKEN',
       'MARKER_EMPTY_SHURIKEN', 'MARKER_PLUS', 'MARKER_CROSS',
       'MARKER_STAR', 'MARKER_RIG', 'NB_MARKER'}
    size (Number): Optional; markers size
 
Returns:
    bool: operation exit status
crossPlotMarkersColor(*args, **kwargs)
crossPlotMarkersColor(plotID: Number, r: Number, g: Number, b: Number) -> bool
 
Choose the cross-plot markers color
 
Args:
    plotID (Number): cross-plot window ID
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
crossPlotMarkersColour(*args, **kwargs)
crossPlotMarkersColour(plotID: Number, r: Number, g: Number, b: Number) -> bool
 
[DEPRECATED] (use crossPlotMarkersColor instead) Choose the cross-plot markers color
 
Args:
    plotID (Number): cross-plot window ID
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
crossPlotMultiWellAddChart(*args, **kwargs)
crossPlotMultiWellAddChart(plotID: Number, cn: str) -> bool
 
Add chart to the cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    cn (str): chart level\chart name. Chart level is optional and can be:
    Techlog (default), Company, User, Project.
 
Returns:
    bool: operation exit status
crossPlotMultiWellAddData(*args, **kwargs)
crossPlotMultiWellAddData(plotID: Number, ds: list) -> bool
 
Add a dataset to a multi well cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    ds (list): dataset ID (wellName.datasetName)
 
Returns:
    bool: operation exit status
crossPlotMultiWellAddEquation(*args, **kwargs)
crossPlotMultiWellAddEquation(plotID: Number, eq: str, n: str='', c: str='black') -> bool
 
Add an equation to an existing cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    eq (str): equation formula
    n (str): Optional; equation name
    c (str): Optional; color Qt name
 
Returns:
    bool: operation exit status
crossPlotMultiWellAddParameterLineX(*args, **kwargs)
crossPlotMultiWellAddParameterLineX(plotID: Number, well: str, dataset: str, zonation: str, zone: str, pn1: str, val1: Number, min1: Number, max1: Number, cminx: Number=MissingValue, cmaxx: Number=MissingValue, cminy: Number=MissingValue, cmaxy: Number=MissingValue, update: bool=True) -> Number
 
Add a parameter line to the cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    well (str): well name
    dataset (str): dataset name
    zonation (str): zonation dataset name
    zone (str): zone name
    pn1 (str): name of  Xparameter
    val1 (Number): value of X parameter
    min1 (Number): minimum of X parameter
    max1 (Number): maximum of X parameter
    cminx (Number): Optional; x min of constraint
    cmaxx (Number): Optional; x max of constraint
    cminy (Number): Optional; y min of constraint
    cmaxy (Number): Optional; y max of constraint
    update (bool): Optional; True if overwrite, false else
 
Returns:
    Number: parameter point id
crossPlotMultiWellAddParameterLineY(*args, **kwargs)
crossPlotMultiWellAddParameterLineY(plotID: Number, well: str, dataset: str, zonation: str, zone: str, pn1: str, val1: Number, min1: Number, max1: Number, cminx: Number=MissingValue, cmaxx: Number=MissingValue, cminy: Number=MissingValue, cmaxy: Number=MissingValue, update: bool=True) -> Number
 
Add parameter point to the cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    well (str): well name
    dataset (str): dataset name
    zonation (str): zonation dataset name
    zone (str): zone name
    pn1 (str): name of Y parameter
    val1 (Number): value of Y parameter
    min1 (Number): minimum of Y parameter
    max1 (Number): maximum of Y parameter
    cminx (Number): Optional; x min of constraint
    cmaxx (Number): Optional; x max of constraint
    cminy (Number): Optional; y min of constraint
    cmaxy (Number): Optional; y max of constraint
    update (bool): Optional; True if overwrite, false else
 
Returns:
    Number: parameter point id
crossPlotMultiWellAddParameterPointLink(*args, **kwargs)
crossPlotMultiWellAddParameterPointLink(plotID: Number, ppid1: str, ppid2: str, lt: Number=0) -> bool
 
Add a link between two parameter point in the cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    ppid1 (str): first parameter point id
    ppid2 (str): second parameter point id
    lt (Number): Optional; link style {0 = 'AtoB', 1 = 'BtoA', 2 = 'BOTH', 3 = 'NOARROW'
 
Returns:
    bool: operation exit status
crossPlotMultiWellAddParameterPointXY(*args, **kwargs)
crossPlotMultiWellAddParameterPointXY(plotID: Number, well: str, dataset: str, zonation: str, zone: str, pn1: str, val1: Number, min1: Number, max1: Number, pn2: str, val2: Number, min2: Number, max2: Number, cminx: Number=MissingValue, cmaxx: Number=MissingValue, cminy: Number=MissingValue, cmaxy: Number=MissingValue, update: bool=True) -> str
 
Add a parameter point to the cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    well (str): well name
    dataset (str): dataset name
    zonation (str): zonation dataset name
    zone (str): zone name
    pn1 (str): name of first parameter
    val1 (Number): value of first parameter
    min1 (Number): minimum of first parameter
    max1 (Number): maximum of first parameter
    pn2 (str): name of second parameter
    val2 (Number): value of second parameter
    min2 (Number): minimum of second parameter
    max2 (Number): maximum of second parameter
    cminx (Number): Optional; x min of constraint
    cmaxx (Number): Optional; x max of constraint
    cminy (Number): Optional; y min of constraint
    cmaxy (Number): Optional; y max of constraint
    update (bool): Optional; True if overwrite, false else
 
Returns:
    str: parameter point id's
crossPlotMultiWellAddRegressionByFilter(*args, **kwargs)
crossPlotMultiWellAddRegressionByFilter(plotID: Number) -> bool
 
Add a regression by filter in a cross-plot
 
Args:
    plotID (Number): cross-plot window ID
 
Returns:
    bool: operation exit status
crossPlotMultiWellAddRegressionByWell(*args, **kwargs)
crossPlotMultiWellAddRegressionByWell(plotID: Number) -> bool
 
Add a regression by well in a cross-plot
 
Args:
    plotID (Number): cross-plot window ID
 
Returns:
    bool: operation exit status
crossPlotMultiWellAddRegressionByZone(*args, **kwargs)
crossPlotMultiWellAddRegressionByZone(plotID: Number) -> bool
 
Add a regression by zone in a cross-plot
 
Args:
    plotID (Number): cross-plot window ID
 
Returns:
    bool: operation exit status
crossPlotMultiWellAddZone(*args, **kwargs)
crossPlotMultiWellAddZone(plotID: Number, z: str) -> bool
 
Add a zone in the selection to the cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    z (str): zone name
 
Returns:
    bool: operation exit status
crossPlotMultiWellChartList(*args, **kwargs)
crossPlotMultiWellChartList()
 
Return the list of available charts
crossPlotMultiWellCleanZonation(*args, **kwargs)
crossPlotMultiWellCleanZonation(plotID: Number, d: str) -> bool
 
Remove the zonation dataset from the cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    d (str): zonation dataset name
 
Returns:
    bool: operation exit status
crossPlotMultiWellCleanZone(*args, **kwargs)
crossPlotMultiWellCleanZone(plotID: Number, z: str) -> bool
 
Remove a zone in the selection from the cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    z (str): zone name
 
Returns:
    bool: operation exit status
crossPlotMultiWellClearAdvancedFilter(*args, **kwargs)
crossPlotMultiWellClearAdvancedFilter(plotID: Number) -> bool
 
Clear the advanced filter of the cross plot
 
Args:
    plotID (Number): cross-plot window ID
 
Returns:
    bool: operation exit status
crossPlotMultiWellCreate(*args, **kwargs)
crossPlotMultiWellCreate(ml: list) -> Number
 
Create a multi well cross-plot
 
Args:
    ml (list): mnemonic list
 
Returns:
    Number: cross-plot window ID
crossPlotMultiWellDensityGridHorizontal(*args, **kwargs)
crossPlotMultiWellDensityGridHorizontal(plotID: Number, type: int, xmin: Number=0, xmax: Number=0, dim: Number=50) -> bool
 
Set characteristics of X density grid
 
Args:
    plotID (Number): cross-plot window ID
    type (int): type {0 = 'VARIABLE', 1 = 'USER', 2 = 'FAMILY'}
    xmin (Number): Optional; X axis minimum
    xmax (Number): Optional; X axis maximum
    dim (Number): Optional; box dimension
 
Returns:
    bool: operation exit status
crossPlotMultiWellDensityGridVertical(*args, **kwargs)
crossPlotMultiWellDensityGridVertical(plotID: Number, type: int, ymin: Number=0, ymax: Number=0, dim: Number=50) -> bool
 
Set characteristics of Y density grid
 
Args:
    plotID (Number): cross-plot window ID
    type (int): type {0 = 'VARIABLE', 1 = 'USER', 2 = 'FAMILY'}
    ymin (Number): Optional; Y axis minimum
    ymax (Number): Optional; Y axis maximum
    dim (Number): Optional; box dimension
 
Returns:
    bool: operation exit status
crossPlotMultiWellDensitySmooth(*args, **kwargs)
crossPlotMultiWellDensitySmooth(plotID: Number, smooth: bool) -> bool
 
Display of smoothed density values
 
Args:
    plotID (Number): cross-plot window ID
    smooth (bool): 1 = smooth else 0
 
Returns:
    bool: operation exit status
crossPlotMultiWellDensityType(*args, **kwargs)
crossPlotMultiWellDensityType(plotID: Number, dst: bool) -> bool
 
Display of the cross-plot in normal or density type
 
Args:
    plotID (Number): cross-plot window ID
    dst (bool): 1 = density display else 0
 
Returns:
    bool: operation exit status
crossPlotMultiWellDensityValue(*args, **kwargs)
crossPlotMultiWellDensityValue(plotID: Number, value: bool, percent: bool=False) -> bool
 
Display of data density values
 
Args:
    plotID (Number): cross-plot window ID
    value (bool): 1 = display of density value else 0
    percent (bool): Optional; 1 = display in percent else 0
 
Returns:
    bool: operation exit status
crossPlotMultiWellDuplicate(*args, **kwargs)
crossPlotMultiWellDuplicate(plotID: Number) -> Number
 
Duplicate the cross-plot
 
Args:
    plotID (Number): cross-plot window ID
 
Returns:
    Number: new plot id or -1
crossPlotMultiWellGetAdvancedFilter(*args, **kwargs)
crossPlotMultiWellGetAdvancedFilter(plotID: Number) -> str
 
Get the advanced filter of the cross plot
 
Args:
    plotID (Number): cross-plot window ID
 
Returns:
    str: the filter equation
crossPlotMultiWellGetChartPolylinesInfo(*args, **kwargs)
crossPlotMultiWellGetChartPolylinesInfo(plotID: Number)
 
Get the polylines information of all the charts loaded in the cross-plot
 
Args:
    plotID (Number): cross-plot window ID
Output dict:
    str: chart level\chart name
    str: polyline id if defined
    str: polyline name if defined
    list: list of X coordinate of the polyline points in the cross-plot X axis unit
    list: list of Y coordinate of the polyline points in the cross-plot Y axis unit
    list: list of the graduation values for each polyline points
    Number: value of the first constant of the polyline indexed by its name
    Number: value of the ... constant of the polyline indexed by its name
    Number: value of the first parameter of the polyline indexed by its name
    Number: value of the ... parameter of the polyline indexed by its name
crossPlotMultiWellGetParameterPointXValue(*args, **kwargs)
crossPlotMultiWellGetParameterPointXValue(plotID: Number, ppid1: str) -> Number
 
Return X value of a parameter point in the cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    ppid1 (str): parameter point id
 
Returns:
    Number: x value of parameter point
crossPlotMultiWellGetParameterPointYValue(*args, **kwargs)
crossPlotMultiWellGetParameterPointYValue(plotID: Number, ppid1: str) -> Number
 
Return Y value of a parameter point in the cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    ppid1 (str): parameter point id
 
Returns:
    Number: y value of parameter point
crossPlotMultiWellGetRegressions(*args, **kwargs)
crossPlotMultiWellGetRegressions(plotID: Number) -> dict
 
get a dictionary of regressions in a cross-plot multi well
 
Args:
    plotID (Number): cross-plot window ID
 
Returns:
    dict: dictionary of regressions
crossPlotMultiWellIDFindByName(*args, **kwargs)
crossPlotMultiWellIDFindByName(n: str) -> Number
 
Find the ID of a name-known cross-plot
 
Args:
    n (str): cross-plot window name
 
Returns:
    Number: cross-plot window ID
crossPlotMultiWellOpen(*args, **kwargs)
crossPlotMultiWellOpen(n: str, f: str='') -> Number
 
Open an existing cross-plot
 
Args:
    n (str): cross-plot name
    f (str): Optional; folder
 
Returns:
    Number: plot ID
crossPlotMultiWellRemoveAllEquations(*args, **kwargs)
crossPlotMultiWellRemoveAllEquations(plotID: Number) -> bool
 
Remove all equations from an existing cross-plot
 
Args:
    plotID (Number): cross-plot window ID
 
Returns:
    bool: operation exit status
crossPlotMultiWellRemoveAllParameterPoint(*args, **kwargs)
crossPlotMultiWellRemoveAllParameterPoint(plotID: Number) -> bool
 
Remove all parameter point in the cross-plot
 
Args:
    plotID (Number): cross-plot window ID
 
Returns:
    bool: operation exit status
crossPlotMultiWellRemoveDataset(*args, **kwargs)
crossPlotMultiWellRemoveDataset(plotID: Number, ds: str) -> bool
 
Remove a dataset from a multi well cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    ds (str): dataset name
 
Returns:
    bool: operation exit status
crossPlotMultiWellRemoveEquation(*args, **kwargs)
crossPlotMultiWellRemoveEquation(plotID: Number, eq: str) -> bool
 
Remove an equation from an existing cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    eq (str): equation name
 
Returns:
    bool: operation exit status
crossPlotMultiWellRemoveParameterLineX(*args, **kwargs)
crossPlotMultiWellRemoveParameterLineX(plotID: Number, ppid1: str) -> bool
 
Remove a parameter line X in the cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    ppid1 (str): parameter point id
 
Returns:
    bool: operation exit status
crossPlotMultiWellRemoveParameterLineY(*args, **kwargs)
crossPlotMultiWellRemoveParameterLineY(plotID: Number, ppid1: str) -> bool
 
Remove a parameter line Y in the cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    ppid1 (str): parameter point id
 
Returns:
    bool: operation exit status
crossPlotMultiWellRemoveParameterPoint(*args, **kwargs)
crossPlotMultiWellRemoveParameterPoint(plotID: Number, ppid1: str) -> bool
 
Remove a parameter point in the cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    ppid1 (str): parameter point id
 
Returns:
    bool: operation exit status
crossPlotMultiWellRemoveWell(*args, **kwargs)
crossPlotMultiWellRemoveWell(plotID: Number, we: str) -> bool
 
Remove a well from a multi well cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    we (str): well name
 
Returns:
    bool: operation exit status
crossPlotMultiWellReverseAxes(*args, **kwargs)
crossPlotMultiWellReverseAxes(plotID: Number) -> bool
 
Reverse the cross-plot axes
 
Args:
    plotID (Number): cross-plot window ID
 
Returns:
    bool: operation exit status
crossPlotMultiWellSave(*args, **kwargs)
crossPlotMultiWellSave(plotID: Number, n: str, f: str='') -> bool
 
Save the cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    n (str): cross-plot name
    f (str): Optional; folder
 
Returns:
    bool: operation exit status
crossPlotMultiWellSelectVar(*args, **kwargs)
crossPlotMultiWellSelectVar(plotID: Number, we: str, ds: str, famId: Number, vr: str) -> bool
 
[DEPRECATED] (use crossPlotMultiWellSelectVariable instead) Change the variable selected among one family's variables in a multi well cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    we (str): well name
    ds (str): dataset name
    famId (Number): ID of the family in which you wish to change variable
    vr (str): new variable name
 
Returns:
    bool: operation exit status
crossPlotMultiWellSelectVariable(*args, **kwargs)
crossPlotMultiWellSelectVariable(plotID: Number, we: str, ds: str, famId: Number, vr: str) -> bool
 
Change the variable selected among one family's variables in a multi well cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    we (str): well name
    ds (str): dataset name
    famId (Number): ID of the family in which you wish to change variable
    vr (str): new variable name
 
Returns:
    bool: operation exit status
crossPlotMultiWellSetAdvancedFilter(*args, **kwargs)
crossPlotMultiWellSetAdvancedFilter(plotID: Number, Equation: str) -> bool
 
Set an advanced filter on the cross plot
 
Args:
    plotID (Number): cross-plot window ID
    Equation (str): equation defining the filter
 
Returns:
    bool: operation exit status
crossPlotMultiWellSetDensityData(*args, **kwargs)
crossPlotMultiWellSetDensityData(plotID: Number, xpos: list, ypos: list, zdata: list, xunit: str='', yunit: str='', zunit: str='') -> bool
 
Set the density values of a multi-well cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    xpos (list): list of x positions values
    ypos (list): list of y positions values
    zdata (list): list of data density values (zsize = (xsize-1)*(ysize-1))
    xunit (str): Optional; x unit
    yunit (str): Optional; y unit
    zunit (str): Optional; z unit
 
Returns:
    bool: operation exit status
crossPlotMultiWellSetHistogramVisible(*args, **kwargs)
crossPlotMultiWellSetHistogramVisible(plotID: Number, cf: bool) -> bool
 
Display histograms on the cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    cf (bool): {0 = 'remove the histograms', 1 = 'display the histograms'}
 
Returns:
    bool: operation exit status
crossPlotMultiWellSetName(*args, **kwargs)
crossPlotMultiWellSetName(plotID: Number, n: str) -> bool
 
Change the name of multiwell cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    n (str): new cross-plot name
 
Returns:
    bool: operation exit status
crossPlotMultiWellSetPaletteBoundaries(*args, **kwargs)
crossPlotMultiWellSetPaletteBoundaries(plotID: Number, min: Number, max: Number) -> bool
 
Set the boundaries of the palette for a multi-well cross plot.
 
Args:
    plotID (Number): plot window ID
    min (Number): minimum of the palette
    max (Number): maximum of the palette
 
Returns:
    bool: operation exit status
crossPlotMultiWellSetPointSizeAxisScale(*args, **kwargs)
crossPlotMultiWellSetPointSizeAxisScale(plotID: Number, psasc: int) -> bool
 
Set the cross-plot point size axis scale
 
Args:
    plotID (Number): cross-plot window ID
    psasc (int): scale type {0 = 'LINEAR', 1 = 'LOGARITHMIC'}
 
Returns:
    bool: operation exit status
crossPlotMultiWellSetPointSizeAxisSizeLimits(*args, **kwargs)
crossPlotMultiWellSetPointSizeAxisSizeLimits(plotID: Number, psamin: Number, psamax: Number) -> bool
 
Set min & max sizes of cross-plot point size axis
 
Args:
    plotID (Number): cross-plot window ID
    psamin (Number): point size axis minimum size
    psamax (Number): point size axis maximum size
 
Returns:
    bool: operation exit status
crossPlotMultiWellSetPointSizeAxisType(*args, **kwargs)
crossPlotMultiWellSetPointSizeAxisType(plotID: Number, psat: int) -> bool
 
Change the type of cross-plot point size axis
 
Args:
    plotID (Number): cross-plot window ID
    psat (int): point size axis type {0 = 'VAR', 1 = 'USER', 2 = 'FAMILY'}
 
Returns:
    bool: operation exit status
crossPlotMultiWellSetPointSizeAxisUserLimits(*args, **kwargs)
crossPlotMultiWellSetPointSizeAxisUserLimits(plotID: Number, psamin: Number, psamax: Number) -> bool
 
Set min & max values of cross-plot point size axis
 
Args:
    plotID (Number): cross-plot window ID
    psamin (Number): point size axis minimum
    psamax (Number): point size axis maximum
 
Returns:
    bool: operation exit status
crossPlotMultiWellSetXAxisInverse(*args, **kwargs)
crossPlotMultiWellSetXAxisInverse(plotID: Number, xainv: bool) -> bool
 
Inverse the cross-plot X axis
 
Args:
    plotID (Number): cross-plot window ID
    xainv (bool): 1 = inverse else 0
 
Returns:
    bool: operation exit status
crossPlotMultiWellSetXAxisScale(*args, **kwargs)
crossPlotMultiWellSetXAxisScale(plotID: Number, xasc: int) -> bool
 
Set the cross-plot X axis scale
 
Args:
    plotID (Number): cross-plot window ID
    xasc (int): scale type {0 = 'LINEAR', 1 = 'LOGARITHMIC'}
 
Returns:
    bool: operation exit status
crossPlotMultiWellSetXAxisType(*args, **kwargs)
crossPlotMultiWellSetXAxisType(plotID: Number, xat: int) -> bool
 
Change the type of cross-plot X axis
 
Args:
    plotID (Number): cross-plot window ID
    xat (int): X axis type {0 = 'VAR', 1 = 'USER', 2 = 'FAMILY'}
 
Returns:
    bool: operation exit status
crossPlotMultiWellSetXAxisUnit(*args, **kwargs)
crossPlotMultiWellSetXAxisUnit(plotID: Number, xau: str) -> bool
 
Change the unit of cross-plot X axis
 
Args:
    plotID (Number): cross-plot window ID
    xau (str): X axis unit
 
Returns:
    bool: operation exit status
crossPlotMultiWellSetXAxisUserLimits(*args, **kwargs)
crossPlotMultiWellSetXAxisUserLimits(plotID: Number, xamin: Number, xamax: Number) -> bool
 
Set min & max values of cross-plot X axis
 
Args:
    plotID (Number): cross-plot window ID
    xamin (Number): X axis minimum
    xamax (Number): X axis maximum
 
Returns:
    bool: operation exit status
crossPlotMultiWellSetYAxisInverse(*args, **kwargs)
crossPlotMultiWellSetYAxisInverse(plotID: Number, yainv: bool) -> bool
 
Inverse the cross-plot Y axis
 
Args:
    plotID (Number): cross-plot window ID
    yainv (bool): 1 = inverse else 0
 
Returns:
    bool: operation exit status
crossPlotMultiWellSetYAxisScale(*args, **kwargs)
crossPlotMultiWellSetYAxisScale(plotID: Number, yasc: int) -> bool
 
Set the cross-plot Y axis scale
 
Args:
    plotID (Number): cross-plot window ID
    yasc (int): scale type {0 = 'LINEAR', 1 = 'LOGARITHMIC'}
 
Returns:
    bool: operation exit status
crossPlotMultiWellSetYAxisType(*args, **kwargs)
crossPlotMultiWellSetYAxisType(plotID: Number, yat: int) -> bool
 
Change the type of cross-plot Y axis
 
Args:
    plotID (Number): cross-plot window ID
    yat (int): Y axis type {0 = 'VAR', 1 = 'USER', 2 = 'FAMILY'}
 
Returns:
    bool: operation exit status
crossPlotMultiWellSetYAxisUnit(*args, **kwargs)
crossPlotMultiWellSetYAxisUnit(plotID: Number, yau: str) -> bool
 
Change the unit of cross-plot Y axis
 
Args:
    plotID (Number): cross-plot window ID
    yau (str): Y axis unit
 
Returns:
    bool: operation exit status
crossPlotMultiWellSetYAxisUserLimits(*args, **kwargs)
crossPlotMultiWellSetYAxisUserLimits(plotID: Number, yamin: Number, yamax: Number) -> bool
 
Set min & max values of cross-plot Y axis
 
Args:
    plotID (Number): cross-plot window ID
    yamin (Number): Y axis minimum
    yamax (Number): Y axis maximum
 
Returns:
    bool: operation exit status
crossPlotMultiWellSetZonation(*args, **kwargs)
crossPlotMultiWellSetZonation(plotID: Number, d: str) -> bool
 
Set the zonation dataset to the cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    d (str): zonation dataset name
 
Returns:
    bool: operation exit status
crossPlotOpen(*args, **kwargs)
crossPlotOpen(n: str, f: str='') -> Number
 
Open an existing cross-plot
 
Args:
    n (str): cross-plot name
    f (str): Optional; folder
 
Returns:
    Number: plot ID
crossPlotPointSizeChange(*args, **kwargs)
crossPlotPointSizeChange(plotID: Number, Vname: str, ScaleId: str='') -> bool
 
Set the point size to an existing cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    Vname (str): variable point size name
    ScaleId (str): Optional; Scale id
 
Returns:
    bool: operation exit status
crossPlotRemoveAllEquations(*args, **kwargs)
crossPlotRemoveAllEquations(plotID: Number) -> bool
 
Remove all equations from an existing cross-plot
 
Args:
    plotID (Number): cross-plot window ID
 
Returns:
    bool: operation exit status
crossPlotRemoveAllParameterPoint(*args, **kwargs)
crossPlotRemoveAllParameterPoint(plotID: Number) -> bool
 
Remove all parameter point in the cross-plot
 
Args:
    plotID (Number): cross-plot window ID
 
Returns:
    bool: operation exit status
crossPlotRemoveChart(*args, **kwargs)
crossPlotRemoveChart(plotID: Number, cn: str) -> bool
 
Remove a chart from the cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    cn (str): chart level\chart name. Chart level is optional and can be:
    Techlog (default), Company, User, Project.
 
Returns:
    bool: operation exit status
crossPlotRemoveEquation(*args, **kwargs)
crossPlotRemoveEquation(plotID: Number, eq: str) -> bool
 
Remove an equation from an existing cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    eq (str): equation name
 
Returns:
    bool: operation exit status
crossPlotRemoveParameterLineX(*args, **kwargs)
crossPlotRemoveParameterLineX(plotID: Number, ppid1: str) -> bool
 
Remove a parameter line X in the cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    ppid1 (str): parameter point id
 
Returns:
    bool: operation exit status
crossPlotRemoveParameterLineY(*args, **kwargs)
crossPlotRemoveParameterLineY(plotID: Number, ppid1: str) -> bool
 
Remove a parameter line Y in the cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    ppid1 (str): parameter point id
 
Returns:
    bool: operation exit status
crossPlotRemoveParameterPoint(*args, **kwargs)
crossPlotRemoveParameterPoint(plotID: Number, ppid1: str) -> bool
 
Remove a parameter point in the cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    ppid1 (str): parameter point id
 
Returns:
    bool: operation exit status
crossPlotReverseAxes(*args, **kwargs)
crossPlotReverseAxes(plotID: Number) -> bool
 
Reverse the cross-plot axes
 
Args:
    plotID (Number): cross-plot window ID
 
Returns:
    bool: operation exit status
crossPlotSave(*args, **kwargs)
crossPlotSave(plotID: Number, n: str, f: str='') -> bool
 
Save the cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    n (str): cross-plot name
    f (str): Optional; folder
 
Returns:
    bool: operation exit status
crossPlotSelectFilter(*args, **kwargs)
crossPlotSelectFilter(plotID: Number, FilterValues: list) -> bool
 
Select the filter values
 
Args:
    plotID (Number): cross-plot window ID
    FilterValues (list): filter values
 
Returns:
    bool: operation exit status
crossPlotSetAdvancedFilter(*args, **kwargs)
crossPlotSetAdvancedFilter(plotID: Number, Equation: str) -> bool
 
Set an advanced filter on the cross plot
 
Args:
    plotID (Number): cross-plot window ID
    Equation (str): equation defining the filter
 
Returns:
    bool: operation exit status
crossPlotSetColor(*args, **kwargs)
crossPlotSetColor(plotID: Number, Vname: str, ScaleId: str='') -> bool
 
Set the color to an existing cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    Vname (str): variable name for the color
    ScaleId (str): Optional; Scale id
 
Returns:
    bool: operation exit status
crossPlotSetColor2(*args, **kwargs)
crossPlotSetColor2(plotID: Number, Vname: str) -> bool
 
[DEPRECATED] Set the second color to an existing cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    Vname (str): variable second color name
 
Returns:
    bool: operation exit status
crossPlotSetColorValues(*args, **kwargs)
crossPlotSetColorValues(plotID: Number, vn: str, vl: list, fam: str='', un: str='', ScaleId: str='') -> bool
 
Set a fictive set of user variables to the color scale of a cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    vn (str): variable name
    vl (list): list of values
    fam (str): Optional; variable family
    un (str): Optional; variable unit
    ScaleId (str): Optional; Scale id
 
Returns:
    bool: operation exit status
crossPlotSetColour2Values(*args, **kwargs)
crossPlotSetColour2Values(plotID: Number, vn: str, vl: list, fam: str='', un: str='') -> bool
 
[DEPRECATED] Set a fictive set of user variables to the second color scale of a cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    vn (str): variable name
    vl (list): list of values
    fam (str): Optional; variable family
    un (str): Optional; variable unit
 
Returns:
    bool: operation exit status
crossPlotSetColourValues(*args, **kwargs)
crossPlotSetColourValues(plotID: Number, vn: str, vl: list, fam: str='', un: str='', ScaleId: str='') -> bool
 
[DEPRECATED] (use crossPlotSetColorValues instead) Set a fictive set of user variables to the color scale of a cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    vn (str): variable name
    vl (list): list of values
    fam (str): Optional; variable family
    un (str): Optional; variable unit
    ScaleId (str): Optional; Scale id
 
Returns:
    bool: operation exit status
crossPlotSetDatum(*args, **kwargs)
crossPlotSetDatum(plotID: Number, lim: bool, ymin: Number=0, ymax: Number=0) -> bool
 
Change the reference limitation on cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    lim (bool): 0 for 'whole datum' / 1 for 'user values'
    ymin (Number): Optional; top limitation
    ymax (Number): Optional; bottom limitation
 
Returns:
    bool: operation exit status
crossPlotSetDensityData(*args, **kwargs)
crossPlotSetDensityData(plotID: Number, xpos: list, ypos: list, zdata: list, xunit: str='', yunit: str='', zunit: str='') -> bool
 
Set the density values of a cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    xpos (list): list of x positions values
    ypos (list): list of y positions values
    zdata (list): list of data density values (zsize = (xsize-1)*(ysize-1))
    xunit (str): Optional; x unit
    yunit (str): Optional; y unit
    zunit (str): Optional; z unit
 
Returns:
    bool: operation exit status
crossPlotSetFilter(*args, **kwargs)
crossPlotSetFilter(plotID: Number, Vname: str, ScaleId: str='') -> bool
 
Set the variable as a filter
 
Args:
    plotID (Number): cross-plot window ID
    Vname (str): filter variable name
    ScaleId (str): Optional; Scale id
 
Returns:
    bool: operation exit status
crossPlotSetFilterValues(*args, **kwargs)
crossPlotSetFilterValues(plotID: Number, f: str) -> bool
 
Set the variable as a filter
 
Args:
    plotID (Number): spectrum window ID
    f (str): variable filter
 
Returns:
    bool: operation exit status
crossPlotSetFirstScaleName(*args, **kwargs)
crossPlotSetFirstScaleName(plotID: Number, n: str) -> bool
 
Change the name of first scale in a mono cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    n (str): new first scale name
 
Returns:
    bool: operation exit status
crossPlotSetGridVisible(*args, **kwargs)
crossPlotSetGridVisible(plotID: Number, grid_X: int=2, grid_Y: int=2) -> bool
 
Hide or Display the Grid in all plots
 
Args:
    plotID (Number): window ID
    grid_X (int): Optional; X grid visibility state: {0 = 'HIDDEN', 1 = 'ONLY_PRIMARY', 2 = 'BOTH'}
    grid_Y (int): Optional; Y grid visibility state: {0 = 'HIDDEN', 1 = 'ONLY_PRIMARY', 2 = 'BOTH'}
 
Returns:
    bool: operation exit status
crossPlotSetHistogramVisible(*args, **kwargs)
crossPlotSetHistogramVisible(plotID: Number, cf: bool) -> bool
 
Display histograms on the cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    cf (bool): {0 = 'remove the histograms', 1 = 'display the histograms'}
 
Returns:
    bool: operation exit status
crossPlotSetHistogramXYVisible(*args, **kwargs)
crossPlotSetHistogramXYVisible(plotID: Number, cf: str) -> bool
 
Display histograms on the cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    cf (str): {'NONE' = 'remove the histograms', 'HISTO_X' = 'display the histogram for X axis',
    'HISTO_Y' = 'display the histogram for Y axis', 'BOTH' = 'display the histograms'}
 
Returns:
    bool: operation exit status
crossPlotSetLabel(*args, **kwargs)
crossPlotSetLabel(plotID: Number, Vname: str, ScaleId: str='') -> bool
 
Set the a label to an existing cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    Vname (str): variable label name
    ScaleId (str): Optional; Scale id
 
Returns:
    bool: operation exit status
crossPlotSetLabel2(*args, **kwargs)
crossPlotSetLabel2(plotID: Number, Vname: str) -> bool
 
[DEPRECATED] Set the a second label to an existing cross-plot
 
Args:
    plotID (Number): cross-plot window windowID
    Vname (str): variable second label name
 
Returns:
    bool: operation exit status
crossPlotSetLabelValues(*args, **kwargs)
crossPlotSetLabelValues(plotID: Number, vn: str, vl: list, fam: str='', un: str='', ScaleId: str='') -> bool
 
Set a fictive set of user variables to the label axis of a cross-plot
The variable name must contain two dots, i.e 'Well.Dataset.Variable'
 
Args:
    plotID (Number): cross-plot window ID
    vn (str): variable name
    vl (list): list of values
    fam (str): Optional; variable family
    un (str): Optional; variable unit
    ScaleId (str): Optional; Scale id
 
Returns:
    bool: operation exit status
crossPlotSetLegendX(*args, **kwargs)
crossPlotSetLegendX(plotID: Number, legendx: str) -> bool
 
Set the cross-plot legend for X axis
 
Args:
    plotID (Number): cross-plot window ID
    legendx (str): legendx
 
Returns:
    bool: operation exit status
crossPlotSetLegendY(*args, **kwargs)
crossPlotSetLegendY(plotID: Number, legendy: str) -> bool
 
Set the cross-plot legend for Y axis
 
Args:
    plotID (Number): cross-plot window ID
    legendy (str): legendy
 
Returns:
    bool: operation exit status
crossPlotSetName(*args, **kwargs)
crossPlotSetName(plotID: Number, n: str) -> bool
 
Change the name of mono cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    n (str): new cross-plot name
 
Returns:
    bool: operation exit status
crossPlotSetPaletteBoundaries(*args, **kwargs)
crossPlotSetPaletteBoundaries(plotID: Number, min: Number, max: Number) -> bool
 
Set the boundaries of the palette for a single-well cross plot.
 
Args:
    plotID (Number): plot window ID
    min (Number): minimum of the palette
    max (Number): maximum of the palette
 
Returns:
    bool: operation exit status
crossPlotSetPointSizeAxisScale(*args, **kwargs)
crossPlotSetPointSizeAxisScale(plotID: Number, psasc: int) -> bool
 
Set the cross-plot point size axis scale
 
Args:
    plotID (Number): cross-plot window ID
    psasc (int): scale type {0 = 'LINEAR', 1 = 'LOGARITHMIC'}
 
Returns:
    bool: operation exit status
crossPlotSetPointSizeAxisSizeLimits(*args, **kwargs)
crossPlotSetPointSizeAxisSizeLimits(plotID: Number, psamin: Number, psamax: Number) -> bool
 
Set min & max sizes of cross-plot point size axis
 
Args:
    plotID (Number): cross-plot window ID
    psamin (Number): point size axis minimum size
    psamax (Number): point size axis maximum size
 
Returns:
    bool: operation exit status
crossPlotSetPointSizeAxisType(*args, **kwargs)
crossPlotSetPointSizeAxisType(plotID: Number, psat: int) -> bool
 
Change the type of cross-plot point size axis
 
Args:
    plotID (Number): cross-plot window ID
    psat (int): point size axis type {0 = 'VAR', 1 = 'USER', 2 = 'FAMILY'}
 
Returns:
    bool: operation exit status
crossPlotSetPointSizeAxisUserLimits(*args, **kwargs)
crossPlotSetPointSizeAxisUserLimits(plotID: Number, psamin: Number, psamax: Number) -> bool
 
Set min & max values of cross-plot point size axis
 
Args:
    plotID (Number): cross-plot window ID
    psamin (Number): point size axis minimum
    psamax (Number): point size axis maximum
 
Returns:
    bool: operation exit status
crossPlotSetSubtitle(*args, **kwargs)
crossPlotSetSubtitle(plotID: Number, subtitle: str) -> bool
 
Set the cross-plot subtitle
 
Args:
    plotID (Number): cross-plot window ID
    subtitle (str): subtitle
 
Returns:
    bool: operation exit status
crossPlotSetTitle(*args, **kwargs)
crossPlotSetTitle(plotID: Number, title: str) -> bool
 
Set the cross-plot title
 
Args:
    plotID (Number): cross-plot window ID
    title (str): title
 
Returns:
    bool: operation exit status
crossPlotSetX(*args, **kwargs)
crossPlotSetX(plotID: Number, Vname: str, ScaleId: str='') -> bool
 
Set the variable to X axis
 
Args:
    plotID (Number): cross-plot window ID
    Vname (str): variable X name
    ScaleId (str): Optional; Scale id
 
Returns:
    bool: operation exit status
crossPlotSetX2(*args, **kwargs)
crossPlotSetX2(plotID: Number, Vname: str) -> bool
 
[DEPRECATED] Set the variable to the second X axis
 
Args:
    plotID (Number): cross-plot window ID
    Vname (str): variable X2 name
 
Returns:
    bool: operation exit status
crossPlotSetX2Values(*args, **kwargs)
crossPlotSetX2Values(plotID: Number, vn: str, vl: list, fam: str='', un: str='') -> bool
 
[DEPRECATED] Set a fictive set of user variables to the second X axis of a cross-plot
The variable name must contain two dots, i.e 'Well.Dataset.Variable'
 
Args:
    plotID (Number): cross-plot window ID
    vn (str): variable name
    vl (list): list of values
    fam (str): Optional; variable family
    un (str): Optional; variable unit
 
Returns:
    bool: operation exit status
crossPlotSetXAxisInverse(*args, **kwargs)
crossPlotSetXAxisInverse(plotID: Number, xainv: bool) -> bool
 
Inverse the cross-plot X axis
 
Args:
    plotID (Number): cross-plot window ID
    xainv (bool): 1 = inverse else 0
 
Returns:
    bool: operation exit status
crossPlotSetXAxisScale(*args, **kwargs)
crossPlotSetXAxisScale(plotID: Number, xasc: int) -> bool
 
Set the cross-plot X axis scale
 
Args:
    plotID (Number): cross-plot window ID
    xasc (int): scale type {0 = 'LINEAR', 1 = 'LOGARITHMIC'}
 
Returns:
    bool: operation exit status
crossPlotSetXAxisType(*args, **kwargs)
crossPlotSetXAxisType(plotID: Number, xat: int, ScaleId: str='') -> bool
 
Change the type of cross-plot X axis
 
Args:
    plotID (Number): cross-plot window ID
    xat (int): X axis type {0 = 'VAR', 1 = 'USER', 2 = 'FAMILY'}
    ScaleId (str): Optional; Scale id
 
Returns:
    bool: operation exit status
crossPlotSetXAxisUnit(*args, **kwargs)
crossPlotSetXAxisUnit(plotID: Number, xau: str) -> bool
 
Change the unit of cross-plot X axis
 
Args:
    plotID (Number): cross-plot window ID
    xau (str): X axis unit
 
Returns:
    bool: operation exit status
crossPlotSetXAxisUserLimits(*args, **kwargs)
crossPlotSetXAxisUserLimits(plotID: Number, xamin: Number, xamax: Number, scaleID: str=None) -> bool
 
Set min & max values of cross-plot X axis for the given scale
 
Args:
    plotID (Number): cross-plot window ID
    xamin (Number): X axis minimum
    xamax (Number): X axis maximum
    scaleID (str): Optional; scale ID
 
Returns:
    bool: operation exit status
crossPlotSetXHistogramBinCount(*args, **kwargs)
crossPlotSetXHistogramBinCount(plotID: Number, binCount: int) -> bool
 
Change the bin count on histogram Horizontal
 
Args:
    plotID (Number): cross-plot window ID
    binCount (int): the new bin count
 
Returns:
    bool: operation exit status(TRUE,FALSE or NONE)
crossPlotSetXHistogramCumulativeFrequencyVisible(*args, **kwargs)
crossPlotSetXHistogramCumulativeFrequencyVisible(plotID: Number, binCount: bool) -> bool
 
Change the cumulative frequency visibility state on histogram Horizontal
 
Args:
    plotID (Number): cross-plot window ID
    binCount (bool): new visibility state
 
Returns:
    bool: operation exit status(TRUE,FALSE or NONE)
crossPlotSetXValues(*args, **kwargs)
crossPlotSetXValues(plotID: Number, vn: str, vl: list, fam: str='', un: str='', ScaleId: str='') -> bool
 
Set a fictive set of user variables to the X axis of a cross-plot
The variable name must contain two dots, i.e 'Well.Dataset.Variable'
 
Args:
    plotID (Number): cross-plot window ID
    vn (str): variable name
    vl (list): list of values
    fam (str): Optional; variable family
    un (str): Optional; variable unit
    ScaleId (str): Optional; Scale id
 
Returns:
    bool: operation exit status
crossPlotSetY(*args, **kwargs)
crossPlotSetY(plotID: Number, Vname: str, ScaleId: str='') -> bool
 
Set the variable to Y axis
 
Args:
    plotID (Number): cross-plot window ID
    Vname (str): variable Y name
    ScaleId (str): Optional; Scale id
 
Returns:
    bool: operation exit status
crossPlotSetY2(*args, **kwargs)
crossPlotSetY2(plotID: Number, Vname: str) -> bool
 
[DEPRECATED] Set the variable to the second Y axis
 
Args:
    plotID (Number): cross-plot window ID
    Vname (str): variable Y2 name
 
Returns:
    bool: operation exit status
crossPlotSetY2Values(*args, **kwargs)
crossPlotSetY2Values(plotID: Number, vn: str, vl: list, fam: str='', un: str='') -> bool
 
[DEPRECATED] Set a fictive set of user variables to the second Y axis of a cross-plot
The variable name must contain two dots, i.e 'Well.Dataset.Variable'
 
Args:
    plotID (Number): cross-plot window ID
    vn (str): variable name
    vl (list): list of values
    fam (str): Optional; variable family
    un (str): Optional; variable unit
 
Returns:
    bool: operation exit status
crossPlotSetYAxisInverse(*args, **kwargs)
crossPlotSetYAxisInverse(plotID: Number, yainv: bool) -> bool
 
Inverse the cross-plot Y axis
 
Args:
    plotID (Number): cross-plot window ID
    yainv (bool): 1 = inverse else 0
 
Returns:
    bool: operation exit status
crossPlotSetYAxisScale(*args, **kwargs)
crossPlotSetYAxisScale(plotID: Number, yasc: int) -> bool
 
Set the cross-plot Y axis scale
 
Args:
    plotID (Number): cross-plot window ID
    yasc (int): scale type {0 = 'LINEAR', 1 = 'LOGARITHMIC'}
 
Returns:
    bool: operation exit status
crossPlotSetYAxisType(*args, **kwargs)
crossPlotSetYAxisType(plotID: Number, yat: int, ScaleId: str='') -> bool
 
Change the type of cross-plot Y axis
 
Args:
    plotID (Number): cross-plot window ID
    yat (int): Y axis type {0 = 'VAR', 1 = 'USER', 2 = 'FAMILY'}
    ScaleId (str): Optional; Scale id
 
Returns:
    bool: operation exit status
crossPlotSetYAxisUnit(*args, **kwargs)
crossPlotSetYAxisUnit(plotID: Number, yau: str) -> bool
 
Change the unit of cross-plot Y axis
 
Args:
    plotID (Number): cross-plot window ID
    yau (str): Y axis unit
 
Returns:
    bool: operation exit status
crossPlotSetYAxisUserLimits(*args, **kwargs)
crossPlotSetYAxisUserLimits(plotID: Number, yamin: Number, yamax: Number, scaleID: str=None) -> bool
 
Set min & max values of cross-plot Y axis for the given scale
 
Args:
    plotID (Number): cross-plot window ID
    yamin (Number): Y axis minimum
    yamax (Number): Y axis maximum
    scaleID (str): Optional; scale ID
 
Returns:
    bool: operation exit status
crossPlotSetYHistogramBinCount(*args, **kwargs)
crossPlotSetYHistogramBinCount(plotID: Number, binCount: int) -> bool
 
Change the bin count on histogram Vertical
 
Args:
    plotID (Number): cross-plot window ID
    binCount (int): the new bin count
 
Returns:
    bool: operation exit status(TRUE,FALSE or NONE)
crossPlotSetYHistogramCumulativeFrequencyVisible(*args, **kwargs)
crossPlotSetYHistogramCumulativeFrequencyVisible(plotID: Number, binCount: bool) -> bool
 
Change the cumulative frequency visibility state on histogram Vertical
 
Args:
    plotID (Number): cross-plot window ID
    binCount (bool): new visibility state
 
Returns:
    bool: operation exit status(TRUE,FALSE or NONE)
crossPlotSetYValues(*args, **kwargs)
crossPlotSetYValues(plotID: Number, vn: str, vl: list, fam: str='', un: str='', ScaleId: str='') -> bool
 
Set a fictive set of user variables to the Y axis of a cross-plot
The variable name must contain two dots, i.e 'Well.Dataset.Variable'
 
Args:
    plotID (Number): cross-plot window ID
    vn (str): variable name
    vl (list): list of values
    fam (str): Optional; variable family
    un (str): Optional; variable unit
    ScaleId (str): Optional; Scale id
 
Returns:
    bool: operation exit status
crossPlotSetZonation(*args, **kwargs)
crossPlotSetZonation(plotID: Number, d: str) -> bool
 
Set the zonation dataset to the cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    d (str): zonation dataset name
 
Returns:
    bool: operation exit status
crossplotAddRegression(*args, **kwargs)
crossplotAddRegression(plotID: Number, r: Number=0, g: Number=0, b: Number=0) -> bool
 
Add a regression in a cross-plot & sets the color
 
Args:
    plotID (Number): cross-plot window ID
    r (Number): Optional; red
    g (Number): Optional; green
    b (Number): Optional; blue
 
Returns:
    bool: operation exit status
crossplotMultiWellAddRegression(*args, **kwargs)
crossplotMultiWellAddRegression(plotID: Number, r: Number=0, g: Number=0, b: Number=0, Regression_Type: int=-1, Explanatory_variable_transformation: int=-1, Explained_variable_transformation: int=-1, Power_Function: bool=False) -> bool
 
Add a regression in a cross-plot & sets the color
 
Args:
    plotID (Number): cross-plot window ID
    r (Number): Optional; red
    g (Number): Optional; green
    b (Number): Optional; blue
    Regression_Type (int): Optional; Regression type {0 = 'XonY', 1 = 'YonX', 2 = 'MA', 3 = 'RMAXonY', 4 = 'RMAYonX', 5 = 'QUANTILE', 6 = 'SWANSON'}
    Explanatory_variable_transformation (int): Optional; Explanatory variable transformation {0 = 'None', 1 = 'LOG10', 2 = 'EXP'}
    Explained_variable_transformation (int): Optional; Explained variable transformation {0 = 'None', 1 = 'LOG10', 2 = 'EXP'}
    Power_Function (bool): Optional; True if you want to enabled the power function
 
Returns:
    bool: operation exit status
cumulativeDipPlotAddZone(*args, **kwargs)
cumulativeDipPlotAddZone(plotID: Number, z: str) -> bool
 
Add a zone in the selection to the cumulative dip-plot
 
Args:
    plotID (Number): plot window ID
    z (str): zone name
 
Returns:
    bool: operation exit status
cumulativeDipPlotApplyTo(*args, **kwargs)
cumulativeDipPlotApplyTo(plotID: Number, ds: list) -> bool
 
Apply the cumulative dip-plot to a data set list
 
Args:
    plotID (Number): plot window ID
    ds (list): dataset ID (wellName.datasetName)
 
Returns:
    bool: operation exit status
cumulativeDipPlotCleanZonation(*args, **kwargs)
cumulativeDipPlotCleanZonation(plotID: Number, d: str) -> bool
 
Remove the zonation dataset from the cumulative dip-plot - any display of zone must previously be cancelled
 
Args:
    plotID (Number): plot window ID
    d (str): zonation dataset name
 
Returns:
    bool: operation exit status
cumulativeDipPlotCleanZone(*args, **kwargs)
cumulativeDipPlotCleanZone(plotID: Number, z: str) -> bool
 
Remove a zone in the selection from the cumulative dip-plot
 
Args:
    plotID (Number): plot window ID
    z (str): zone name
 
Returns:
    bool: operation exit status
cumulativeDipPlotCreate(*args, **kwargs)
cumulativeDipPlotCreate(n: str, dip: str='', azimuth: str='', color: str='', filter: str='') -> Number
 
Create a new cumulative dip-plot
 
Args:
    n (str): plot window name
    dip (str): Optional; variable name
    azimuth (str): Optional; variable name
    color (str): Optional; variable name
    filter (str): Optional; variable name
 
Returns:
    Number: plot window ID
cumulativeDipPlotDeleteAzimuth(*args, **kwargs)
cumulativeDipPlotDeleteAzimuth(plotID: Number) -> bool
 
Delete the azimuth variable of a cumulative dip-plot
 
Args:
    plotID (Number): plot window ID
 
Returns:
    bool: operation exit status
cumulativeDipPlotDeleteColor(*args, **kwargs)
cumulativeDipPlotDeleteColor(plotID: Number) -> bool
 
Delete the color variable of a cumulative dip-plot
 
Args:
    plotID (Number): plot window ID
 
Returns:
    bool: operation exit status
cumulativeDipPlotDeleteDip(*args, **kwargs)
cumulativeDipPlotDeleteDip(plotID: Number) -> bool
 
Delete the dip variable of a cumulative dip-plot
 
Args:
    plotID (Number): plot window ID
 
Returns:
    bool: operation exit status
cumulativeDipPlotDeleteFilter(*args, **kwargs)
cumulativeDipPlotDeleteFilter(plotID: Number) -> bool
 
Delete the filter variable of a cumulative dip-plot
 
Args:
    plotID (Number): plot window ID
 
Returns:
    bool: operation exit status
cumulativeDipPlotDuplicate(*args, **kwargs)
cumulativeDipPlotDuplicate(plotID: Number) -> Number
 
Duplicate the cumulative dip-plot
 
Args:
    plotID (Number): plot window ID
 
Returns:
    Number: new plot id or -1
cumulativeDipPlotGetIdByName(*args, **kwargs)
cumulativeDipPlotGetIdByName(n: str) -> Number
 
Find the ID of a name-known cumulative dip-plot
 
Args:
    n (str): plot name
 
Returns:
    Number: plot window ID
cumulativeDipPlotLockTitle(*args, **kwargs)
cumulativeDipPlotLockTitle(plotID: Number, locked: bool) -> bool
 
Lock title of the cumulative dip-plot
 
Args:
    plotID (Number): plot window ID
    locked (bool): True if locked, False else
 
Returns:
    bool: operation exit status
cumulativeDipPlotOpen(*args, **kwargs)
cumulativeDipPlotOpen(n: str, f: str=None) -> Number
 
Open an existing cumulative dip plot
 
Args:
    n (str): plot name
    f (str): Optional; folder
 
Returns:
    Number: plot ID
cumulativeDipPlotOpenWalkoutPlot(*args, **kwargs)
cumulativeDipPlotOpenWalkoutPlot(plotID: Number) -> Number
 
Open a walkout-plot
 
Args:
    plotID (Number): cumulative dip-plot window ID
 
Returns:
    Number: walkout-plot window ID
cumulativeDipPlotSave(*args, **kwargs)
cumulativeDipPlotSave(plotID: Number, n: str, f: str='') -> bool
 
Save the cumulative dip-plot
 
Args:
    plotID (Number): plot window ID
    n (str): file name
    f (str): Optional; folder
 
Returns:
    bool: operation exit status
cumulativeDipPlotSelectFilter(*args, **kwargs)
cumulativeDipPlotSelectFilter(plotID: Number, FilterValues: list) -> bool
 
Select the filter values
 
Args:
    plotID (Number): plot window ID
    FilterValues (list): filter values
 
Returns:
    bool: operation exit status
cumulativeDipPlotSetAutomaticAdjustment(*args, **kwargs)
cumulativeDipPlotSetAutomaticAdjustment(plotID: Number, b: bool) -> bool
 
Set the automatic adjustment on cumulative dip-plot
 
Args:
    plotID (Number): plot window ID
    b (bool): True for automatic adjustment, False else
 
Returns:
    bool: operation exit status
cumulativeDipPlotSetAzimuth(*args, **kwargs)
cumulativeDipPlotSetAzimuth(plotID: Number, azimuth: str) -> bool
 
Set the azimuth variable of a cumulative dip-plot
 
Args:
    plotID (Number): plot window ID
    azimuth (str): variable name
 
Returns:
    bool: operation exit status
cumulativeDipPlotSetColor(*args, **kwargs)
cumulativeDipPlotSetColor(plotID: Number, color: str) -> bool
 
Set the color variable of a cumulative dip-plot
 
Args:
    plotID (Number): plot window ID
    color (str): variable name
 
Returns:
    bool: operation exit status
cumulativeDipPlotSetColorMode(*args, **kwargs)
cumulativeDipPlotSetColorMode(plotID: Number, mode: str='BY PALETTE') -> bool
 
Set the color mode on cumulative dip-plot
 
Args:
    plotID (Number): plot window ID
    mode (str): Optional; color mode {'BY PALETTE', 'BY SOURCE', 'BY ZONE'}
 
Returns:
    bool: operation exit status
cumulativeDipPlotSetColourMode(*args, **kwargs)
cumulativeDipPlotSetColourMode(plotID: Number, mode: str='BY PALETTE') -> bool
 
[DEPRECATED] (use cumulativeDipPlotSetColorMode instead) Set the color mode on cumulative dip-plot
 
Args:
    plotID (Number): plot window ID
    mode (str): Optional; color mode {'BY PALETTE', 'BY SOURCE', 'BY ZONE'}
 
Returns:
    bool: operation exit status
cumulativeDipPlotSetDatum(*args, **kwargs)
cumulativeDipPlotSetDatum(plotID: Number, lim: bool, ymin: Number=0, ymax: Number=0) -> bool
 
Change the reference limitation on cumulative dip-plot
 
Args:
    plotID (Number): plot window ID
    lim (bool): 0 for 'whole datum' / 1 for 'user values'
    ymin (Number): Optional; top limitation
    ymax (Number): Optional; bottom limitation
 
Returns:
    bool: operation exit status
cumulativeDipPlotSetDip(*args, **kwargs)
cumulativeDipPlotSetDip(plotID: Number, dip: str) -> bool
 
Set the dip variable of a cumulative dip-plot
 
Args:
    plotID (Number): plot window ID
    dip (str): variable name
 
Returns:
    bool: operation exit status
cumulativeDipPlotSetFilter(*args, **kwargs)
cumulativeDipPlotSetFilter(plotID: Number, filter: str) -> bool
 
Set the filter variable of a cumulative dip-plot
 
Args:
    plotID (Number): plot window ID
    filter (str): variable name
 
Returns:
    bool: operation exit status
cumulativeDipPlotSetMarkersColor(*args, **kwargs)
cumulativeDipPlotSetMarkersColor(plotID: Number, r: Number, g: Number, b: Number) -> bool
 
Set the makers color on cumulative dip-plot
 
Args:
    plotID (Number): plot window ID
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
cumulativeDipPlotSetMarkersColour(*args, **kwargs)
cumulativeDipPlotSetMarkersColour(plotID: Number, r: Number, g: Number, b: Number) -> bool
 
[DEPRECATED] (use cumulativeDipPlotSetMarkersColor instead) Set the makers color on cumulative dip-plot
 
Args:
    plotID (Number): plot window ID
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
cumulativeDipPlotSetMarkersSize(*args, **kwargs)
cumulativeDipPlotSetMarkersSize(plotID: Number, s: Number) -> bool
 
Set the makers size on cumulative dip-plot
 
Args:
    plotID (Number): plot window ID
    s (Number): size
 
Returns:
    bool: operation exit status
cumulativeDipPlotSetName(*args, **kwargs)
cumulativeDipPlotSetName(plotID: Number, n: str) -> bool
 
Change the name of the cumulative dip-plot
 
Args:
    plotID (Number): plot window ID
    n (str): new plot windows name
 
Returns:
    bool: operation exit status
cumulativeDipPlotSetXAxisGraduations(*args, **kwargs)
cumulativeDipPlotSetXAxisGraduations(plotID: Number, f: Number) -> bool
 
Set the x axis graduations of the cumulative dip-plot
 
Args:
    plotID (Number): plot window ID
    f (Number): graduations
 
Returns:
    bool: operation exit status
cumulativeDipPlotSetXAxisInverse(*args, **kwargs)
cumulativeDipPlotSetXAxisInverse(plotID: Number, b: bool) -> bool
 
Set the x axis inverse of the cumulative dip-plot
 
Args:
    plotID (Number): plot window ID
    b (bool): True if inversed, False else
 
Returns:
    bool: operation exit status
cumulativeDipPlotSetXAxisType(*args, **kwargs)
cumulativeDipPlotSetXAxisType(plotID: Number, type: str='VARIABLE') -> bool
 
Set the x axis type of the cumulative dip-plot
 
Args:
    plotID (Number): plot window ID
    type (str): Optional; axis type {'VARIABLE', 'USER'}
 
Returns:
    bool: operation exit status
cumulativeDipPlotSetXAxisUserLimits(*args, **kwargs)
cumulativeDipPlotSetXAxisUserLimits(plotID: Number, min: Number, max: Number) -> bool
 
Set the x axis user limits of the cumulative dip-plot
 
Args:
    plotID (Number): plot window ID
    min (Number): min user
    max (Number): max user
 
Returns:
    bool: operation exit status
cumulativeDipPlotSetYAxisGraduations(*args, **kwargs)
cumulativeDipPlotSetYAxisGraduations(plotID: Number, f: Number) -> bool
 
Set the y axis graduations of the cumulative dip-plot
 
Args:
    plotID (Number): plot window ID
    f (Number): graduations
 
Returns:
    bool: operation exit status
cumulativeDipPlotSetYAxisInverse(*args, **kwargs)
cumulativeDipPlotSetYAxisInverse(plotID: Number, b: bool) -> bool
 
Set the y axis inverse of the cumulative dip-plot
 
Args:
    plotID (Number): plot window ID
    b (bool): True if inversed, False else
 
Returns:
    bool: operation exit status
cumulativeDipPlotSetYAxisType(*args, **kwargs)
cumulativeDipPlotSetYAxisType(plotID: Number, type: str='VARIABLE') -> bool
 
Set the y axis type of the cumulative dip-plot
 
Args:
    plotID (Number): plot window ID
    type (str): Optional; axis type {'VARIABLE', 'USER'}
 
Returns:
    bool: operation exit status
cumulativeDipPlotSetYAxisUserLimits(*args, **kwargs)
cumulativeDipPlotSetYAxisUserLimits(plotID: Number, min: Number, max: Number) -> bool
 
Set the y axis user limits of the cumulative dip-plot
 
Args:
    plotID (Number): plot window ID
    min (Number): min user
    max (Number): max user
 
Returns:
    bool: operation exit status
cumulativeDipPlotSetZonation(*args, **kwargs)
cumulativeDipPlotSetZonation(plotID: Number, d: str) -> bool
 
Set the zonation dataset to the cumulative dip-plot
 
Args:
    plotID (Number): plot window ID
    d (str): zonation dataset name
 
Returns:
    bool: operation exit status
customPlotAddAction(*args, **kwargs)
customPlotAddAction(plotID: Number, ActionName: str, Location: int, GlobalPosition: int=4, ActionAfter: str) -> bool
 
Add an action to toolbar, mouseMode and/or contextMenu with the given position (begin, middle or end)
 
Args:
    plotID (Number): custom-plot window ID
    ActionName (str): Name of action
    Location (int): Location of action : Tool-bar = 1,Mouse-mode = 2, Context-menu = 4. You can associate it.
    GlobalPosition (int): Optional; Global position of action : Begin = 1, Middle = 2, End = 4.
    ActionAfter (str): [=]: Name of action we want to introduce before.
 
Returns:
    bool: operation exit status
customPlotAddActionToCreatedMenu(*args, **kwargs)
customPlotAddActionToCreatedMenu(plotID: Number, MenuName: str, ActionName: str, ActionAfter: str) -> bool
 
Add action to existing menu before the given action name.
 
Args:
    plotID (Number): custom-plot window ID
    MenuName (str): Name of menu.
    ActionName (str): Name of action.
    ActionAfter (str): [=]: Name of action we want to introduce before.
 
Returns:
    bool: operation exit status
customPlotAddActionToDefaultMenu(*args, **kwargs)
customPlotAddActionToDefaultMenu(plotID: Number, Menu: int, ActionName: str, GlobalPosition: int) -> bool
 
Add action to existing menu.
 
Args:
    plotID (Number): custom-plot window ID
    Menu (int): Menu : DISPLAY = 1, EDIT = 2, INSERT = 4, OPEN = 8, PLOT = 16, SAVE = 32, PROCESSING = 64, PROPERTIES = 128, SELECTION = 256.
    ActionName (str): Name of action.
    GlobalPosition (int): Global position of action : Begin = 1, Middle = 2, End = 4.
 
Returns:
    bool: operation exit status
customPlotAddActionToDefaultMenuDynamic(*args, **kwargs)
customPlotAddActionToDefaultMenuDynamic(plotID: Number, Menu: int, ActionName: str, ActionAfter: str) -> bool
 
Add action to existing menu.
 
Args:
    plotID (Number): custom-plot window ID
    Menu (int): Menu : DISPLAY = 1, EDIT = 2, INSERT = 4, OPEN = 8, PLOT = 16, SAVE = 32, PROCESSING = 64, PROPERTIES = 128, SELECTION = 256.
    ActionName (str): Name of action.
    ActionAfter (str): Name of action we want to introduce before.
 
Returns:
    bool: operation exit status
customPlotAddNewMenu(*args, **kwargs)
customPlotAddNewMenu(plotID: Number, MenuName: str, ActionList: list) -> bool
 
Add a menu.
 
Args:
    plotID (Number): custom-plot window ID.
    MenuName (str): Name of menu.
    ActionList (list): List of action we want to add to menu.
 
Returns:
    bool: operation exit status
customPlotAddNewTable(*args, **kwargs)
customPlotAddNewTable(plotID: Number, TableName: str) -> bool
 
Add a new table widget on left part of custom plot. (Here for this exemple, the widget are empty)
 
Args:
    plotID (Number): custom-plot window ID
    TableName (str): Name of table.
 
Returns:
    bool: operation exit status
customPlotAddPlotToWorkspace(*args, **kwargs)
customPlotAddPlotToWorkspace(plotID: Number) -> bool
 
Add the plot to workspace.
 
Args:
    plotID (Number): custom-plot window ID
 
Returns:
    bool: operation exit status
customPlotCreate(*args, **kwargs)
customPlotCreate(n: str) -> Number
 
Create a  custom plot, you have to add it to workspace for see it.
 
Args:
    n (str): custom plot window name
 
Returns:
    Number: custom-plot window ID
customPlotDisplayDefaultActions(*args, **kwargs)
customPlotDisplayDefaultActions(plotID: Number, IsDisplay: bool) -> bool
 
Say if you want to display default action.
 
Args:
    plotID (Number): custom-plot window ID
    IsDisplay (bool): True if you want to display default menu.
 
Returns:
    bool: operation exit status
customPlotDisplayMenu(*args, **kwargs)
customPlotDisplayMenu(plotID: Number, IsDisplay: bool) -> bool
 
Say if you want to hide menu when they are empty.
 
Args:
    plotID (Number): custom-plot window ID
    IsDisplay (bool): True if you want to display default menu.
 
Returns:
    bool: operation exit status
customPlotInsertChart(*args, **kwargs)
customPlotInsertChart(plotID: Number, chartFile: str) -> bool
 
Insert a chart in custom plot
 
Args:
    plotID (Number): custom-plot window ID
    chartFile (str): Name of chart we want to insert
 
Returns:
    bool: operation exit status
customPlotInsertDynamicChart(*args, **kwargs)
customPlotInsertDynamicChart(plotID: Number, chart: str, chartName: str) -> bool
 
Insert a chart dynamically in custom plot
 
Args:
    plotID (Number): custom-plot window ID
    chart (str): Chart we want to insert
    chartName (str): Title of chart
 
Returns:
    bool: operation exit status
customPlotRemoveChart(*args, **kwargs)
customPlotRemoveChart(plotID: Number, chartFile: str) -> bool
 
Remove a chart in custom plot
 
Args:
    plotID (Number): custom-plot window ID
    chartFile (str): Name of chart we want to remove
 
Returns:
    bool: operation exit status
customPlotResize(*args, **kwargs)
customPlotResize(plotID: Number, width: Number, height: Number) -> bool
 
Resize the widget
 
Args:
    plotID (Number): custom-plot window ID
    width (Number): Width of widget after resize
    height (Number): Height of widget after resize
 
Returns:
    bool: operation exit status
customPlotSetCursorToAction(*args, **kwargs)
customPlotSetCursorToAction(plotID: Number, ActionName: str, Cursor: int) -> bool
 
Associate a cursor for a given action when you are in viewer. (Here for this exemple, create an action in Mouse Mode begin)
 
Args:
    plotID (Number): custom-plot window ID
    ActionName (str): Name of action
    Cursor (int): Qt::CursorShape, see website for number.
 
Returns:
    bool: operation exit status
customPlotSetHorizontalLegendName(*args, **kwargs)
customPlotSetHorizontalLegendName(plotID: Number, legendY: str) -> bool
 
Set the name of the horizontal legend
 
Args:
    plotID (Number): custom-plot window ID
    legendY (str): Name of legend on Y
 
Returns:
    bool: operation exit status
customPlotSetPlotSubTitle(*args, **kwargs)
customPlotSetPlotSubTitle(plotID: Number, subtitle: str) -> bool
 
Set a subtitle to plot
 
Args:
    plotID (Number): custom-plot window ID
    subtitle (str): Name of subtitle
 
Returns:
    bool: operation exit status
customPlotSetPlotTitle(*args, **kwargs)
customPlotSetPlotTitle(plotID: Number, title: str) -> bool
 
Set a title to plot
 
Args:
    plotID (Number): custom-plot window ID
    title (str): Name of title
 
Returns:
    bool: operation exit status
customPlotSetVerticalLegendName(*args, **kwargs)
customPlotSetVerticalLegendName(plotID: Number, legendY: str) -> bool
 
Set the name of the vertical legend
 
Args:
    plotID (Number): custom-plot window ID
    legendY (str): Name of legend on Y
 
Returns:
    bool: operation exit status
customPlotSetWindowTitle(*args, **kwargs)
customPlotSetWindowTitle(plotID: Number, title: str) -> bool
 
Set a title to window
 
Args:
    plotID (Number): custom-plot window ID
    title (str): Name of title
 
Returns:
    bool: operation exit status
depthArrayPlotDuplicate(*args, **kwargs)
depthArrayPlotDuplicate(plotID: Number) -> Number
 
Duplicate an existing depth array plot
 
Args:
    plotID (Number): plot Id to duplicate
 
Returns:
    Number: plot ID
depthArrayPlotOpen(*args, **kwargs)
depthArrayPlotOpen(n: str, f: str=None) -> Number
 
Open an existing depth array plot
 
Args:
    n (str): plot name
    f (str): Optional; folder
 
Returns:
    Number: plot ID
depthMapPlotCreate(*args, **kwargs)
depthMapPlotCreate(n: str) -> Number
 
Create a new depth map plot
 
Args:
    n (str): plot name
 
Returns:
    Number: plot ID
depthMapPlotSetData(*args, **kwargs)
depthMapPlotSetData(plotID: Number, fileName: str, t: list, nbL: Number, nbC: Number, minX: Number, stepX: Number, unitX: str, minY: Number, stepY: Number, unitY: str, referenceValues: list, referenceName: str, referenceUnit: str, referenceFamily: str) -> bool
 
Set the data of a depth map plot
 
Args:
    plotID (Number): plot window ID
    fileName (str): name for the reference
    t (list): list of the map data
    nbL (Number): number of row
    nbC (Number): number of column
    minX (Number): minimum X axis
    stepX (Number): step X axis
    unitX (str): unit X axis
    minY (Number): minimum Y axis
    stepY (Number): step Y axis
    unitY (str): unit Y axis
    referenceValues (list): list of reference values
    referenceName (str): name of the reference variable
    referenceUnit (str): unit of the reference variable
    referenceFamily (str): reference Family
 
Returns:
    bool: operation exit status
enableBenchmark(*args, **kwargs)
enableBenchmark(enable: bool)
 
start the benchmarking
 
Args:
    enable (bool): True  start, False stop
 
Returns:
geometryAddBasePolygon(*args, **kwargs)
geometryAddBasePolygon(ID: Number, points: list) -> bool
 
add a new base polygon in the geometry engine. If new polygon intersect geometry, operation fails
 
Args:
    ID (Number): id of the plot - geometry feature is only available for 3DP and 2DWT
    points (list): polygon points [(x1, y1), (x2, y2), ...], for polygon ABCDA, user should only provide A, B, C, D points
 
Returns:
    bool: True if operation is done else exception
geometryAddBoundary(*args, **kwargs)
geometryAddBoundary(ID: Number, points: list) -> bool
 
Split the geometry with a new boundary.
 
Args:
    ID (Number): id of the plot - geometry feature is only available for 3DP and 2DWT
    points (list): boundary points list [(x1, y1), (x2, y2), ...]
 
Returns:
    bool: True if operation is done else exception
geometryAddProperty(*args, **kwargs)
geometryAddProperty(ID: Number, propertyName: str, measurement: str, unit: str, paletteName: str) -> bool
 
Add a new property family to the geometry.
 
Args:
    ID (Number): id of the plot - geometry feature is only available for 3DP and 2DWT
    propertyName (str): name of the property family to add
    measurement (str): measurement name
    unit (str): unit of the family values
    paletteName (str): name of the palette to use for displaying the family
 
Returns:
    bool: True if operation is done else exception
geometryDeleteBoundary(*args, **kwargs)
geometryDeleteBoundary(ID: Number, point: tuple) -> bool
 
Delete a geometry boundary.
 
Args:
    ID (Number): id of the plot - geometry feature is only available for 3DP and 2DWT
    point (tuple): point selection for boundary
 
Returns:
    bool: True if operation is done else exception
geometryDeletePoint(*args, **kwargs)
geometryDeletePoint(ID: Number, point: tuple) -> bool
 
Delete a geometry point.
 
Args:
    ID (Number): id of the plot - geometry feature is only available for 3DP and 2DWT
    point (tuple): point position
 
Returns:
    bool: True if operation is done else exception
geometryDeleteProperty(*args, **kwargs)
geometryDeleteProperty(ID: Number, propertyName: str) -> bool
 
Delete a property family.
 
Args:
    ID (Number): id of the plot - geometry feature is only available for 3DP and 2DWT
    propertyName (str): name of the property family to delete
 
Returns:
    bool: True if operation is done else exception
geometryGetPolygons(*args, **kwargs)
geometryGetPolygons(ID: Number) -> list
 
Get all geometry polygons.
 
Args:
    ID (Number): id of the plot - geometry feature is only available for 3DP and 2DWT
 
Returns:
    list: list of list of point(x,y)
geometryMoveBoundary(*args, **kwargs)
geometryMoveBoundary(ID: Number, point: tuple, point: tuple) -> bool
 
Move a geometry boundary.
 
Args:
    ID (Number): id of the plot - geometry feature is only available for 3DP and 2DWT
    point (tuple): boundary point initial position
    point (tuple): translation vector
 
Returns:
    bool: True if operation is done else exception
geometryMovePoint(*args, **kwargs)
geometryMovePoint(ID: Number, point: tuple, point: tuple) -> bool
 
Move a geometry point.
 
Args:
    ID (Number): id of the plot - geometry feature is only available for 3DP and 2DWT
    point (tuple): point initial position
    point (tuple): point destination position
 
Returns:
    bool: True if operation is done else exception
geometryReset(*args, **kwargs)
geometryReset(ID: Number) -> bool
 
delete all geometry features of the geometric engine.
 
Args:
    ID (Number): id of the plot - geometry feature is only available for 3DP and 2DWT
 
Returns:
    bool: True if operation is done else exception
geometryRotateBoundary(*args, **kwargs)
geometryRotateBoundary(ID: Number, point: tuple, center: tuple, angle: Number) -> bool
 
Rotate a geometry Boundary.
 
Args:
    ID (Number): id of the plot - geometry feature is only available for 3DP and 2DWT
    point (tuple): Boundary point selection
    center (tuple): rotation center
    angle (Number): rotation angle in degree
 
Returns:
    bool: True if operation is done else exception
geometrySelectProperty(*args, **kwargs)
geometrySelectProperty(ID: Number, propertyName: str) -> bool
 
select the property family to display.
 
Args:
    ID (Number): id of the plot - geometry feature is only available for 3DP and 2DWT
    propertyName (str): name of the property family to display
 
Returns:
    bool: True if operation is done else exception
geometrySetPolygonProperty(*args, **kwargs)
geometrySetPolygonProperty(ID: Number, point: tuple, propertyName: str, propertyValue: Number) -> bool
 
Set polygon property.
 
Args:
    ID (Number): id of the plot - geometry feature is only available for 3DP and 2DWT
    point (tuple): point selection for polygon
    propertyName (str): name of the property family to delete
    propertyValue (Number): new value for the property family of the selected polygon
 
Returns:
    bool: True if operation is done else exception
headerEditorAddBox(*args, **kwargs)
headerEditorAddBox(headerEditorID: Number, x: Number, y: Number, w: Number, h: Number) -> Number
 
Add a box to a header editor
 
Args:
    headerEditorID (Number): header editor window ID
    x (Number): left coordinate of the box
    y (Number): top coordinate of the box
    w (Number): width of the box
    h (Number): height of the box
 
Returns:
    Number: header object ID
headerEditorAddHeader(*args, **kwargs)
headerEditorAddHeader(headerEditorID: Number, n: str, f: str=None) -> Number
 
Add an existing header to the header editor
 
Args:
    headerEditorID (Number): header editor window ID
    n (str): header name
    f (str): Optional; folder
 
Returns:
    Number: header ID
headerEditorAddImage(*args, **kwargs)
headerEditorAddImage(headerEditorID: Number, path: str, x: Number=0, y: Number=0) -> Number
 
Add an image to the header editor
 
Args:
    headerEditorID (Number): header editor window ID
    path (str): image path
    x (Number): Optional; left coordinate of the image
    y (Number): Optional; top coordinate of the image
 
Returns:
    Number: header object ID
headerEditorAddImageFromProperty(*args, **kwargs)
headerEditorAddImageFromProperty(headerEditorID: Number, path: str, x: Number=0, y: Number=0) -> Number
 
Add an image to the header editor using properties
 
Args:
    headerEditorID (Number): header editor window ID
    path (str): image path using properties
    x (Number): Optional; left coordinate of the image
    y (Number): Optional; top coordinate of the image
 
Returns:
    Number: header object ID
headerEditorAddLine(*args, **kwargs)
headerEditorAddLine(headerEditorID: Number, x1: Number, y1: Number, x2: Number, y2: Number) -> Number
 
Add a line to a header editor
 
Args:
    headerEditorID (Number): header editor window ID
    x1 (Number): x coordinate of the first extremity of the line
    y1 (Number): y coordinate of the first extremity of the line
    x2 (Number): x coordinate of the second extremity of the line
    y2 (Number): y coordinate of the second extremity of the line
 
Returns:
    Number: header object ID
headerEditorAddProperty(*args, **kwargs)
headerEditorAddProperty(headerEditorID: Number, objectID: Number, text: str) -> bool
 
Add a property to the header object
 
Args:
    headerEditorID (Number): header editor window ID
    objectID (Number): header object ID
    text (str): text of the property (using '%')
 
Returns:
    bool: operation exit status
headerEditorAddTable(*args, **kwargs)
headerEditorAddTable(headerEditorID: Number, rowCount: Number, columnCount: Number) -> Number
 
Add a table to a header editor
 
Args:
    headerEditorID (Number): header editor window ID
    rowCount (Number): Number of row of the table
    columnCount (Number): Number of column of the table
 
Returns:
    Number: header object ID
headerEditorAddText(*args, **kwargs)
headerEditorAddText(headerEditorID: Number, x: Number, y: Number, w: Number, h: Number, text: str=None) -> Number
 
Add a text to a header editor
 
Args:
    headerEditorID (Number): header editor window ID
    x (Number): left coordinate of the text
    y (Number): top coordinate of the text
    w (Number): width of the text
    h (Number): height of the text
    text (str): Optional; text
 
Returns:
    Number: header object ID
headerEditorAlignObjectsOnTheGrid(*args, **kwargs)
headerEditorAlignObjectsOnTheGrid(headerEditorID: Number, align: bool) -> bool
 
Enable to align objects on the grid
 
Args:
    headerEditorID (Number): header editor window ID
    align (bool): 1 = align; 0 = don't align
 
Returns:
    bool: operation exit status
headerEditorApplyPropertiesTo(*args, **kwargs)
headerEditorApplyPropertiesTo(headerEditorID: Number, well: str=None, dataset: str=None) -> bool
 
Apply the properties (tags) of the header to a particular well and dataset
 
Args:
    headerEditorID (Number): header editor window ID
    well (str): Optional; well name
    dataset (str): Optional; dataset name
 
Returns:
    bool: operation exit status
headerEditorChangeDisplayMode(*args, **kwargs)
headerEditorChangeDisplayMode(headerEditorID: Number, result: bool) -> bool
 
Change the display mode
 
Args:
    headerEditorID (Number): header editor window ID
    result (bool): 1 = display result texts; 0 = display tags
 
Returns:
    bool: operation exit status
headerEditorCreate(*args, **kwargs)
headerEditorCreate() -> Number
 
Create a new header editor
 
Returns:
    Number: header editor ID
headerEditorNew(*args, **kwargs)
headerEditorNew(headerEditorID: Number) -> bool
 
Reset a header editor
 
Args:
    headerEditorID (Number): header editor window ID
 
Returns:
    bool: operation exit status
headerEditorObjectBringForward(*args, **kwargs)
headerEditorObjectBringForward(headerEditorID: Number, objectID: Number) -> bool
 
Bring forward an object of the header editor
 
Args:
    headerEditorID (Number): header editor window ID
    objectID (Number): header object ID
 
Returns:
    bool: operation exit status
headerEditorObjectBringToFront(*args, **kwargs)
headerEditorObjectBringToFront(headerEditorID: Number, objectID: Number) -> bool
 
Bring to front an object of the header editor
 
Args:
    headerEditorID (Number): header editor window ID
    objectID (Number): header object ID
 
Returns:
    bool: operation exit status
headerEditorObjectSendBackward(*args, **kwargs)
headerEditorObjectSendBackward(headerEditorID: Number, objectID: Number) -> bool
 
Send backward an object of the header editor
 
Args:
    headerEditorID (Number): header editor window ID
    objectID (Number): header object ID
 
Returns:
    bool: operation exit status
headerEditorObjectSendToBack(*args, **kwargs)
headerEditorObjectSendToBack(headerEditorID: Number, objectID: Number) -> bool
 
Send to back an object of the header editor
 
Args:
    headerEditorID (Number): header editor window ID
    objectID (Number): header object ID
 
Returns:
    bool: operation exit status
headerEditorOpen(*args, **kwargs)
headerEditorOpen(n: str, f: str=None) -> Number
 
Open an existing header editor
 
Args:
    n (str): header name
    f (str): Optional; folder
 
Returns:
    Number: header editor ID
headerEditorRemoveHeader(*args, **kwargs)
headerEditorRemoveHeader(headerEditorID: Number, headerID: Number) -> bool
 
Remove an existing header from the header editor
 
Args:
    headerEditorID (Number): header editor window ID
    headerID (Number): header ID
 
Returns:
    bool: operation exit status
headerEditorRemoveObject(*args, **kwargs)
headerEditorRemoveObject(headerEditorID: Number, objectID: Number) -> bool
 
Remove an object from the header editor
 
Args:
    headerEditorID (Number): header editor window ID
    objectID (Number): header object ID
 
Returns:
    bool: operation exit status
headerEditorSave(*args, **kwargs)
headerEditorSave(headerEditorID: Number, n: str, f: str=None, Copy_pictures: bool=True) -> bool
 
Save a header editor
 
Args:
    headerEditorID (Number): header editor window ID
    n (str): header editor name
    f (str): Optional; folder
    Copy_pictures (bool): Optional; True to copy the pictures if needed, False else
 
Returns:
    bool: operation exit status
headerEditorSetBackgroundColor(*args, **kwargs)
headerEditorSetBackgroundColor(headerEditorID: Number, r: Number, g: Number, b: Number) -> bool
 
Change the background color of the header editor
 
Args:
    headerEditorID (Number): header editor window ID
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
headerEditorSetBoxAreaFill(*args, **kwargs)
headerEditorSetBoxAreaFill(headerEditorID: Number, objectID: Number, filled: bool) -> bool
 
Set if the box is transparent
 
Args:
    headerEditorID (Number): header editor window ID
    objectID (Number): header object ID of the box
    filled (bool): 1 = yes; 0 = no
 
Returns:
    bool: operation exit status
headerEditorSetBoxAreaFillColor(*args, **kwargs)
headerEditorSetBoxAreaFillColor(headerEditorID: Number, objectID: Number, r: Number, g: Number, b: Number) -> bool
 
Change the text field background color
 
Args:
    headerEditorID (Number): header editor window ID
    objectID (Number): header object ID of the box
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
headerEditorSetCurrentHeader(*args, **kwargs)
headerEditorSetCurrentHeader(headerEditorID: Number, headerID: Number) -> bool
 
Change the header used for modifications by other header editor functions
 
Args:
    headerEditorID (Number): header editor window ID
    headerID (Number): header ID (first header ID is 0, and so on...)
 
Returns:
    bool: operation exit status
headerEditorSetGridVisibility(*args, **kwargs)
headerEditorSetGridVisibility(headerEditorID: Number, visible: bool) -> bool
 
Change the grid visibility
 
Args:
    headerEditorID (Number): header editor window ID
    visible (bool): 1 = show; 0 = hide
 
Returns:
    bool: operation exit status
headerEditorSetHeight(*args, **kwargs)
headerEditorSetHeight(headerEditorID: Number, height: Number) -> bool
 
Set the height of the header editor
 
Args:
    headerEditorID (Number): header editor window ID
    height (Number): new height in the current header editor unit
 
Returns:
    bool: operation exit status
headerEditorSetHorizontalRulerVisibility(*args, **kwargs)
headerEditorSetHorizontalRulerVisibility(headerEditorID: Number, visible: bool) -> bool
 
Change the horizontal ruler visibility
 
Args:
    headerEditorID (Number): header editor window ID
    visible (bool): 1 = show; 0 = hide
 
Returns:
    bool: operation exit status
headerEditorSetImageKeepProportions(*args, **kwargs)
headerEditorSetImageKeepProportions(headerEditorID: Number, objectID: Number, keep: bool) -> bool
 
Set if the image has to keep its original proportions
 
Args:
    headerEditorID (Number): header editor window ID
    objectID (Number): header object ID of the image
    keep (bool): 1 = yes; 0 = no
 
Returns:
    bool: operation exit status
headerEditorSetImageOpacity(*args, **kwargs)
headerEditorSetImageOpacity(headerEditorID: Number, objectID: Number, opacity: Number) -> bool
 
Set the opacity of an image
 
Args:
    headerEditorID (Number): header editor window ID
    objectID (Number): header object ID of the image
    opacity (Number): between 0 (fully transparent) and 1 (fully opaque)
 
Returns:
    bool: operation exit status
headerEditorSetImageOriginalSize(*args, **kwargs)
headerEditorSetImageOriginalSize(headerEditorID: Number, objectID: Number, keep: bool) -> bool
 
Set if the image has to keep its original size
 
Args:
    headerEditorID (Number): header editor window ID
    objectID (Number): header object ID of the image
    keep (bool): 1 = yes; 0 = no
 
Returns:
    bool: operation exit status
headerEditorSetImageRotation(*args, **kwargs)
headerEditorSetImageRotation(headerEditorID: Number, objectID: Number, rotation: Number) -> bool
 
Set the orientation of an image
 
Args:
    headerEditorID (Number): header editor window ID
    objectID (Number): header object ID of the image
    rotation (Number): rotation in  (0, 90, 180 or 270)
 
Returns:
    bool: operation exit status
headerEditorSetObjectAlignment(*args, **kwargs)
headerEditorSetObjectAlignment(headerEditorID: Number, objectID: Number, position: Number) -> bool
 
Change the header object alignment
 
Args:
    headerEditorID (Number): header editor window ID
    objectID (Number): header object ID
    position (Number): 0 = left; 1 = center; 2 = right
 
Returns:
    bool: operation exit status
headerEditorSetObjectBorderColor(*args, **kwargs)
headerEditorSetObjectBorderColor(headerEditorID: Number, objectID: Number, r: Number, g: Number, b: Number) -> bool
 
Change the header object border color
 
Args:
    headerEditorID (Number): header editor window ID
    objectID (Number): header object ID
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
headerEditorSetObjectBorderWidth(*args, **kwargs)
headerEditorSetObjectBorderWidth(headerEditorID: Number, objectID: Number, width: Number) -> bool
 
Change the header object border width
 
Args:
    headerEditorID (Number): header editor window ID
    objectID (Number): header object ID
    width (Number): width of the border
 
Returns:
    bool: operation exit status
headerEditorSetObjectPosition(*args, **kwargs)
headerEditorSetObjectPosition(headerEditorID: Number, objectID: Number, x: Number, y: Number) -> bool
 
Change the header object position
 
Args:
    headerEditorID (Number): header editor window ID
    objectID (Number): header object ID
    x (Number): horizontal position
    y (Number): vertical position
 
Returns:
    bool: operation exit status
headerEditorSetObjectSize(*args, **kwargs)
headerEditorSetObjectSize(headerEditorID: Number, objectID: Number, w: Number, h: Number) -> bool
 
Change the header object size
 
Args:
    headerEditorID (Number): header editor window ID
    objectID (Number): header object ID
    w (Number): horizontal size
    h (Number): vertical size
 
Returns:
    bool: operation exit status
headerEditorSetText(*args, **kwargs)
headerEditorSetText(headerEditorID: Number, objectID: Number, text: str) -> bool
 
Set the text of a text field
 
Args:
    headerEditorID (Number): header editor window ID
    objectID (Number): header object ID of the text field
    text (str): text to set
 
Returns:
    bool: operation exit status
headerEditorSetTextAllWidthAvailable(*args, **kwargs)
headerEditorSetTextAllWidthAvailable(headerEditorID: Number, objectID: Number, all: bool) -> bool
 
Set if the text has to use all the width available
 
Args:
    headerEditorID (Number): header editor window ID
    objectID (Number): header object ID of the text field
    all (bool): 1 = yes; 0 = no
 
Returns:
    bool: operation exit status
headerEditorSetTextAreaFill(*args, **kwargs)
headerEditorSetTextAreaFill(headerEditorID: Number, objectID: Number, filled: bool) -> bool
 
Set if the text field is transparent
 
Args:
    headerEditorID (Number): header editor window ID
    objectID (Number): header object ID of the text field
    filled (bool): 1 = yes; 0 = no
 
Returns:
    bool: operation exit status
headerEditorSetTextAreaFillColor(*args, **kwargs)
headerEditorSetTextAreaFillColor(headerEditorID: Number, objectID: Number, r: Number, g: Number, b: Number) -> bool
 
Change the text field background color
 
Args:
    headerEditorID (Number): header editor window ID
    objectID (Number): header object ID of the text field
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
headerEditorSetTextOrientation(*args, **kwargs)
headerEditorSetTextOrientation(headerEditorID: Number, objectID: Number, orientation: Number) -> bool
 
Set the orientation of a text field
 
Args:
    headerEditorID (Number): header editor window ID
    objectID (Number): header object ID of the text field
    orientation (Number): orientation in  (0, 90, 180 or 270)
 
Returns:
    bool: operation exit status
headerEditorSetUnit(*args, **kwargs)
headerEditorSetUnit(headerEditorID: Number, unit: str) -> bool
 
Set the unit of the header editor
 
Args:
    headerEditorID (Number): header editor window ID
    unit (str): new unit
 
Returns:
    bool: operation exit status
headerEditorSetVerticalRulerVisibility(*args, **kwargs)
headerEditorSetVerticalRulerVisibility(headerEditorID: Number, visible: bool) -> bool
 
Change the vertical ruler visibility
 
Args:
    headerEditorID (Number): header editor window ID
    visible (bool): 1 = show; 0 = hide
 
Returns:
    bool: operation exit status
headerEditorTableAddColumn(*args, **kwargs)
headerEditorTableAddColumn(headerEditorID: Number, objectID: Number) -> bool
 
Add a column to the table
 
Args:
    headerEditorID (Number): header editor window ID
    objectID (Number): header object ID of the table
 
Returns:
    bool: operation exit status
headerEditorTableAddRow(*args, **kwargs)
headerEditorTableAddRow(headerEditorID: Number, objectID: Number) -> bool
 
Add a row to the table
 
Args:
    headerEditorID (Number): header editor window ID
    objectID (Number): header object ID of the table
 
Returns:
    bool: operation exit status
headerEditorTableDeleteColumn(*args, **kwargs)
headerEditorTableDeleteColumn(headerEditorID: Number, objectID: Number, column_index: Number) -> bool
 
Delete a column of the table
 
Args:
    headerEditorID (Number): header editor window ID
    objectID (Number): header object ID of the table
    column_index (Number): index of the column (from 0) to remove
 
Returns:
    bool: operation exit status
headerEditorTableDeleteRow(*args, **kwargs)
headerEditorTableDeleteRow(headerEditorID: Number, objectID: Number, row_index: Number) -> bool
 
Delete a row of the table
 
Args:
    headerEditorID (Number): header editor window ID
    objectID (Number): header object ID of the table
    row_index (Number): index of the row (from 0) to remove
 
Returns:
    bool: operation exit status
headerEditorTableInsertColumn(*args, **kwargs)
headerEditorTableInsertColumn(headerEditorID: Number, objectID: Number, column_index: Number) -> bool
 
Insert a column in the table
 
Args:
    headerEditorID (Number): header editor window ID
    objectID (Number): header object ID of the table
    column_index (Number): index of the column (from 0) where the new one has to be inserted
 
Returns:
    bool: operation exit status
headerEditorTableInsertRow(*args, **kwargs)
headerEditorTableInsertRow(headerEditorID: Number, objectID: Number, row_index: Number) -> bool
 
Insert a row in the table
 
Args:
    headerEditorID (Number): header editor window ID
    objectID (Number): header object ID of the table
    row_index (Number): index of the row (from 0) where the new one has to be inserted
 
Returns:
    bool: operation exit status
histogramAddParameterLineX(*args, **kwargs)
histogramAddParameterLineX(plotID: Number, well: str, dataset: str, zonation: str, zone: str, pn1: str, val1: Number, min1: Number, max1: Number, cminx: Number=MissingValue, cmaxx: Number=MissingValue, cminy: Number=MissingValue, cmaxy: Number=MissingValue, update: bool=True) -> Number
 
Add a parameter line to the histogram
 
Args:
    plotID (Number): histogram window ID
    well (str): well name
    dataset (str): dataset name
    zonation (str): zonation dataset name
    zone (str): zone name
    pn1 (str): name of X parameter
    val1 (Number): value of X parameter
    min1 (Number): minimum of X parameter
    max1 (Number): maximum of X parameter
    cminx (Number): Optional; x min of constraint
    cmaxx (Number): Optional; x max of constraint
    cminy (Number): Optional; y min of constraint
    cmaxy (Number): Optional; y max of constraint
    update (bool): Optional; True if overwrite, false else
 
Returns:
    Number: parameter point id
histogramAddParameterPointXY(*args, **kwargs)
histogramAddParameterPointXY(plotID: Number, well: str, dataset: str, zonation: str, zone: str, pn1: str, val1: Number, min1: Number, max1: Number, pn2: str, val2: Number, min2: Number, max2: Number, cminx: Number=MissingValue, cmaxx: Number=MissingValue, cminy: Number=MissingValue, cmaxy: Number=MissingValue, update: bool=True) -> str
 
Add a parameter point to the histogram
 
Args:
    plotID (Number): histogram window ID
    well (str): well name
    dataset (str): dataset name
    zonation (str): zonation dataset name
    zone (str): zone name
    pn1 (str): name of first parameter
    val1 (Number): value of first parameter
    min1 (Number): minimum of first parameter
    max1 (Number): maximum of first parameter
    pn2 (str): name of second parameter
    val2 (Number): value of second parameter
    min2 (Number): minimum of second parameter
    max2 (Number): maximum of second parameter
    cminx (Number): Optional; x min of constraint
    cmaxx (Number): Optional; x max of constraint
    cminy (Number): Optional; y min of constraint
    cmaxy (Number): Optional; y max of constraint
    update (bool): Optional; True if overwrite, false else
 
Returns:
    str: parameter point id's
histogramAddZone(*args, **kwargs)
histogramAddZone(plotID: Number, z: str) -> bool
 
Add a zone in the selection to the histogram
 
Args:
    plotID (Number): histogram window ID
    z (str): zone name
 
Returns:
    bool: operation exit status
histogramApplyTo(*args, **kwargs)
histogramApplyTo(plotID: Number, ds: list) -> list
 
Apply the histogram to a data set list
 
Args:
    plotID (Number): histogram window ID
    ds (list): dataset ID (wellName.datasetName)
 
Returns:
    list: list of plotID
histogramCleanZonation(*args, **kwargs)
histogramCleanZonation(plotID: Number, d: str) -> bool
 
Remove the zonation dataset from the histogram - any display of zone must previously have been cancelled
 
Args:
    plotID (Number): histogram window ID
    d (str): zonation dataset name
 
Returns:
    bool: operation exit status
histogramCleanZone(*args, **kwargs)
histogramCleanZone(plotID: Number, z: str) -> bool
 
Remove a zone in the selection from the histogram
 
Args:
    plotID (Number): histogram window ID
    z (str): zone name
 
Returns:
    bool: operation exit status
histogramCreate(*args, **kwargs)
histogramCreate(n: str, vl: list=None, f: str='') -> Number
 
Create a new histogram
 
Args:
    n (str): histogram window name
    vl (list): Optional; variable list name
    f (str): Optional; filter variable name
 
Returns:
    Number: histogram window ID
histogramDeleteFilterValues(*args, **kwargs)
histogramDeleteFilterValues(plotID: Number) -> bool
 
Delete the filter variable of a histogram
 
Args:
    plotID (Number): histogram window ID
 
Returns:
    bool: operation exit status
histogramDeleteVariables(*args, **kwargs)
histogramDeleteVariables(plotID: Number, vn: list) -> bool
 
Delete the variable list of the histogram
 
Args:
    plotID (Number): histogram window ID
    vn (list): variable list
 
Returns:
    bool: operation exit status
histogramDuplicate(*args, **kwargs)
histogramDuplicate(plotID: Number) -> Number
 
Duplicate the histogram
 
Args:
    plotID (Number): histogram window ID
 
Returns:
    Number: new plot id or -1
histogramGetIdByName(*args, **kwargs)
histogramGetIdByName(n: str) -> Number
 
Returns the ID of a name-known histogram
 
Args:
    n (str): histogram name
 
Returns:
    Number: histogram window ID
histogramGetParameterPointXValue(*args, **kwargs)
histogramGetParameterPointXValue(plotID: Number, ppid1: str) -> Number
 
Return X value of a parameter point in the histogram
 
Args:
    plotID (Number): histogram window ID
    ppid1 (str): parameter point id
 
Returns:
    Number: x value of parameter point
histogramGetParameterPointYValue(*args, **kwargs)
histogramGetParameterPointYValue(plotID: Number, ppid1: str) -> Number
 
Return Y value of a parameter point in the histogram
 
Args:
    plotID (Number): histogram window ID
    ppid1 (str): parameter point id
 
Returns:
    Number: y value of parameter point
histogramLockAxisX(*args, **kwargs)
histogramLockAxisX(plotID: Number, locked: bool) -> bool
 
Lock x-axis limits of the histogram
 
Args:
    plotID (Number): histogram window ID
    locked (bool): True if locked, False else
 
Returns:
    bool: operation exit status
histogramLockLegendX(*args, **kwargs)
histogramLockLegendX(plotID: Number, locked: bool) -> bool
 
Lock x-axis legend of the histogram
 
Args:
    plotID (Number): histogram window ID
    locked (bool): True if locked, False else
 
Returns:
    bool: operation exit status
histogramLockLegendY(*args, **kwargs)
histogramLockLegendY(plotID: Number, locked: bool) -> bool
 
Lock y-axis legend of the histogram
 
Args:
    plotID (Number): histogram window ID
    locked (bool): True if locked, False else
 
Returns:
    bool: operation exit status
histogramLockTitle(*args, **kwargs)
histogramLockTitle(plotID: Number, locked: bool) -> bool
 
Lock title of the histogram
 
Args:
    plotID (Number): histogram window ID
    locked (bool): True if locked, False else
 
Returns:
    bool: operation exit status
histogramMultiWellAddData(*args, **kwargs)
histogramMultiWellAddData(plotID: Number, ds: list) -> bool
 
Add a dataset to a multi well histogram
 
Args:
    plotID (Number): histogram window ID
    ds (list): dataset ID (wellName.datasetName)
 
Returns:
    bool: operation exit status
histogramMultiWellAddParameterLineX(*args, **kwargs)
histogramMultiWellAddParameterLineX(plotID: Number, well: str, dataset: str, zonation: str, zone: str, pn1: str, val1: Number, min1: Number, max1: Number, cminx: Number=MissingValue, cmaxx: Number=MissingValue, cminy: Number=MissingValue, cmaxy: Number=MissingValue, update: bool=True) -> Number
 
Add a parameter line to the histogram
 
Args:
    plotID (Number): histogram window ID
    well (str): well name
    dataset (str): dataset name
    zonation (str): zonation dataset name
    zone (str): zone name
    pn1 (str): name of  Xparameter
    val1 (Number): value of X parameter
    min1 (Number): minimum of X parameter
    max1 (Number): maximum of X parameter
    cminx (Number): Optional; x min of constraint
    cmaxx (Number): Optional; x max of constraint
    cminy (Number): Optional; y min of constraint
    cmaxy (Number): Optional; y max of constraint
    update (bool): Optional; True if overwrite, false else
 
Returns:
    Number: parameter point id
histogramMultiWellAddParameterPointXY(*args, **kwargs)
histogramMultiWellAddParameterPointXY(plotID: Number, well: str, dataset: str, zonation: str, zone: str, pn1: str, val1: Number, min1: Number, max1: Number, pn2: str, val2: Number, min2: Number, max2: Number, cminx: Number=MissingValue, cmaxx: Number=MissingValue, cminy: Number=MissingValue, cmaxy: Number=MissingValue, update: bool=True) -> str
 
Add a parameter point to the histogram
 
Args:
    plotID (Number): histogram window ID
    well (str): well name
    dataset (str): dataset name
    zonation (str): zonation dataset name
    zone (str): zone name
    pn1 (str): name of first parameter
    val1 (Number): value of first parameter
    min1 (Number): minimum of first parameter
    max1 (Number): maximum of first parameter
    pn2 (str): name of second parameter
    val2 (Number): value of second parameter
    min2 (Number): minimum of second parameter
    max2 (Number): maximum of second parameter
    cminx (Number): Optional; x min of constraint
    cmaxx (Number): Optional; x max of constraint
    cminy (Number): Optional; y min of constraint
    cmaxy (Number): Optional; y max of constraint
    update (bool): Optional; True if overwrite, false else
 
Returns:
    str: parameter point id's
histogramMultiWellAddZone(*args, **kwargs)
histogramMultiWellAddZone(plotID: Number, z: str) -> bool
 
Add a zone in the selection to the histogram
 
Args:
    plotID (Number): histogram window ID
    z (str): zone name
 
Returns:
    bool: operation exit status
histogramMultiWellCleanZonation(*args, **kwargs)
histogramMultiWellCleanZonation(plotID: Number, d: str) -> bool
 
Remove the zonation dataset from the histogram - any display of zone must previously have been cancelled
 
Args:
    plotID (Number): histogram window ID
    d (str): zonation dataset name
 
Returns:
    bool: operation exit status
histogramMultiWellCleanZone(*args, **kwargs)
histogramMultiWellCleanZone(plotID: Number, z: str) -> bool
 
Remove a zone in the selection from the histogram
 
Args:
    plotID (Number): histogram window ID
    z (str): zone name
 
Returns:
    bool: operation exit status
histogramMultiWellCreate(*args, **kwargs)
histogramMultiWellCreate(ml: list) -> Number
 
Create a multi well histogram
 
Args:
    ml (list): mnemonic list
 
Returns:
    Number: histogram window ID
histogramMultiWellDuplicate(*args, **kwargs)
histogramMultiWellDuplicate(plotID: Number) -> Number
 
Duplicate the histogram
 
Args:
    plotID (Number): histogram window ID
 
Returns:
    Number: new plot id or -1
histogramMultiWellGetIdByName(*args, **kwargs)
histogramMultiWellGetIdByName(n: str) -> Number
 
Returns the ID of a name-known histogram
 
Args:
    n (str): histogram name
 
Returns:
    Number: histogram window ID
histogramMultiWellGetParameterPointXValue(*args, **kwargs)
histogramMultiWellGetParameterPointXValue(plotID: Number, ppid1: str) -> Number
 
Return X value of a parameter point in the histogram
 
Args:
    plotID (Number): histogram window ID
    ppid1 (str): parameter point id
 
Returns:
    Number: x value of parameter point
histogramMultiWellGetParameterPointYValue(*args, **kwargs)
histogramMultiWellGetParameterPointYValue(plotID: Number, ppid1: str) -> Number
 
Return Y value of a parameter point in the histogram
 
Args:
    plotID (Number): histogram window ID
    ppid1 (str): parameter point id
 
Returns:
    Number: y value of parameter point
histogramMultiWellOpen(*args, **kwargs)
histogramMultiWellOpen(n: str, f: str='') -> Number
 
Open an existing histogram
 
Args:
    n (str): histogram wname
    f (str): Optional; folder
 
Returns:
    Number: histogram window ID
histogramMultiWellQuantile1Value(*args, **kwargs)
histogramMultiWellQuantile1Value(plotID: Number, q1: Number) -> bool
 
Set user value for quantile 1
 
Args:
    plotID (Number): histogram window ID
    q1 (Number): quantile 1 percentage
 
Returns:
    bool: operation exit status
histogramMultiWellQuantile2Value(*args, **kwargs)
histogramMultiWellQuantile2Value(plotID: Number, q2: Number) -> bool
 
Set user value for quantile 2
 
Args:
    plotID (Number): histogram window ID
    q2 (Number): quantile 2 percentage
 
Returns:
    bool: operation exit status
histogramMultiWellQuantile3Value(*args, **kwargs)
histogramMultiWellQuantile3Value(plotID: Number, q3: Number) -> bool
 
Set user value for quantile 3
 
Args:
    plotID (Number): histogram window ID
    q3 (Number): quantile 3 percentage
 
Returns:
    bool: operation exit status
histogramMultiWellQuantile4Value(*args, **kwargs)
histogramMultiWellQuantile4Value(plotID: Number, q4: Number) -> bool
 
Set user value for quantile 4
 
Args:
    plotID (Number): histogram window ID
    q4 (Number): quantile 4 percentage
 
Returns:
    bool: operation exit status
histogramMultiWellQuantile5Value(*args, **kwargs)
histogramMultiWellQuantile5Value(plotID: Number, q5: Number) -> bool
 
Set user value for quantile 5
 
Args:
    plotID (Number): histogram window ID
    q5 (Number): quantile 5 percentage
 
Returns:
    bool: operation exit status
histogramMultiWellQuantileDisplay(*args, **kwargs)
histogramMultiWellQuantileDisplay(plotID: Number, quant: bool, line: bool=False) -> bool
 
Display of the quantiles (10, 25, 50, 75 and 90) on the current histogram
 
Args:
    plotID (Number): histogram window ID
    quant (bool): 1 = quantiles display else 0
    line (bool): Optional; = 1 if display quantiles by lines
 
Returns:
    bool: operation exit status
histogramMultiWellQuantileValues(*args, **kwargs)
histogramMultiWellQuantileValues(plotID: Number, q1: Number, q2: Number, q3: Number, q4: Number, q5: Number) -> bool
 
Set user values to the histogram quantiles
 
Args:
    plotID (Number): histogram window ID
    q1 (Number): quantile 1 percentage
    q2 (Number): quantile 2 percentage
    q3 (Number): quantile 3 percentage
    q4 (Number): quantile 4 percentage
    q5 (Number): quantile 5 percentage
 
Returns:
    bool: operation exit status
histogramMultiWellRemoveAllParameterPoint(*args, **kwargs)
histogramMultiWellRemoveAllParameterPoint(plotID: Number) -> bool
 
Remove all parameter point in the histogram
 
Args:
    plotID (Number): histogram window ID
 
Returns:
    bool: operation exit status
histogramMultiWellRemoveDataset(*args, **kwargs)
histogramMultiWellRemoveDataset(plotID: Number, ds: str) -> bool
 
Remove a dataset from a multi well histogram
 
Args:
    plotID (Number): histogram window ID
    ds (str): dataset name
 
Returns:
    bool: operation exit status
histogramMultiWellRemoveParameterLineX(*args, **kwargs)
histogramMultiWellRemoveParameterLineX(plotID: Number, ppid1: str) -> bool
 
Remove a parameter line X in the histogram
 
Args:
    plotID (Number): histogram window ID
    ppid1 (str): parameter point id
 
Returns:
    bool: operation exit status
histogramMultiWellRemoveParameterPoint(*args, **kwargs)
histogramMultiWellRemoveParameterPoint(plotID: Number, ppid1: str) -> bool
 
Remove a parameter point in the histogram
 
Args:
    plotID (Number): histogram window ID
    ppid1 (str): parameter point id
 
Returns:
    bool: operation exit status
histogramMultiWellRemoveWell(*args, **kwargs)
histogramMultiWellRemoveWell(plotID: Number, we: str) -> bool
 
Remove a well from a multi well histogram
 
Args:
    plotID (Number): histogram window ID
    we (str): well name
 
Returns:
    bool: operation exit status
histogramMultiWellSave(*args, **kwargs)
histogramMultiWellSave(plotID: Number, n: str, f: str='') -> bool
 
Save the histogram
 
Args:
    plotID (Number): histogram window ID
    n (str): histogram window name
    f (str): Optional; folder
 
Returns:
    bool: operation exit status
histogramMultiWellSelectVar(*args, **kwargs)
histogramMultiWellSelectVar(plotID: Number, we: str, ds: str, famId: Number, vr: str) -> bool
 
[DEPRECATED] (use histogramMultiWellSelectVariable instead) Change the variable selected among one family's variables in a multi well histogram
 
Args:
    plotID (Number): histogram window ID
    we (str): well name
    ds (str): dataset name
    famId (Number): ID of the family in which you wish to change variable
    vr (str): new variable name
 
Returns:
    bool: operation exit status
histogramMultiWellSelectVariable(*args, **kwargs)
histogramMultiWellSelectVariable(plotID: Number, we: str, ds: str, famId: Number, vr: str) -> bool
 
Change the variable selected among one family's variables in a multi well histogram
 
Args:
    plotID (Number): histogram window ID
    we (str): well name
    ds (str): dataset name
    famId (Number): ID of the family in which you wish to change variable
    vr (str): new variable name
 
Returns:
    bool: operation exit status
histogramMultiWellSetCumul(*args, **kwargs)
histogramMultiWellSetCumul(plotID: Number, cf: bool) -> bool
 
Display of cumulative frequencies on the histogram
 
Args:
    plotID (Number): histogram window ID
    cf (bool): {0 = 'remove cumulative frequencies', 1 = 'display of cumulative frequencies'}
 
Returns:
    bool: operation exit status
histogramMultiWellSetCumulate(*args, **kwargs)
histogramMultiWellSetCumulate(plotID: Number, cum: bool=True) -> bool
 
Cumul of the histogram values
 
Args:
    plotID (Number): histogram window ID
    cum (bool): Optional; 1 = cumulate histo else 0
 
Returns:
    bool: operation exit status
histogramMultiWellSetFill(*args, **kwargs)
histogramMultiWellSetFill(plotID: Number, fill: bool) -> bool
 
Filling of histogram crenels
 
Args:
    plotID (Number): histogram window ID
    fill (bool): {0 = 'remove filling', 1 = 'display filling'}
 
Returns:
    bool: operation exit status
histogramMultiWellSetFillingColor(*args, **kwargs)
histogramMultiWellSetFillingColor(plotID: Number, var: str, r: Number=0, g: Number=0, b: Number=0) -> bool
 
Choose the histogram filling color
 
Args:
    plotID (Number): histogram window ID
    var (str): variable ID
    r (Number): Optional; red
    g (Number): Optional; green
    b (Number): Optional; blue
 
Returns:
    bool: operation exit status
histogramMultiWellSetFillingColour(*args, **kwargs)
histogramMultiWellSetFillingColour(plotID: Number, var: str, r: Number=0, g: Number=0, b: Number=0) -> bool
 
[DEPRECATED] (use histogramMultiWellSetFillingColor instead) Choose the histogram filling color
 
Args:
    plotID (Number): histogram window ID
    var (str): variable ID
    r (Number): Optional; red
    g (Number): Optional; green
    b (Number): Optional; blue
 
Returns:
    bool: operation exit status
histogramMultiWellSetName(*args, **kwargs)
histogramMultiWellSetName(plotID: Number, n: str) -> bool
 
Change the name of the histogram
 
Args:
    plotID (Number): histogram window ID
    n (str): new histogram window name
 
Returns:
    bool: operation exit status
histogramMultiWellSetPrecision(*args, **kwargs)
histogramMultiWellSetPrecision(plotID: Number, bins: Number) -> bool
 
Change number of bins on the histogram
 
Args:
    plotID (Number): histogram window ID
    bins (Number): number of bins
 
Returns:
    bool: operation exit status
histogramMultiWellSetStandardise(*args, **kwargs)
histogramMultiWellSetStandardise(plotID: Number, std: bool) -> bool
 
[DEPRECATED] (use histogramMultiWellSetStandardize instead) Display of number of samples or frequencies on Y axis on the histogram
 
Args:
    plotID (Number): histogram window ID
    std (bool): {0 = 'number of samples', 1 = 'frequencies'}
 
Returns:
    bool: operation exit status
histogramMultiWellSetStandardize(*args, **kwargs)
histogramMultiWellSetStandardize(plotID: Number, std: bool) -> bool
 
Display of number of samples or frequencies on Y axis on the histogram
 
Args:
    plotID (Number): histogram window ID
    std (bool): {0 = 'number of samples', 1 = 'frequencies'}
 
Returns:
    bool: operation exit status
histogramMultiWellSetStyle(*args, **kwargs)
histogramMultiWellSetStyle(plotID: Number, st: int) -> bool
 
Change the style of display of the histogram
 
Args:
    plotID (Number): histogram window ID
    st (int): display style: {0 = 'CRENEL_CLOSE', 1 = 'CRENEL_OPEN', 2 = 'CONTINUOUS_LINE'}
 
Returns:
    bool: operation exit status
histogramMultiWellSetType(*args, **kwargs)
histogramMultiWellSetType(plotID: Number, ty: int) -> bool
 
Change histogram type
 
Args:
    plotID (Number): histogram window ID
    ty (int): histogram type: {0 = 'VARIABLES', 1 = 'FILTER', 2 = 'ZONATION'}
 
Returns:
    bool: operation exit status
histogramMultiWellSetXAxisScale(*args, **kwargs)
histogramMultiWellSetXAxisScale(plotID: Number, xasc: int) -> bool
 
Change the histogram X axis scale
 
Args:
    plotID (Number): histogram window ID
    xasc (int): scale type {0 = 'LINEAR', 1 = 'LOGARITHMIC'}
 
Returns:
    bool: operation exit status
histogramMultiWellSetXAxisType(*args, **kwargs)
histogramMultiWellSetXAxisType(plotID: Number, xat: int) -> bool
 
Change the type of histogram X axis
 
Args:
    plotID (Number): histogram window ID
    xat (int): X axis type {0 = 'VAR', 1 = 'USER', 2 = 'FAMILY'}
 
Returns:
    bool: operation exit status
histogramMultiWellSetXAxisUnit(*args, **kwargs)
histogramMultiWellSetXAxisUnit(plotID: Number, xau: str) -> bool
 
Change the unit of histogram X axis
 
Args:
    plotID (Number): histogram window ID
    xau (str): X axis unit
 
Returns:
    bool: operation exit status
histogramMultiWellSetXAxisUserLimits(*args, **kwargs)
histogramMultiWellSetXAxisUserLimits(plotID: Number, xamin: Number, xamax: Number) -> bool
 
Set min & max values of histogram X axis
 
Args:
    plotID (Number): histogram window ID
    xamin (Number): X axis minimum
    xamax (Number): X axis maximum
 
Returns:
    bool: operation exit status
histogramMultiWellSetYAxisMinMax(*args, **kwargs)
histogramMultiWellSetYAxisMinMax(plotID: Number, ymin: Number, ymax: Number) -> bool
 
Set min & max values of histogram Y axis
 
Args:
    plotID (Number): histogram window ID
    ymin (Number): Y axis minimum
    ymax (Number): Y axis maximum
 
Returns:
    bool: operation exit status
histogramMultiWellSetZonation(*args, **kwargs)
histogramMultiWellSetZonation(plotID: Number, d: str) -> bool
 
Set the zonation dataset to the histogram
 
Args:
    plotID (Number): histogram window ID
    d (str): zonation dataset name
 
Returns:
    bool: operation exit status
histogramOpen(*args, **kwargs)
histogramOpen(n: str, f: str='') -> Number
 
Open an existing histogram
 
Args:
    n (str): histogram name
    f (str): Optional; folder
 
Returns:
    Number: histogram window ID
histogramQuantile1Value(*args, **kwargs)
histogramQuantile1Value(plotID: Number, q1: Number) -> bool
 
Set user value for quantile 1
 
Args:
    plotID (Number): histogram window ID
    q1 (Number): quantile 1 percentage
 
Returns:
    bool: operation exit status
histogramQuantile2Value(*args, **kwargs)
histogramQuantile2Value(plotID: Number, q2: Number) -> bool
 
Set user value for quantile 2
 
Args:
    plotID (Number): histogram window ID
    q2 (Number): quantile 2 percentage
 
Returns:
    bool: operation exit status
histogramQuantile3Value(*args, **kwargs)
histogramQuantile3Value(plotID: Number, q3: Number) -> bool
 
Set user value for quantile 3
 
Args:
    plotID (Number): histogram window ID
    q3 (Number): quantile 3 percentage
 
Returns:
    bool: operation exit status
histogramQuantile4Value(*args, **kwargs)
histogramQuantile4Value(plotID: Number, q4: Number) -> bool
 
Set user value for quantile 4
 
Args:
    plotID (Number): histogram window ID
    q4 (Number): quantile 4 percentage
 
Returns:
    bool: operation exit status
histogramQuantile5Value(*args, **kwargs)
histogramQuantile5Value(plotID: Number, q5: Number) -> bool
 
Set user value for quantile 5
 
Args:
    plotID (Number): histogram window ID
    q5 (Number): quantile 5 percentage
 
Returns:
    bool: operation exit status
histogramQuantileDisplay(*args, **kwargs)
histogramQuantileDisplay(plotID: Number, quant: bool, line: bool=False) -> bool
 
Display of the quantiles (10, 25, 50, 75 and 90) on the current histogram
 
Args:
    plotID (Number): histogram window ID
    quant (bool): 1 = quantiles display else 0
    line (bool): Optional; = 1 if display quantiles by lines
 
Returns:
    bool: operation exit status
histogramQuantileValues(*args, **kwargs)
histogramQuantileValues(plotID: Number, q1: Number, q2: Number, q3: Number, q4: Number, q5: Number) -> bool
 
Set user values to the histogram quantiles
 
Args:
    plotID (Number): histogram window ID
    q1 (Number): quantile 1 percentage
    q2 (Number): quantile 2 percentage
    q3 (Number): quantile 3 percentage
    q4 (Number): quantile 4 percentage
    q5 (Number): quantile 5 percentage
 
Returns:
    bool: operation exit status
histogramRemoveAllParameterPoint(*args, **kwargs)
histogramRemoveAllParameterPoint(plotID: Number) -> bool
 
Remove all parameter point in the histogram
 
Args:
    plotID (Number): histogram window ID
 
Returns:
    bool: operation exit status
histogramRemoveParameterLineX(*args, **kwargs)
histogramRemoveParameterLineX(plotID: Number, ppid1: str) -> bool
 
Remove a parameter line X in the histogram
 
Args:
    plotID (Number): histogram window ID
    ppid1 (str): parameter point id
 
Returns:
    bool: operation exit status
histogramRemoveParameterPoint(*args, **kwargs)
histogramRemoveParameterPoint(plotID: Number, ppid1: str) -> bool
 
Remove a parameter point in the histogram
 
Args:
    plotID (Number): histogram window ID
    ppid1 (str): parameter point id
 
Returns:
    bool: operation exit status
histogramSave(*args, **kwargs)
histogramSave(plotID: Number, n: str, f: str='') -> bool
 
Save the histogram
 
Args:
    plotID (Number): histogram window ID
    n (str): histogram window name
    f (str): Optional; folder
 
Returns:
    bool: operation exit status
histogramSelectFilter(*args, **kwargs)
histogramSelectFilter(plotID: Number, FilterValues: list) -> bool
 
Select the filter values
 
Args:
    plotID (Number): histogram window ID
    FilterValues (list): filter values
 
Returns:
    bool: operation exit status
histogramSetCumul(*args, **kwargs)
histogramSetCumul(plotID: Number, cf: bool) -> bool
 
[DEPRECATED] (use histogramSetCumulative instead) Display of cumulative frequencies on the histogram
 
Args:
    plotID (Number): histogram window ID
    cf (bool): {0 = 'remove cumulative frequencies', 1 = 'display of cumulative frequencies'}
 
Returns:
    bool: operation exit status
histogramSetCumulate(*args, **kwargs)
histogramSetCumulate(plotID: Number, cum: bool=True) -> bool
 
Cumul of the histogram values
 
Args:
    plotID (Number): histogram window ID
    cum (bool): Optional; True = cumulate histo else False
 
Returns:
    bool: operation exit status
histogramSetCumulative(*args, **kwargs)
histogramSetCumulative(plotID: Number, cf: bool) -> bool
 
Display of cumulative frequencies on the histogram
 
Args:
    plotID (Number): histogram window ID
    cf (bool): {0 = 'remove cumulative frequencies', 1 = 'display of cumulative frequencies'}
 
Returns:
    bool: operation exit status
histogramSetDatum(*args, **kwargs)
histogramSetDatum(plotID: Number, lim: bool, ymin: Number=0, ymax: Number=0) -> bool
 
Change the reference limitation on histogram
 
Args:
    plotID (Number): histogram window ID
    lim (bool): 0 for 'whole datum' / 1 for 'user values'
    ymin (Number): Optional; top limitation
    ymax (Number): Optional; bottom limitation
 
Returns:
    bool: operation exit status
histogramSetFill(*args, **kwargs)
histogramSetFill(plotID: Number, fill: bool) -> bool
 
Filling of histogram crenels
 
Args:
    plotID (Number): histogram window ID
    fill (bool): {0 = 'remove filling', 1 = 'display filling'}
 
Returns:
    bool: operation exit status
histogramSetFillingColor(*args, **kwargs)
histogramSetFillingColor(plotID: Number, var: str, r: Number=0, g: Number=0, b: Number=0) -> bool
 
Choose the histogram filling color
 
Args:
    plotID (Number): plot ID
    var (str): variable ID
    r (Number): Optional; red
    g (Number): Optional; green
    b (Number): Optional; blue
 
Returns:
    bool: operation exit status
histogramSetFillingColour(*args, **kwargs)
histogramSetFillingColour(plotID: Number, var: str, r: Number=0, g: Number=0, b: Number=0) -> bool
 
[DEPRECATED] (use histogramSetFillingColor instead) Choose the histogram filling color
 
Args:
    plotID (Number): plot ID
    var (str): variable ID
    r (Number): Optional; red
    g (Number): Optional; green
    b (Number): Optional; blue
 
Returns:
    bool: operation exit status
histogramSetFilter(*args, **kwargs)
histogramSetFilter(plotID: Number, f: str) -> bool
 
Set the variable as a filter
 
Args:
    plotID (Number): histogram window ID
    f (str): variable filter
 
Returns:
    bool: operation exit status
histogramSetName(*args, **kwargs)
histogramSetName(plotID: Number, n: str) -> bool
 
Change the name of the histogram
 
Args:
    plotID (Number): histogram window ID
    n (str): new histogram window name
 
Returns:
    bool: operation exit status
histogramSetPrecision(*args, **kwargs)
histogramSetPrecision(plotID: Number, bins: Number) -> bool
 
Change number of bins on the histogram
 
Args:
    plotID (Number): histogram window ID
    bins (Number): number of bins
 
Returns:
    bool: operation exit status
histogramSetStandardise(*args, **kwargs)
histogramSetStandardise(plotID: Number, std: bool) -> bool
 
[DEPRECATED] (use histogramSetStandardize instead) Display of number of samples or frequencies on Y axis on the histogram
 
Args:
    plotID (Number): histogram window ID
    std (bool): {0 = 'number of samples', 1 = 'frequencies'}
 
Returns:
    bool: operation exit status
histogramSetStandardize(*args, **kwargs)
histogramSetStandardize(plotID: Number, std: bool) -> bool
 
Display of number of samples or frequencies on Y axis on the histogram
 
Args:
    plotID (Number): histogram window ID
    std (bool): {0 = 'number of samples', 1 = 'frequencies'}
 
Returns:
    bool: operation exit status
histogramSetStyle(*args, **kwargs)
histogramSetStyle(plotID: Number, st: int) -> bool
 
Change the style of display of the histogram
 
Args:
    plotID (Number): histogram window ID
    st (int): display style: {0 = 'CRENEL_CLOSE', 1 = 'CRENEL_OPEN', 2 = 'CONTINUOUS_LINE'}
 
Returns:
    bool: operation exit status
histogramSetType(*args, **kwargs)
histogramSetType(plotID: Number, ty: int) -> bool
 
Change histogram type
 
Args:
    plotID (Number): histogram window ID
    ty (int): histogram type: {0 = 'VARIABLES', 1 = 'FILTER', 2 = 'ZONATION'}
 
Returns:
    bool: operation exit status
histogramSetVariablesList(*args, **kwargs)
histogramSetVariablesList(plotID: Number, vn: list) -> bool
 
Set the variable list to the histogram
 
Args:
    plotID (Number): histogram window ID
    vn (list): variable list
 
Returns:
    bool: operation exit status
histogramSetVariablesValues(*args, **kwargs)
histogramSetVariablesValues(plotID: Number, vn: str, vl: list, fam: str='', un: str='') -> bool
 
Set a fictive set of user variables to the X axis of a histogram
 
Args:
    plotID (Number): histogram window ID
    vn (str): variable name
    vl (list): list of values
    fam (str): Optional; variable family
    un (str): Optional; variable unit
 
Returns:
    bool: operation exit status
histogramSetXAxisScale(*args, **kwargs)
histogramSetXAxisScale(plotID: Number, xasc: int) -> bool
 
Change the histogram X axis scale
 
Args:
    plotID (Number): histogram window ID
    xasc (int): scale type {0 = 'LINEAR', 1 = 'LOGARITHMIC'}
 
Returns:
    bool: operation exit status
histogramSetXAxisType(*args, **kwargs)
histogramSetXAxisType(plotID: Number, xat: int) -> bool
 
Change the type of histogram X axis
 
Args:
    plotID (Number): histogram window ID
    xat (int): X axis type {0 = 'VAR', 1 = 'USER', 2 = 'FAMILY'}
 
Returns:
    bool: operation exit status
histogramSetXAxisUnit(*args, **kwargs)
histogramSetXAxisUnit(plotID: Number, xau: str) -> bool
 
Change the unit of histogram X axis
 
Args:
    plotID (Number): histogram window ID
    xau (str): X axis unit
 
Returns:
    bool: operation exit status
histogramSetXAxisUserLimits(*args, **kwargs)
histogramSetXAxisUserLimits(plotID: Number, xamin: Number, xamax: Number) -> bool
 
Set min & max values of histogram X axis
 
Args:
    plotID (Number): histogram window ID
    xamin (Number): X axis minimum
    xamax (Number): X axis maximum
 
Returns:
    bool: operation exit status
histogramSetYAxisMinMax(*args, **kwargs)
histogramSetYAxisMinMax(plotID: Number, ymin: Number, ymax: Number) -> bool
 
Set min & max values of histogram Y axis
 
Args:
    plotID (Number): histogram window ID
    ymin (Number): Y axis minimum
    ymax (Number): Y axis maximum
 
Returns:
    bool: operation exit status
histogramSetZonation(*args, **kwargs)
histogramSetZonation(plotID: Number, d: str) -> bool
 
Set the zonation dataset to the histogram
 
Args:
    plotID (Number): histogram window ID
    d (str): zonation dataset name
 
Returns:
    bool: operation exit status
histogramVAOpen(*args, **kwargs)
histogramVAOpen(n: str, f: str='') -> Number
 
Open an existing histogram VA
 
Args:
    n (str): histogram name
    f (str): Optional; folder
 
Returns:
    Number: histogram window ID
logViewAddAnnotationsByTrack(*args, **kwargs)
logViewAddAnnotationsByTrack(plotID: Number, pos: Number, size: Number, listText: list, listTop: list, listBottom: list, listFamilyFont: list='Verdana', listSize: list=12, listBold: list=None, listItalic: list=None, listUnderline: list=None) -> bool
 
Add annotation to track in the logview
 
Args:
    plotID (Number): logview window ID
    pos (Number): track position
    size (Number): size of list for annotations
    listText (list): text list for annotations
    listTop (list): top list for annotations
    listBottom (list): bottom list for annotation
    listFamilyFont (list): Optional; family font list for annotations
    listSize (list): Optional; font size list for annotations
    listBold (list): Optional; bold state list for annotations fonts
    listItalic (list): Optional; italic state list for annotations fonts
    listUnderline (list): Optional; underline state list for annotations fonts
 
Returns:
    bool: operation exit status
logViewAddAnnotationsByTrackWithSameFont(*args, **kwargs)
logViewAddAnnotationsByTrackWithSameFont(plotID: Number, pos: Number, size: Number, listText: list, listTop: list, listBottom: list, FamilyFont: str, Size: Number, Bold: bool=False, Italic: bool=False, Underline: bool=False) -> bool
 
Add annotation to track in the logview
 
Args:
    plotID (Number): logview window ID
    pos (Number): track position
    size (Number): size of list for annotations
    listText (list): text list for annotations
    listTop (list): top list for annotations
    listBottom (list): bottom list for annotation
    FamilyFont (str): family font for annotations fonts
    Size (Number): font size for annotations fonts
    Bold (bool): Optional; bold state for annotations fonts
    Italic (bool): Optional; italic state for annotations fonts
    Underline (bool): Optional; underline state for annotations fonts
 
Returns:
    bool: operation exit status
logViewAddAnnotationsByWell(*args, **kwargs)
logViewAddAnnotationsByWell(plotID: Number, w: str, groupName: str, pos: Number, size: Number, listText: list, listTop: list, listBottom: list, listBackgroundColour: list=None, listBorderColour: list=None, listHorizontalTextAlignment: list='CENTER', listVerticalTextAlignment: list='TOP', listTextOrientation: list='HORIZONTAL', listFamilyFont: list='Verdana', listSize: list=12, listBold: list=None, listItalic: list=None, listUnderline: list=None) -> bool
 
Add annotation to track in the logview
 
Args:
    plotID (Number): logview window ID
    w (str): well name
    groupName (str): name of the annotations group
    pos (Number): track position
    size (Number): size of list for annotations
    listText (list): text list for annotations
    listTop (list): top list for annotations
    listBottom (list): bottom list for annotation
    listBackgroundColour (list): Optional; background color (hexadecimal code) list for annotations
    listBorderColour (list): Optional; border color (hexadecimal code) list for annotations
    listHorizontalTextAlignment (list): Optional; list of string enum for the horizontal alignment of each annotation, {'LEFT', 'CENTER', 'RIGHT'}
    listVerticalTextAlignment (list): Optional; list of string enum for the vertical alignment of each annotation, {'TOP', 'CENTER', 'BOTTOM'}
    listTextOrientation (list): Optional; list of string enum for the orientation of each annotation, {'HORIZONTAL', 'VERTICAL'}
    listFamilyFont (list): Optional; family font list for annotations fonts
    listSize (list): Optional; font size list for annotations fonts
    listBold (list): Optional; bold state list for annotations fonts
    listItalic (list): Optional; italic state list for annotations fonts
    listUnderline (list): Optional; underline state list for annotations fonts
 
Returns:
    bool: operation exit status
logViewAddAnnotationsByWellWithSameFont(*args, **kwargs)
logViewAddAnnotationsByWellWithSameFont(plotID: Number, w: str, pos: Number, size: Number, listText: list, listTop: list, listBottom: list, FamilyFont: str, Size: Number, Bold: bool=False, Italic: bool=False, Underline: bool=False) -> bool
 
Add annotation to track in the logview
 
Args:
    plotID (Number): logview window ID
    w (str): well name
    pos (Number): track position
    size (Number): size of list for annotations
    listText (list): text list for annotations
    listTop (list): top list for annotations
    listBottom (list): bottom list for annotation
    FamilyFont (str): family font for annotations fonts
    Size (Number): font size for annotations fonts
    Bold (bool): Optional; bold state for annotations fonts
    Italic (bool): Optional; italic state for annotations fonts
    Underline (bool): Optional; underline state for annotations fonts
 
Returns:
    bool: operation exit status
logViewAddFooters(*args, **kwargs)
logViewAddFooters(plotID: Number, footers: Union[str, list]) -> bool
 
Add footers to the layout
 
Args:
    plotID (Number): logview window ID
    footers (Union[str, list]): footer(s) name (Folder.FooterName)
 
Returns:
    bool: operation exit status
logViewAddHeaders(*args, **kwargs)
logViewAddHeaders(plotID: Number, headers: Union[str, list]) -> bool
 
Add headers to the layout
 
Args:
    plotID (Number): logview window ID
    headers (Union[str, list]): header(s) name (Folder.HeaderName)
 
Returns:
    bool: operation exit status
logViewAddMultipleTopHeaderNoteByTrack(*args, **kwargs)
logViewAddMultipleTopHeaderNoteByTrack(plotID: Number, listPos: list, text: str, centered: bool=True) -> bool
 
Add a top header note for multiple tracks in the logview
 
Args:
    plotID (Number): logview window ID
    listPos (list): track position for starting and finishing top header
    text (str): text of the top header note
    centered (bool): Optional; 1 if text is centered, 0 else
 
Returns:
    bool: operation exit status
logViewAddMultipleTrackTopHeaderNoteByWell(*args, **kwargs)
logViewAddMultipleTrackTopHeaderNoteByWell(plotID: Number, w: str, listPos: list, text: str, centered: bool=True) -> bool
 
Add a top header note for multiple tracks in the logview
 
Args:
    plotID (Number): logview window ID
    w (str): well name
    listPos (list): track position for starting and finishing top header
    text (str): text of the top header note
    centered (bool): Optional; 1 if text is centered, 0 else
 
Returns:
    bool: operation exit status
logViewAddTopHeaderNoteByTrack(*args, **kwargs)
logViewAddTopHeaderNoteByTrack(plotID: Number, pos: Number, text: str, centered: bool=True) -> bool
 
Add a top header note for a track in the logview
 
Args:
    plotID (Number): logview window ID
    pos (Number): track position
    text (str): text of the top header note
    centered (bool): Optional; 1 if text is centered, 0 else
 
Returns:
    bool: operation exit status
logViewAddTrackTopHeaderNoteByWell(*args, **kwargs)
logViewAddTrackTopHeaderNoteByWell(plotID: Number, w: str, pos: Number, text: str, centered: bool=True) -> bool
 
Add a top header note for a track in the logview
 
Args:
    plotID (Number): logview window ID
    w (str): well name
    pos (Number): track position
    text (str): text of the top header note
    centered (bool): Optional; 1 if text is centered, 0 else
 
Returns:
    bool: operation exit status
logViewAddZone(*args, **kwargs)
logViewAddZone(plotID: Number, z: str) -> bool
 
Display of one zone of the zonation set of the logview
 
Args:
    plotID (Number): logview window ID
    z (str): name of the zone to display
 
Returns:
    bool: operation exit status
logViewApplyTemplate(*args, **kwargs)
logViewApplyTemplate(nameTemplate: str, nameObject: str, set: bool) -> Number
 
Apply a layout template to a dataset or a well
 
Args:
    nameTemplate (str): layout template name (level can be set in the name by following the syntax: 'level\filename.xml')
    nameObject (str): well name if the template is applied by well. Well and dataset name (with the syntax 'wellName_datasetName') if the template is applied by dataset
    set (bool): True if dataset, False else
 
Returns:
    Number: layout window ID
logViewCreate(*args, **kwargs)
logViewCreate(n: str, vl: list=None, mw: bool=True) -> Number
 
Create a new logview
 
Args:
    n (str): logview window name
    vl (list): Optional; variable list
    mw (bool): Optional; True = multiwell else False
 
Returns:
    Number: logview window ID
logViewCreateBoreholeShape(*args, **kwargs)
logViewCreateBoreholeShape(plotID: Number, wellName: str, datasetName: str, varNameList: list, padAAzimuthName: str='', relativeBearingName: str='', useAsCaliper: bool=True) -> bool
 
Create and insert a borehole shape in an existing logview
 
Args:
    plotID (Number): logview window ID
    wellName (str): name of the well
    datasetName (str): name of the dataset
    varNameList (list): list of calipers or radius names
    padAAzimuthName (str): Optional; name of the pad A azimuth
    relativeBearingName (str): Optional; name of the relative bearing
    useAsCaliper (bool): Optional; use the variable list as calipers if True, else use the variable list as radius
 
Returns:
    bool: operation exit status
logViewCreateCrossReference(*args, **kwargs)
logViewCreateCrossReference(plotID: Number, reference: str, variable: str, track: Number, type: int, color: str='black', type: int='MARKER_CIRCLE', size: Number=5) -> bool
 
Create a cross reference object.
 
Args:
    plotID (Number): logview window ID
    reference (str): Custom reference WellName.DatasetName.VariableName
    variable (str): Variable WellName.DatasetName.VariableName
    track (Number): Position of the track in the logview
    type (int): 0: Cloud, 1: Mean
    color (str): Optional; Point color
    type (int): Optional; markers type {'MARKER_CIRCLE', 'MARKER_SQUARE', 'MARKER_DIAMOND',
       'MARKER_TRIANGLE', 'MARKER_TRIANGLE_DOWN', 'MARKER_TRIANGLE_LEFT',
       'MARKER_TRIANGLE_RIGHT', 'MARKER_EMPTY_CIRCLE', 'MARKER_EMPTY_SQUARE',
       'MARKER_EMPTY_DIAMOND', 'MARKER_EMPTY_TRIANGLE', 'MARKER_EMPTY_TRIANGLE_DOWN',
       'MARKER_EMPTY_TRIANGLE_LEFT', 'MARKER_EMPTY_TRIANGLE_RIGHT', 'MARKER_SHURIKEN',
       'MARKER_EMPTY_SHURIKEN', 'MARKER_PLUS', 'MARKER_CROSS',
       'MARKER_STAR', 'MARKER_RIG', 'NB_MARKER'}
    size (Number): Optional; markers size
 
 
Returns:
    bool: operation exit status
logViewCreateDipMeters(*args, **kwargs)
logViewCreateDipMeters(plotID: Number, wellName: str, datasetName: str, varName: str, toolName: str, varNameList: list, orientationVar: str, doi: float=0.0, associatedCaliperVar: str='', associatedHoleAzimuthVar: str='', associatedHoleDeviationVar: str='') -> bool
 
Create and insert a dip meters in an existing logview
 
Args:
    plotID (Number): logview window ID
    wellName (str): name of the well
    datasetName (str): name of the dataset
    varName (str): name of the variable
    toolName (str): name of the tool (ARMS_4, ARMS_6, SHDT)
    varNameList (list): list of arms names
    orientationVar (str): name of the orientation variable
    doi (float): Optional; depth of investigation
    associatedCaliperVar (str): Optional; name of the associated caliper
    associatedHoleAzimuthVar (str): Optional; name of the associated hole azimuth
    associatedHoleDeviationVar (str): Optional; name of the associated hole deviation
 
Returns:
    bool: operation exit status
logViewDelta(*args, **kwargs)
logViewDelta(plotID: Number, log1: str, log2: str) -> bool
 
Delta computation between two log lines (same well) or arrays (same well and dataset). Computed log is added to the current layout with name 'Delta_log1name_log2name'
 
Args:
    plotID (Number): logview window ID
    log1 (str): first variable name
    log2 (str): second variable name
 
Returns:
    bool: operation exit status
logViewDuplicate(*args, **kwargs)
logViewDuplicate(plotID: Number) -> Number
 
Duplicate the logview
 
Args:
    plotID (Number): logview window ID
 
Returns:
    Number: new plot id or -1
logViewFillWithColor(*args, **kwargs)
logViewFillWithColor(plotID: Number, v: str, left: bool, r: Number, g: Number, b: Number) -> bool
 
Add a filling to variable with color
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    left (bool): 1 = fill left, 0 else
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
logViewFillWithPalette(*args, **kwargs)
logViewFillWithPalette(plotID: Number, v: str, left: bool, pal: str) -> bool
 
Add a filling to variable with palette
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    left (bool): 1 = fill left, 0 else
    pal (str): palette name (level can be set in the name by following the syntax: 'level\palette')
 
Returns:
    bool: operation exit status
logViewFillWithPattern(*args, **kwargs)
logViewFillWithPattern(plotID: Number, v: str, left: bool, pal: str) -> bool
 
Add a filling to variable with pattern
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    left (bool): 1 = fill left, 0 else
    pal (str): pattern name
 
Returns:
    bool: operation exit status
logViewGetApplyTheFamilyPropertiesStatus(*args, **kwargs)
logViewGetApplyTheFamilyPropertiesStatus(plotID: Number) -> bool
 
Get the Property Apply the family properties status.
 
Args:
    plotID (Number): logview window ID
 
Returns:
    bool: True if the property is applied, false otherwise
logViewGetAxeUnitByVariable(*args, **kwargs)
logViewGetAxeUnitByVariable(plotID: Number, v: str) -> str
 
Get a variable axis unit in the logview
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
 
Returns:
    str: unit of the first log found for the given variable
logViewGetIdByName(*args, **kwargs)
logViewGetIdByName(n: str) -> Number
 
Find the ID of a name-known logview
 
Args:
    n (str): logview name
 
Returns:
    Number: logview window ID
logViewGetVariableListByTrack(*args, **kwargs)
logViewGetVariableListByTrack(plotID: int) -> dict
 
Get the list of variables by track in a layout
 
Args:
    plotID (int): logview window ID
 
Returns:
    dict: A dictionary with track index as key and a list [Well.Dataset.Variable] as value
logViewHorizontalGridDisplay(*args, **kwargs)
logViewHorizontalGridDisplay(plotID: Number, w: str, pos: Number, g: int=0) -> bool
 
Change horizontal grid display in one specified track
 
Args:
    plotID (Number): logview window ID
    w (str): well name
    pos (Number): position of the track
    g (int): Optional; display type {0 = 'HORIZONTAL_BELOW', 1 = 'HORIZONTAL_TOP', 2 = 'HORIZONTAL_NONE'}
 
Returns:
    bool: operation exit status
logViewInsertBaseline(*args, **kwargs)
logViewInsertBaseline(plotID: Number, v: str, val: Number) -> bool
 
Display of a baseline on the logview
 
Args:
    plotID (Number): logview window ID
    v (str): variable ID
    val (Number): baseline value
 
Returns:
    bool: operation exit status
logViewInsertCrossPlot(*args, **kwargs)
logViewInsertCrossPlot(plotID: Number, var1: str, var2: str, top: Number, bottom: Number, var3: str=None) -> bool
 
Insert a cross-plot object in the logview
 
Args:
    plotID (Number): logview window ID
    var1 (str): X variable name
    var2 (str): Y variable name
    top (Number): top value for insertion
    bottom (Number): bottom value for insertion
    var3 (str): Optional; color variable name
 
Returns:
    bool: operation exit status
logViewInsertCrossPlotByDepth(*args, **kwargs)
logViewInsertCrossPlotByDepth(plotID: Number, var1: str, var2: str, step: Number, top: Number, bottom: Number, var3: str=None) -> bool
 
Insert cross-plot object by depth in the logview
 
Args:
    plotID (Number): logview window ID
    var1 (str): X variable name
    var2 (str): Y variable name
    step (Number): step for inserting cross-plot
    top (Number): top value for insertion
    bottom (Number): bottom value for insertion
    var3 (str): Optional; color variable name
 
Returns:
    bool: operation exit status
logViewInsertCrossPlotByZone(*args, **kwargs)
logViewInsertCrossPlotByZone(plotID: Number, var1: str, var2: str, zn: str, var3: str=None) -> bool
 
Insert cross-plot object by zone in the logview
 
Args:
    plotID (Number): logview window ID
    var1 (str): X variable name
    var2 (str): Y variable name
    zn (str): zonation name
    var3 (str): Optional; color variable name
 
Returns:
    bool: operation exit status
logViewInsertHistogram(*args, **kwargs)
logViewInsertHistogram(plotID: Number, var: str, top: Number, bottom: Number) -> bool
 
Insert a histogram object in the logview
 
Args:
    plotID (Number): logview window ID
    var (str): variable name
    top (Number): top value for insertion
    bottom (Number): bottom value for insertion
 
Returns:
    bool: operation exit status
logViewInsertHistogramByDepth(*args, **kwargs)
logViewInsertHistogramByDepth(plotID: Number, var: str, step: Number, top: Number, bottom: Number) -> bool
 
Insert histogram object by depth in the logview
 
Args:
    plotID (Number): logview window ID
    var (str): variable name
    step (Number): step for inserting histogram
    top (Number): top value for insertion
    bottom (Number): bottom value for insertion
 
Returns:
    bool: operation exit status
logViewInsertHistogramByZone(*args, **kwargs)
logViewInsertHistogramByZone(plotID: Number, var: str, zn: str) -> bool
 
Insert histogram object by zone in the logview
 
Args:
    plotID (Number): logview window ID
    var (str): variable name
    zn (str): zonation name
 
Returns:
    bool: operation exit status
logViewInsertStereonet(*args, **kwargs)
logViewInsertStereonet(plotID: Number, var: str, top: Number, bottom: Number, var2: str=None) -> bool
 
Insert a stereonet object in the logview
 
Args:
    plotID (Number): logview window ID
    var (str): dip variable name or angular variable name for azimuth
    top (Number): top value for insertion
    bottom (Number): bottom value for insertion
    var2 (str): Optional; second angular variable name for dip
 
Returns:
    bool: operation exit status
logViewInsertStereonetByDepth(*args, **kwargs)
logViewInsertStereonetByDepth(plotID: Number, var: str, step: Number, top: Number, bottom: Number, var2: str=None) -> bool
 
Insert stereonet object by depth in the logview
 
Args:
    plotID (Number): logview window ID
    var (str): dip variable name or angular variable name for azimuth
    step (Number): step for inserting steronet
    top (Number): top value for insertion
    bottom (Number): bottom value for insertion
    var2 (str): Optional; second angular variable name for dip
 
Returns:
    bool: operation exit status
logViewInsertStereonetByZone(*args, **kwargs)
logViewInsertStereonetByZone(plotID: Number, var: str, zn: str, var2: str=None) -> bool
 
Insert stereonet object by zone in the logview
 
Args:
    plotID (Number): logview window ID
    var (str): dip variable name or angular variable name for azimuth
    zn (str): zonation name
    var2 (str): Optional; second angular variable name for dip
 
Returns:
    bool: operation exit status
logViewInsertTrack(*args, **kwargs)
logViewInsertTrack(plotID: Number, tr: int, pos: Number=0) -> Number
 
Insert any type of track in a logview
 
Args:
    plotID (Number): logview window ID
    tr (int): track type {'NORMAL', 'REFERENCE', 'SEPARATOR',
    'PLOT', 'ZONATION', 'ANNOTATION', 'ARRAY'}
    pos (Number): Optional; position of the track in the layout
 
Returns:
    Number: reference number of the track if success, else -1
logViewInsertTrackByWell(*args, **kwargs)
logViewInsertTrackByWell(plotID: Number, n: str, tr: int, pos: Number=0, zs: str='') -> Number
 
Insert any type of track in a multiwell logview
 
Args:
    plotID (Number): logview window ID
    n (str): well name
    tr (int): track type {'NORMAL', 'REFERENCE', 'SEPARATOR',
    'PLOT', 'ZONATION', 'ANNOTATION', 'ARRAY'}
    pos (Number): Optional; position of the track in the layout
    zs (str): Optional; zonation set (if insertion of a zonation track)
 
Returns:
    Number: reference number of the track if success, else -1
logViewInsertUncertaintyConstant(*args, **kwargs)
logViewInsertUncertaintyConstant(plotID: Number, v: str, lowerBound: Number, upperBound: Number, r: Number=255, g: Number=255, b: Number=0) -> bool
 
Insert an incertitude range for this variable
 
Args:
    plotID (Number): logview window ID
    v (str): variable ID
    lowerBound (Number): lower limit for uncertainty value
    upperBound (Number): upper limit for uncertainty value
    r (Number): Optional; red
    g (Number): Optional; green
    b (Number): Optional; blue
 
Returns:
    bool: operation exit status
logViewInsertUncertaintyVariable(*args, **kwargs)
logViewInsertUncertaintyVariable(plotID: Number, v: str, variableLowerBound: str, variableUpperBound: str, r: Number=255, g: Number=255, b: Number=0) -> bool
 
Insert an incertitude range for this variable
 
Args:
    plotID (Number): logview window ID
    v (str): variable ID
    variableLowerBound (str): lower limit for uncertainty values
    variableUpperBound (str): upper limit for uncertainty values
    r (Number): Optional; red
    g (Number): Optional; green
    b (Number): Optional; blue
 
Returns:
    bool: operation exit status
logViewInsertVariable(*args, **kwargs)
logViewInsertVariable(plotID: Number, vl: list, tr: Number=None) -> bool
 
Insert a new logs in a layout - it is possible to specify a track by its position to insert logs
 
Args:
    plotID (Number): logview window ID
    vl (list): variables list to insert
    tr (Number): Optional; position of the track
 
Returns:
    bool: operation exit status
logViewInsertVariableInTrack(*args, **kwargs)
logViewInsertVariableInTrack(plotID: Number, var: str, newvar: list) -> bool
 
Insert a new logs in a track already existing & containing log(s) in the layout - takes a variable already in the wanted track to find it
 
Args:
    plotID (Number): logview window ID
    var (str): name of one variable which log is in the track
    newvar (list): new variable or variables list
 
Returns:
    bool: operation exit status
logViewInsertVariablesInCumulatedTrack(*args, **kwargs)
logViewInsertVariablesInCumulatedTrack(plotID: Number, varlist: list, pos: Number=-1, colorlist: list=None, patternlist: list=None, lock: bool=False) -> bool
 
Insert variables in a cumulated track - it is possible to specify the track position
 
Args:
    plotID (Number): logview window ID
    varlist (list): variables list to insert
    pos (Number): Optional; position of the track
    colorlist (list): Optional; colors list
    patternlist (list): Optional; patterns list
    lock (bool): Optional; {False = 'Cumulate the variables', True = 'Lock the track. Does not cumulate the variables'}
 
Returns:
    bool: operation exit status
logViewInsertVariablesInCumulatedTrackByWell(*args, **kwargs)
logViewInsertVariablesInCumulatedTrackByWell(plotID: Number, well: str, varlist: list, pos: Number=-1, colorlist: list=None, patternlist: list=None, noCumulVarList: list=None) -> bool
 
Insert variables in a cumulated track in a specified well - it is possible to specify the track position according to the well
 
Args:
    plotID (Number): logview window ID
    well (str): well name
    varlist (list): variables list to insert
    pos (Number): Optional; position of the track
    colorlist (list): Optional; colors list
    patternlist (list): Optional; patterns list
    noCumulVarList (list): Optional; variables list to insert without cumulating
 
Returns:
    bool: operation exit status
logViewInverseArrayBHI(*args, **kwargs)
logViewInverseArrayBHI(plotID: Number, variableName: str, inverse: bool) -> bool
 
Inverse arrayBHI logs
 
Args:
    plotID (Number): logview window ID
    variableName (str): name of the arrayBHI [wellName.datasetName.variableName]
    inverse (bool): inversion status
 
Returns:
    bool: operation exit status
logViewLimitsByVariable(*args, **kwargs)
logViewLimitsByVariable(plotID: Number, variableName: str) -> list
 
Get the limits of a variable in a logview
 
Args:
    plotID (Number): logview window ID
    variableName (str): name of the variable ["Well.Dataset.Variable"]
 
Returns:
    list: limits [[float] lower limit, [float] upper limit, [bool] inverted]
logViewLimitsTypeByVariable(*args, **kwargs)
logViewLimitsTypeByVariable(plotID: Number, variableName: str) -> str
 
Get the limits type of a variable in a logview
 
Args:
    plotID (Number): logview window ID
    variableName (str): name of the variable ["Well.Dataset.Variable"]
 
Returns:
    str: limits type ['variable', 'user', 'family']
logViewLoadFooter(*args, **kwargs)
logViewLoadFooter(plotID: Number, footer: str) -> bool
 
Load the footer as main footer of the layout
 
Args:
    plotID (Number): logview window ID
    footer (str): footer name (Folder.FooterName)
 
Returns:
    bool: operation exit status
logViewLoadHeader(*args, **kwargs)
logViewLoadHeader(plotID: Number, header: str) -> bool
 
Load the header as main header of the layout
 
Args:
    plotID (Number): logview window ID
    header (str): header name (Folder.HeaderName)
 
Returns:
    bool: operation exit status
logViewOpen(*args, **kwargs)
logViewOpen(n: str, f: str='', type: int=0) -> Number
 
Open an existing Logview
 
Args:
    n (str): logview window name
    f (str): Optional; folder
    type (int): Optional; layout type {'LAYOUT', 'LAYOUTTEMPLATE'}
 
Returns:
    Number: logview window ID
logViewOptimised(*args, **kwargs)
logViewOptimised(plotID: Number, v: str, optimised: bool) -> bool
 
[DEPRECATED] (use logViewOptimized instead) Change if a log display is optimised or not
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    optimised (bool): True if optimised, False else
 
Returns:
    bool: operation exit status
logViewOptimisedByArrayBHI(*args, **kwargs)
logViewOptimisedByArrayBHI(plotID: Number, v: str, optimised: bool, value: Number=3) -> bool
 
[DEPRECATED] (use logViewOptimizedByArrayBHI instead) Set if optimised & threshold value for arrayBHI logs
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    optimised (bool): True if optimised, False else
    value (Number): Optional; threshold pixel value
 
Returns:
    bool: operation exit status
logViewOptimisedX(*args, **kwargs)
logViewOptimisedX(plotID: Number, v: str, optimised: bool, value: Number=3) -> bool
 
[DEPRECATED] (use logViewOptimizedX instead) Set if optimised horizontally & threshold value for array or arrayBHI logs
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    optimised (bool): True if optimised, False else
    value (Number): Optional; threshold pixel value
 
Returns:
    bool: operation exit status
logViewOptimisedXByArrayBHI(*args, **kwargs)
logViewOptimisedXByArrayBHI(plotID: Number, v: str, optimised: bool, value: Number=3) -> bool
 
[DEPRECATED] (use logViewOptimizedByArrayBHI instead) Set if optimised horizontally & threshold value for arrayBHI logs
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    optimised (bool): True if optimised, False else
    value (Number): Optional; threshold pixel value
 
Returns:
    bool: operation exit status
logViewOptimized(*args, **kwargs)
logViewOptimized(plotID: Number, v: str, optimised: bool) -> bool
 
Change if a log display is optimised or not
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    optimised (bool): True if optimised, False else
 
Returns:
    bool: operation exit status
logViewOptimizedByArrayBHI(*args, **kwargs)
logViewOptimizedByArrayBHI(plotID: Number, v: str, optimised: bool, value: Number=3) -> bool
 
Set if optimised & threshold value for arrayBHI logs
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    optimised (bool): True if optimised, False else
    value (Number): Optional; threshold pixel value
 
Returns:
    bool: operation exit status
logViewOptimizedX(*args, **kwargs)
logViewOptimizedX(plotID: Number, v: str, optimised: bool, value: Number=3) -> bool
 
Set if optimised horizontally & threshold value for array or arrayBHI logs
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    optimised (bool): True if optimised, False else
    value (Number): Optional; threshold pixel value
 
Returns:
    bool: operation exit status
logViewOptimizedXByArrayBHI(*args, **kwargs)
logViewOptimizedXByArrayBHI(plotID: Number, v: str, optimised: bool, value: Number=3) -> bool
 
Set if optimised horizontally & threshold value for arrayBHI logs
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    optimised (bool): True if optimised, False else
    value (Number): Optional; threshold pixel value
 
Returns:
    bool: operation exit status
logViewRemoveAll(*args, **kwargs)
logViewRemoveAll(plotID: Number) -> bool
 
Remove all tracks from the layout
 
Args:
    plotID (Number): logview window ID
 
Returns:
    bool: operation exit status
logViewRemoveFill(*args, **kwargs)
logViewRemoveFill(plotID: Number, v: str) -> bool
 
remove a filling to variable
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
 
Returns:
    bool: operation exit status
logViewRemoveLog(*args, **kwargs)
logViewRemoveLog(plotID: Number, v: str, tr: bool=False) -> bool
 
Remove a log from the logview
 
Args:
    plotID (Number): logview window ID
    v (str): variable ID of the log to remove
    tr (bool): Optional; =1 if remove the empty track after removing log
    warning: all empty tracks of the logview will be removed
 
Returns:
    bool: operation exit status
logViewRemoveTrackByPosition(*args, **kwargs)
logViewRemoveTrackByPosition(plotID: Number, pos: Number, n: str=None, trackType: int=0) -> bool
 
Remove a track from the layout - track selected by its position
 
Args:
    plotID (Number): logview window ID
    pos (Number): position of the track to delete
    n (str): Optional; well name (if multiwell logview)
    trackType (int): Optional; track type {'NORMAL', 'REFERENCE', 'SEPARATOR',
    'PLOT', 'ZONATION', 'ANNOTATION'} (if multiwell logview)
 
Returns:
    bool: operation exit status
logViewRemoveTrackByVar(*args, **kwargs)
logViewRemoveTrackByVar(plotID: Number, var: str) -> bool
 
[DEPRECATED] (use logViewRemoveTrackByVariable instead) Remove a track from the layout - track selected by variable
 
Args:
    plotID (Number): logview window ID
    var (str): variable in track to delete
 
Returns:
    bool: operation exit status
logViewRemoveTrackByVariable(*args, **kwargs)
logViewRemoveTrackByVariable(plotID: Number, var: str) -> bool
 
Remove a track from the layout - track selected by variable
 
Args:
    plotID (Number): logview window ID
    var (str): variable in track to delete
 
Returns:
    bool: operation exit status
logViewRemoveWell(*args, **kwargs)
logViewRemoveWell(plotID: Number, w: str) -> bool
 
Remove all logs from a well from a layout
 
Args:
    plotID (Number): logview window ID
    w (str): well name
 
Returns:
    bool: operation exit status
logViewRemoveZonation(*args, **kwargs)
logViewRemoveZonation(plotID: Number, sn: str) -> bool
 
Remove a set of zonation from the logview - any display of zone must previously have been cancelled
 
Args:
    plotID (Number): logview window ID
    sn (str): name of the set of zonation
 
Returns:
    bool: operation exit status
logViewRemoveZone(*args, **kwargs)
logViewRemoveZone(plotID: Number, z: str) -> bool
 
Remove the display of one zone of the zonation set of the logview
 
Args:
    plotID (Number): logview window ID
    z (str): name of the zone
 
Returns:
    bool: operation exit status
logViewSave(*args, **kwargs)
logViewSave(plotID: Number, n: str, f: str='', type: int=0) -> bool
 
Save the logview
 
Args:
    plotID (Number): logview window ID
    n (str): logview window name
    f (str): Optional; folder
    type (int): Optional; layout type {0='LAYOUT', 1='LAYOUTTEMPLATE'}
 
Returns:
    bool: operation exit status
logViewScaleByVariable(*args, **kwargs)
logViewScaleByVariable(plotID: Number, variableName: str) -> str
 
Get the scale of a variable in a logview
 
Args:
    plotID (Number): logview window ID
    variableName (str): name of the variable ["Well.Dataset.Variable"]
 
Returns:
    str: scale ['linear', 'logarithmic']
logViewScaleUnitByVariable(*args, **kwargs)
logViewScaleUnitByVariable(plotID: Number, variableName: str) -> str
 
Get the scale unit a variable in a logview
 
Args:
    plotID (Number): logview window ID
    variableName (str): name of the variable ["Well.Dataset.Variable"]
 
Returns:
    str: scale unit
logViewSetApplyTheFamilyPropertiesStatus(*args, **kwargs)
logViewSetApplyTheFamilyPropertiesStatus(plotID: Number, status: bool=True) -> bool
 
Set the Property Apply the family properties.
 
Args:
    plotID (Number): logview window ID
    status (bool): Optional; state
 
Returns:
    bool: True if operation is OK else return False
logViewSetArrayBHIOrientation(*args, **kwargs)
logViewSetArrayBHIOrientation(plotID: Number, v: str, value: Number) -> bool
 
Set orientation value for arrayBHI logs
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    value (Number): orientation value
 
Returns:
    bool: operation exit status
logViewSetAxeLimitTypeByVariable(*args, **kwargs)
logViewSetAxeLimitTypeByVariable(plotID: Number, v: str, sc: int) -> bool
 
Change a variable axis type in the logview
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    sc (int): limit type {0 = 'VAR', 1 = 'USER', 2 = 'FAMILY'}
 
Returns:
    bool: operation exit status
logViewSetAxeScaleByVariable(*args, **kwargs)
logViewSetAxeScaleByVariable(plotID: Number, v: str, sc: int) -> bool
 
Change a variable axis scale in the logview
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    sc (int): scale type {0 = 'LINEAR', 1 = 'LOGARITHMIC'}
 
Returns:
    bool: operation exit status
logViewSetAxeUnitByVariable(*args, **kwargs)
logViewSetAxeUnitByVariable(plotID: Number, v: str, u: str) -> bool
 
Change a variable axis unit in the logview
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    u (str): new unit
 
Returns:
    bool: operation exit status
logViewSetAxeXAxeIndexTypeToArray(*args, **kwargs)
logViewSetAxeXAxeIndexTypeToArray(plotID: Number, v: str, xat: int) -> bool
 
Change the X index axis limits types for a  array variable in a logview
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    xat (int): X axis type {0 = 'VAR', 1 = 'USER'}
 
Returns:
    bool: operation exit status
logViewSetAxeXAxeIndexValMaxUserToArray(*args, **kwargs)
logViewSetAxeXAxeIndexValMaxUserToArray(plotID: Number, v: str, max: Number) -> bool
 
Change the X index axis user upper  limits  for a  array variable in a logview
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    max (Number): bottom limit
 
Returns:
    bool: operation exit status
logViewSetAxeXAxeIndexValMinUserToArray(*args, **kwargs)
logViewSetAxeXAxeIndexValMinUserToArray(plotID: Number, v: str, min: Number) -> bool
 
Change the X index axis user lower  limits  for a  array variable in a logview
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    min (Number): top limit
 
Returns:
    bool: operation exit status
logViewSetAxeXAxeVarMaxUserToArray(*args, **kwargs)
logViewSetAxeXAxeVarMaxUserToArray(plotID: Number, v: str, max: Number) -> bool
 
[DEPRECATED] (use logViewSetAxeXAxeVariableMaxUserToArray instead) Change the X variable axis user upper  limits  for a  array variable in a logview
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    max (Number): bottom limit
 
Returns:
    bool: operation exit status
logViewSetAxeXAxeVarMinUserToArray(*args, **kwargs)
logViewSetAxeXAxeVarMinUserToArray(plotID: Number, v: str, min: Number) -> bool
 
[DEPRECATED] (use logViewSetAxeXAxeVariableMinUserToArray instead) Change the X variable axis user lower  limits  for a  array variable in a logview
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    min (Number): top limit
 
Returns:
    bool: operation exit status
logViewSetAxeXAxeVarNameToArray(*args, **kwargs)
logViewSetAxeXAxeVarNameToArray(plotID: Number, v: str, v: str) -> bool
 
[DEPRECATED] (use logViewSetAxeXAxeVariableNameToArray instead) Change the X variable axis variable name  for a  array variable in a logview
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    v (str): variable name
 
Returns:
    bool: operation exit status
logViewSetAxeXAxeVarScaleTypeToArray(*args, **kwargs)
logViewSetAxeXAxeVarScaleTypeToArray(plotID: Number, v: str, xasc: int) -> bool
 
[DEPRECATED] (use logViewSetAxeXAxeVariableScaleTypeToArray instead) Change the X variable axis scale for a array variable in a logview
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    xasc (int): scale type {0 = 'LINEAR', 1 = 'LOGARITHMIC'}
 
Returns:
    bool: operation exit status
logViewSetAxeXAxeVarTypeToArray(*args, **kwargs)
logViewSetAxeXAxeVarTypeToArray(plotID: Number, v: str, xat: int) -> bool
 
[DEPRECATED] (use logViewSetAxeXAxeVariableTypeToArray instead) Change the X variable axis limits types for a  array variable in a logview
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    xat (int): X axis type {0 = 'VAR', 1 = 'USER'}
 
Returns:
    bool: operation exit status
logViewSetAxeXAxeVariableMaxUserToArray(*args, **kwargs)
logViewSetAxeXAxeVariableMaxUserToArray(plotID: Number, v: str, max: Number) -> bool
 
Change the X variable axis user upper  limits  for a  array variable in a logview
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    max (Number): bottom limit
 
Returns:
    bool: operation exit status
logViewSetAxeXAxeVariableMinUserToArray(*args, **kwargs)
logViewSetAxeXAxeVariableMinUserToArray(plotID: Number, v: str, min: Number) -> bool
 
Change the X variable axis user lower  limits  for a  array variable in a logview
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    min (Number): top limit
 
Returns:
    bool: operation exit status
logViewSetAxeXAxeVariableNameToArray(*args, **kwargs)
logViewSetAxeXAxeVariableNameToArray(plotID: Number, v: str, v: str) -> bool
 
Change the X variable axis variable name  for a  array variable in a logview
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    v (str): variable name
 
Returns:
    bool: operation exit status
logViewSetAxeXAxeVariableScaleTypeToArray(*args, **kwargs)
logViewSetAxeXAxeVariableScaleTypeToArray(plotID: Number, v: str, xasc: int) -> bool
 
Change the X variable axis scale for a array variable in a logview
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    xasc (int): scale type {0 = 'LINEAR', 1 = 'LOGARITHMIC'}
 
Returns:
    bool: operation exit status
logViewSetAxeXAxeVariableTypeToArray(*args, **kwargs)
logViewSetAxeXAxeVariableTypeToArray(plotID: Number, v: str, xat: int) -> bool
 
Change the X variable axis limits types for a  array variable in a logview
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    xat (int): X axis type {0 = 'VAR', 1 = 'USER'}
 
Returns:
    bool: operation exit status
logViewSetAxeXInverseToCumulatedTrack(*args, **kwargs)
logViewSetAxeXInverseToCumulatedTrack(plotID: Number, variableNames: list, inverted: bool) -> bool
 
Change the orientation of the X Axis for a cumulated track in a logview
 
Args:
    plotID (Number): logview window  ID
    variableNames (list): list of wellName.datasetName.variableName
    inverted (bool): inversion status
 
Returns:
    bool: operation exit status
logViewSetAxeXInversedToArray(*args, **kwargs)
logViewSetAxeXInversedToArray(plotID: Number, v: str, inversed: bool) -> bool
 
Set the  Invert X axis's property  for a array variable in a logview
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    inversed (bool): True if inversed, False else
 
Returns:
    bool: operation exit status
logViewSetAxeXMaxUserToCumulatedArray(*args, **kwargs)
logViewSetAxeXMaxUserToCumulatedArray(plotID: Number, v: str, min: Number) -> bool
 
Change a the X axis upper limit for a  cumulated array variable in a logview
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    min (Number): bottom limit
 
Returns:
    bool: operation exit status
logViewSetAxeXMaxUserToHistoArray(*args, **kwargs)
logViewSetAxeXMaxUserToHistoArray(plotID: Number, v: str, max: Number) -> bool
 
Change the X axis user upper limits  for a histogram array variable in a logview
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    max (Number): bottom limit
 
Returns:
    bool: operation exit status
logViewSetAxeXMinMaxUserToCrossReference(*args, **kwargs)
logViewSetAxeXMinMaxUserToCrossReference(plotId: Number, variable: str, min: Number, max: Number) -> bool
 
 
Args:
    plotId (Number): plot window ID
    variable (str): Variable WellName.DatasetName.VariableName
    min (Number): Min user value
    max (Number): Max user value
 
Returns:
    bool: operation exit status
logViewSetAxeXMinUserToCumulatedArray(*args, **kwargs)
logViewSetAxeXMinUserToCumulatedArray(plotID: Number, v: str, min: Number) -> bool
 
Change a the X axis lower limit for a  cumulated array variable in a logview
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    min (Number): top limit
 
Returns:
    bool: operation exit status
logViewSetAxeXMinUserToHistoArray(*args, **kwargs)
logViewSetAxeXMinUserToHistoArray(plotID: Number, v: str, min: Number) -> bool
 
Change the X axis user lower limits  for a histogram array variable in a logview
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    min (Number): top limit
 
Returns:
    bool: operation exit status
logViewSetAxeXScaleTypeToHistoArray(*args, **kwargs)
logViewSetAxeXScaleTypeToHistoArray(plotID: Number, v: str, xasc: int) -> bool
 
Change the X axis scale for a histogram array variable in a logview
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    xasc (int): scale type {0 = 'LINEAR', 1 = 'LOGARITHMIC'}
 
Returns:
    bool: operation exit status
logViewSetAxeXTypeToCumulatedArray(*args, **kwargs)
logViewSetAxeXTypeToCumulatedArray(plotID: Number, v: str, xat: int) -> bool
 
Change the X axis limits types for a  cumulated array variable in a logview
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    xat (int): X axis type {0 = 'VAR', 1 = 'USER'}
 
Returns:
    bool: operation exit status
logViewSetAxeXTypeToHistoArray(*args, **kwargs)
logViewSetAxeXTypeToHistoArray(plotID: Number, v: str, xat: int) -> bool
 
Change the X axis limits types for a histogram array variable in a logview
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    xat (int): X axis type {0 = 'VAR', 1 = 'USER'}
 
Returns:
    bool: operation exit status
logViewSetAxeXUnitToCrossReference(*args, **kwargs)
logViewSetAxeXUnitToCrossReference(plotId: Number, variable: str, unit: str) -> bool
 
 
Args:
    plotId (Number): plot window ID
    variable (str): Variable WellName.DatasetName.VariableName
    unit (str): Axis X unit
 
Returns:
    bool: operation exit status
logViewSetAxeXWithVarToArray(*args, **kwargs)
logViewSetAxeXWithVarToArray(plotID: Number, v: str, variable_axis: bool) -> bool
 
[DEPRECATED] (use logViewSetAxeXWithVariableToArray instead) Switch X axis from index axis to variable axis for a array variable in a logview
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    variable_axis (bool): True if variable axis, False if index axis
 
Returns:
    bool: operation exit status
logViewSetAxeXWithVariableToArray(*args, **kwargs)
logViewSetAxeXWithVariableToArray(plotID: Number, v: str, variable_axis: bool) -> bool
 
Switch X axis from index axis to variable axis for a array variable in a logview
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    variable_axis (bool): True if variable axis, False if index axis
 
Returns:
    bool: operation exit status
logViewSetCallTypeByVariable(*args, **kwargs)
logViewSetCallTypeByVariable(plotID: Number, v: str, ct: int) -> bool
 
Change the call type of a variable in the logview
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    ct (int): new call type {0 = 'VAR_NAME_CT', 1 = 'FAMILY_CT', 2 = 'ALIAS_CT'}
 
Returns:
    bool: operation exit status
logViewSetDisplayOnXOutputValueOnYToArray(*args, **kwargs)
logViewSetDisplayOnXOutputValueOnYToArray(plotID: Number, v: str, always: bool) -> bool
 
Change the always display property  for a array variable in a logview
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    always (bool): True if always display, False else
 
Returns:
    bool: operation exit status
logViewSetHeaderOrientation(*args, **kwargs)
logViewSetHeaderOrientation(plotID: Number, posTrackList: list, vertical: bool) -> bool
 
Change the orientation of the header in a track
 
Args:
    plotID (Number): logview window ID
    posTrackList (list): list of position of tracks
    vertical (bool): header vertical if True, else header horizontal
 
Returns:
    bool: operation exit status
logViewSetHorizontal(*args, **kwargs)
logViewSetHorizontal(plotID: Number, horizontal: bool) -> Number
 
Set the logview orientation
 
Args:
    plotID (Number): logview window ID
    horizontal (bool): horizontal if True, else vertical
 
Returns:
    Number: logview window ID
logViewSetLayoutScale(*args, **kwargs)
logViewSetLayoutScale(plotID: Number, sc: Number=200) -> bool
 
Change the layout global scale
 
Args:
    plotID (Number): logview window ID
    sc (Number): Optional; wanted scale - scale format is '1 : sc', only enter sc
    default scale is '1 : 200', to have it back only enter logview ID
 
Returns:
    bool: operation exit status
logViewSetLimitsByVariable(*args, **kwargs)
logViewSetLimitsByVariable(plotID: Number, variableName: str, lowerLimit: float, upperLimit: float, inverted: bool) -> bool
 
Set the limits of a variable in a logview
 
Args:
    plotID (Number): logview window ID
    variableName (str): name of the variable ["Well.Dataset.Variable"]
    lowerLimit (float): new lower limit of the variable
    upperLimit (float): new upper limit of the variable
    inverted (bool): inverse or not the limit of the variable
 
Returns:
    bool: operation exit status
logViewSetLimitsTypeByVariable(*args, **kwargs)
logViewSetLimitsTypeByVariable(plotID: Number, variableName: str, limitsType: str) -> bool
 
Set the limits type of a variable in a logview
 
Args:
    plotID (Number): logview window ID
    variableName (str): name of the variable ["Well.Dataset.Variable"]
    limitsType (str): limits type ['variable', 'user', 'family']
 
Returns:
    bool: operation exit status
logViewSetLineProperties(*args, **kwargs)
logViewSetLineProperties(plotID: Number, v: str, st: int=0, ty: Number=0, thk: Number=2) -> bool
 
Set user preferences for line display of logs
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    st (int): Optional; line type {'NoPen', 'SolidLine', 'DashLine', 'DotLine', 'DashDotLine', 'DashDotDotLine', 'DotDashDashLine', 'ShortDashLine', 'LongDashLine'}
    ty (Number): Optional; line continuity {'NO_CONNECTION', 'POINT_TO_POINT', 'STEP_H_V', 'STEP_V_H', 'STEP_CENTER'}
    thk (Number): Optional; line thickness (between 1 & 8)
 
Returns:
    bool: operation exit status
logViewSetMarkers(*args, **kwargs)
logViewSetMarkers(plotID: Number, v: str, show: bool, ty: int=0, size: Number=2) -> bool
 
Set user preferences for variable markers.
It works exclusively on variable, not dataset.
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    show (bool): 1 = show markers on log
    ty (int): Optional; markers type {'MARKER_CIRCLE', 'MARKER_SQUARE', 'MARKER_DIAMOND', 'MARKER_TRIANGLE',
       'MARKER_TRIANGLE_DOWN', 'MARKER_TRIANGLE_LEFT', 'MARKER_TRIANGLE_RIGHT', 'MARKER_EMPTY_CIRCLE', 'MARKER_EMPTY_SQUARE',
       'MARKER_EMPTY_DIAMOND', 'MARKER_EMPTY_TRIANGLE', 'MARKER_EMPTY_TRIANGLE_DOWN', 'MARKER_EMPTY_TRIANGLE_LEFT',
       'MARKER_EMPTY_TRIANGLE_RIGHT', 'MARKER_SHURIKEN', 'MARKER_EMPTY_SHURIKEN', 'MARKER_PLUS', 'MARKER_CROSS',
       'MARKER_STAR', 'MARKER_RIG', 'NB_MARKER'}
    size (Number): Optional; markers size (between 2 & 20)
 
Returns:
    bool: operation exit status
logViewSetMaxUserByVariable(*args, **kwargs)
logViewSetMaxUserByVariable(plotID: Number, v: str, max: Number, inversed: bool) -> bool
 
Change a variable bottom limit in the logview
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    max (Number): bottom limit
    inversed (bool): True if inversed, False else
 
Returns:
    bool: operation exit status
logViewSetMaxUserToMatrixArrayBHI(*args, **kwargs)
logViewSetMaxUserToMatrixArrayBHI(plotID: Number, v: str, min: Number) -> bool
 
Change a the upper  limit for a matrix array BHI  in a logview
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    min (Number): top limit
 
Returns:
    bool: operation exit status
logViewSetMinMaxUserByVariable(*args, **kwargs)
logViewSetMinMaxUserByVariable(plotID: Number, v: str, min: Number, max: Number, inversed: bool) -> bool
 
[DEPRECATED] Change a variable top and bottom limits in the logview
Please use logViewSetLimitsByVariable instead.
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    min (Number): top limit
    max (Number): bottom limit
    inversed (bool): True if inversed, False else
 
Returns:
    bool: operation exit status
logViewSetMinUserByVariable(*args, **kwargs)
logViewSetMinUserByVariable(plotID: Number, v: str, min: Number, inversed: bool) -> bool
 
Change a variable top limit in the logview
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    min (Number): top limit
    inversed (bool): True if inversed, False else
 
Returns:
    bool: operation exit status
logViewSetMinUserToMatrixArrayBHI(*args, **kwargs)
logViewSetMinUserToMatrixArrayBHI(plotID: Number, v: str, min: Number) -> bool
 
Change a the lower limit for a matrix array BHI  in a logview
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    min (Number): top limit
 
Returns:
    bool: operation exit status
logViewSetName(*args, **kwargs)
logViewSetName(plotID: Number, n: str) -> bool
 
Change the name of the logview
 
Args:
    plotID (Number): logview window ID
    n (str): new logview windows name
 
Returns:
    bool: operation exit status
logViewSetPalette(*args, **kwargs)
logViewSetPalette(plotID: Number, v: str, pal: str) -> bool
 
Add a palette to variable
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    pal (str): palette name (level can be set in the name by following the syntax: 'level\palette')
 
Returns:
    bool: operation exit status
logViewSetPaletteLimits(*args, **kwargs)
logViewSetPaletteLimits(plotID: Number, v: str, limitMin: float, limitMax: float) -> bool
 
Set palette limits for variable
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    limitMin (float): Lower limit
    limitMax (float): Upper limit (> limitMin)
 
Returns:
    bool: operation exit status
logViewSetPartialTrackStartStopByVariable(*args, **kwargs)
logViewSetPartialTrackStartStopByVariable(plotID: Number, varName: str, start: Number, stop: Number) -> bool
 
Set start stop values for partial track to log line
 
Args:
    plotID (Number): logview window ID
    varName (str): variable name wellName.datasetName.variableName
    start (Number): start value for partial track
    stop (Number): stop value for partial track
 
Returns:
    bool: operation exit status
logViewSetPartialTrackStartStopToArray(*args, **kwargs)
logViewSetPartialTrackStartStopToArray(plotID: Number, varName: str, start: Number, stop: Number) -> bool
 
Set start stop values for partial track to array
 
Args:
    plotID (Number): logview window ID
    varName (str): variable name wellName.datasetName.variableName
    start (Number): start value for partial track
    stop (Number): stop value for partial track
 
Returns:
    bool: operation exit status
logViewSetReferenceDisplay(*args, **kwargs)
logViewSetReferenceDisplay(plotID: Number, r: str, u: str=None) -> bool
 
Change the reference space & the reference unit in the logview
 
Args:
    plotID (Number): logview window ID
    r (str): reference scale
    u (str): Optional; new unit
 
Returns:
    bool: operation exit status
logViewSetReferenceDisplayByTrack(*args, **kwargs)
logViewSetReferenceDisplayByTrack(plotID: Number, pos: Number, r: str) -> bool
 
Change the reference space of a reference track in the logview
 
Args:
    plotID (Number): logview window ID
    pos (Number): track position
    r (str): reference scale
 
Returns:
    bool: operation exit status
logViewSetReferenceUnit(*args, **kwargs)
logViewSetReferenceUnit(plotID: Number, u: str=None) -> bool
 
Change the reference unit in the logview
 
Args:
    plotID (Number): logview window ID
    u (str): Optional; new unit
 
Returns:
    bool: operation exit status
logViewSetReferenceUnitByTrack(*args, **kwargs)
logViewSetReferenceUnitByTrack(plotID: Number, pos: Number, u: str) -> bool
 
Change the reference unit of a reference track in the logview
 
Args:
    plotID (Number): logview window ID
    pos (Number): track position
    u (str): new unit
 
Returns:
    bool: operation exit status
logViewSetScaleByVariable(*args, **kwargs)
logViewSetScaleByVariable(plotID: Number, variableName: str, scale: str) -> bool
 
Set the scale of a variable in a logview
 
Args:
    plotID (Number): logview window ID
    variableName (str): name of the variable ["Well.Dataset.Variable"]
    scale (str): scale of the variable ['linear', 'logarithmic']
 
Returns:
    bool: operation exit status
logViewSetScaleTypeToMatrixArrayBHI(*args, **kwargs)
logViewSetScaleTypeToMatrixArrayBHI(plotID: Number, v: str, xasc: int) -> bool
 
Change the scale for a matrix array BHI  in a logview
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    xasc (int): scale type {0 = 'LINEAR', 1 = 'LOGARITHMIC'}
 
Returns:
    bool: operation exit status
logViewSetScaleUnitByVariable(*args, **kwargs)
logViewSetScaleUnitByVariable(plotID: Number, variableName: str, scaleUnit: str) -> bool
 
Set the scale unit of a variable in a logview
 
Args:
    plotID (Number): logview window ID
    variableName (str): name of the variable ["Well.Dataset.Variable"]
    scaleUnit (str): scale unit of the variable
 
Returns:
    bool: operation exit status
logViewSetThresholdY(*args, **kwargs)
logViewSetThresholdY(plotID: Number, v: str, value: Number) -> bool
 
Set threshold value for optimised array or arrayBHI logs
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    value (Number): threshold pixel value
 
Returns:
    bool: operation exit status
logViewSetTrackReferenceDisplayByWell(*args, **kwargs)
logViewSetTrackReferenceDisplayByWell(plotID: Number, w: str, pos: Number, r: str) -> bool
 
Change the reference space of a reference track in the logview
 
Args:
    plotID (Number): logview window ID
    w (str): well name
    pos (Number): track position
    r (str): reference scale
 
Returns:
    bool: operation exit status
logViewSetTrackReferenceUnitByWell(*args, **kwargs)
logViewSetTrackReferenceUnitByWell(plotID: Number, w: str, pos: Number, u: str) -> bool
 
Change the reference unit of a reference track in the logview
 
Args:
    plotID (Number): logview window ID
    w (str): well name
    pos (Number): track position
    u (str): new unit
 
Returns:
    bool: operation exit status
logViewSetVariableColor(*args, **kwargs)
logViewSetVariableColor(plotID: Number, var: str, r: Number, g: Number, b: Number) -> bool
 
Change the default color of a variable log
 
Args:
    plotID (Number): logview window ID
    var (str): variable ID to modify (WellName.DatasetName.VariableName)
    r (Number): red (0-255)
    g (Number): green (0-255)
    b (Number): blue (0-255)
 
Returns:
    bool: operation exit status
logViewSetVariableColour(*args, **kwargs)
logViewSetVariableColour(plotID: Number, var: str, r: Number, g: Number, b: Number) -> bool
 
[DEPRECATED] (use logViewSetVariableColor instead) Change the default color of a variable log
 
Args:
    plotID (Number): logview window ID
    var (str): variable ID to modify (WellName.DatasetName.VariableName)
    r (Number): red (0-255)
    g (Number): green (0-255)
    b (Number): blue (0-255)
 
Returns:
    bool: operation exit status
logViewSetWellDatum(*args, **kwargs)
logViewSetWellDatum(plotID: Number, w: str, lim: bool, min: Number=0, max: Number=0) -> bool
 
Set a user reference limitation to a well
 
Args:
    plotID (Number): logview window ID
    w (str): well name
    lim (bool): 1 = user limits else 0
    min (Number): Optional; top limit
    max (Number): Optional; bottom limit
    if inputs 4 & 5 are not given by user (& lim =1), min = 0 & max = last registered max
 
Returns:
    bool: operation exit status
logViewSetZonation(*args, **kwargs)
logViewSetZonation(plotID: Number, sn: str) -> bool
 
Assign a set of zonation to the logview
 
Args:
    plotID (Number): logview window ID
    sn (str): name of the set of zonation
 
Returns:
    bool: operation exit status
logViewSetZonationTrackColorationMode(*args, **kwargs)
logViewSetZonationTrackColorationMode(plotID: Number, trackID: Number, mode: str='COLOUR') -> bool
 
Change the coloring mode of a zonation track
 
Args:
    plotID (Number): logview window ID
    trackID (Number): reference number of the zonation track
    mode (str): Optional; coloring mode, {'COLOUR', 'PATTERN', 'BOTH'}
 
Returns:
    bool: operation exit status
logViewSetZonationTrackColourationMode(*args, **kwargs)
logViewSetZonationTrackColourationMode(plotID: Number, trackID: Number, mode: str='COLOUR') -> bool
 
[DEPRECATED] (use logViewSetZonationTrackColorationMode instead) Change the coloring mode of a zonation track
 
Args:
    plotID (Number): logview window ID
    trackID (Number): reference number of the zonation track
    mode (str): Optional; coloring mode, {'COLOUR', 'PATTERN', 'BOTH'}
 
Returns:
    bool: operation exit status
logViewSetZonationTrackFamily(*args, **kwargs)
logViewSetZonationTrackFamily(plotID: Number, trackID: Number, family: str='ZONE_NAME') -> bool
 
Change the family of a zonation track
 
Args:
    plotID (Number): logview window ID
    trackID (Number): reference number of the zonation track
    family (str): Optional; family type, {'ZONE_NAME', 'HYDRAULIC_ZONE', 'FAULT_BLOCK'}
 
Returns:
    bool: operation exit status
logViewSetZonationTrackSet(*args, **kwargs)
logViewSetZonationTrackSet(plotID: Number, trackID: Number, set: str) -> bool
 
Change the dataset of a zonation track
 
Args:
    plotID (Number): logview window ID
    trackID (Number): reference number of the zonation track
    set (str): dataset name
 
Returns:
    bool: operation exit status
logViewSetZonationTrackTextOrientation(*args, **kwargs)
logViewSetZonationTrackTextOrientation(plotID: Number, trackID: Number, b: bool=True) -> bool
 
Change the orientation of the text in a zonation track
 
Args:
    plotID (Number): logview window ID
    trackID (Number): reference number of the zonation track
    b (bool): Optional; text vertical if True, else text horizontal
 
Returns:
    bool: operation exit status
logViewSmooth(*args, **kwargs)
logViewSmooth(plotID: Number, v: str, smooth: bool) -> bool
 
Smooth for array or arrayBHI logs
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    smooth (bool): True if smoothed, False else
 
Returns:
    bool: operation exit status
logViewSmoothByArrayBHI(*args, **kwargs)
logViewSmoothByArrayBHI(plotID: Number, v: str, smooth: bool) -> bool
 
Smooth for array or arrayBHI logs
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    smooth (bool): True if smoothed, False else
 
Returns:
    bool: operation exit status
logViewTrackSize(*args, **kwargs)
logViewTrackSize(plotID: Number, pos: Number, s: Number) -> bool
 
Set track size in the logview
 
Args:
    plotID (Number): logview window ID
    pos (Number): track position
    s (Number): size of track (in pixels)
 
Returns:
    bool: operation exit status
logViewTrackSizeByWell(*args, **kwargs)
logViewTrackSizeByWell(plotID: Number, w: str, pos: Number, s: Number) -> bool
 
Set track size in the logview for a given well
 
Args:
    plotID (Number): logview window ID
    w (str): well name
    pos (Number): track position
    s (Number): size of track (in pixels)
 
Returns:
    bool: operation exit status
logViewVerticalGridDisplay(*args, **kwargs)
logViewVerticalGridDisplay(plotID: Number, w: str, pos: Number, g: int=0) -> bool
 
Change vertical grid display in one specified track
 
Args:
    plotID (Number): logview window ID
    w (str): well name
    pos (Number): position of the track
    g (int): Optional; display type {0 = 'VERTICAL_BELOW', 1 = 'VERTICAL_TOP', 2 = 'VERTICAL_NONE'}
 
Returns:
    bool: operation exit status
logViewVerticalGridLineColor(*args, **kwargs)
logViewVerticalGridLineColor(plotID: Number, w: str, pos: Number, r: Number=173, g: Number=173, b: Number=173) -> bool
 
Change the color of vertical grid lines in one specified track
 
Args:
    plotID (Number): logview window ID
    w (str): well name
    pos (Number): position of the track
    r (Number): Optional; red
    g (Number): Optional; green
    b (Number): Optional; blue
    default line color is grey
 
Returns:
    bool: operation exit status
logViewVerticalGridLineColour(*args, **kwargs)
logViewVerticalGridLineColour(plotID: Number, w: str, pos: Number, r: Number=173, g: Number=173, b: Number=173) -> bool
 
[DEPRECATED] (use logViewVerticalGridLineColor instead) Change the color of vertical grid lines in one specified track
 
Args:
    plotID (Number): logview window ID
    w (str): well name
    pos (Number): position of the track
    r (Number): Optional; red
    g (Number): Optional; green
    b (Number): Optional; blue
    default line color is grey
 
Returns:
    bool: operation exit status
logViewVerticalGridLineCount(*args, **kwargs)
logViewVerticalGridLineCount(plotID: Number, w: str, pos: Number, count: Number=4) -> bool
 
Change the number of line of vertical grid in one specified track
 
Args:
    plotID (Number): logview window ID
    w (str): well name
    pos (Number): position of the track
    count (Number): Optional; number of lines (default = 4)
 
Returns:
    bool: operation exit status
logViewVerticalGridLineThickness(*args, **kwargs)
logViewVerticalGridLineThickness(plotID: Number, w: str, pos: Number, thk: Number=4) -> bool
 
Change the thickness of vertical grid lines in one specified track
 
Args:
    plotID (Number): logview window ID
    w (str): well name
    pos (Number): position of the track
    thk (Number): Optional; line thickness (default = 1)
 
Returns:
    bool: operation exit status
logViewVerticalGrigLineCount(*args, **kwargs)
logViewVerticalGrigLineCount(plotID: Number, w: str, pos: Number, count: Number=4) -> bool
 
[DEPRECATED] (use logViewVerticalGridLineCount instead) Change the number of line of vertical grid in one specified track
 
Args:
    plotID (Number): logview window ID
    w (str): well name
    pos (Number): position of the track
    count (Number): Optional; number of lines (default = 4)
 
Returns:
    bool: operation exit status
logViewZonationAreaFilling(*args, **kwargs)
logViewZonationAreaFilling(plotID: Number, fill: bool, transp: Number=4) -> bool
 
Set filling proprieties of colored zonation
 
Args:
    plotID (Number): logview window ID
    fill (bool): 1 = show filled else 0
    transp (Number): Optional; transparency (between 0 & 10)
 
Returns:
    bool: operation exit status
logViewZonationBordersProperties(*args, **kwargs)
logViewZonationBordersProperties(plotID: Number, thk: Number=2, r: Number=0, g: Number=0, b: Number=0) -> bool
 
Set border proprieties of coloured zonation
 
Args:
    plotID (Number): logview window ID
    thk (Number): Optional; border line thikness (between 1 & 5)
    r (Number): Optional; red
    g (Number): Optional; green
    b (Number): Optional; blue
 
Returns:
    bool: operation exit status
logViewZonationDisplay(*args, **kwargs)
logViewZonationDisplay(plotID: Number, ty: int=0) -> bool
 
Change the display of zonation on logview
 
Args:
    plotID (Number): logview window ID
    ty (int): Optional; zonation display type {0 = 'BELOW_GRID (default)', 1 = 'OVER_GRID', 2 = 'OVER_LOG'}
 
Returns:
    bool: operation exit status
logviewInsertUncertaintyConstant(*args, **kwargs)
logviewInsertUncertaintyConstant(plotID: Number, v: str, lowerBound: Number, upperBound: Number, r: Number=255, g: Number=255, b: Number=0) -> bool
 
[DEPRECATED] (use logViewInsertUncertaintyConstant instead) Insert an incertitude range for this variable
 
Args:
    plotID (Number): logview window ID
    v (str): variable ID
    lowerBound (Number): lower limit for uncertainty value
    upperBound (Number): upper limit for uncertainty value
    r (Number): Optional; red
    g (Number): Optional; green
    b (Number): Optional; blue
 
Returns:
    bool: operation exit status
logviewInsertUncertaintyVariable(*args, **kwargs)
logviewInsertUncertaintyVariable(plotID: Number, v: str, variableLowerBound: str, variableUpperBound: str, r: Number=255, g: Number=255, b: Number=0) -> bool
 
[DEPRECATED] (use logViewInsertUncertaintyVariable instead) Insert an incertitude range for this variable
 
Args:
    plotID (Number): logview window ID
    v (str): variable ID
    variableLowerBound (str): lower limit for uncertainty values
    variableUpperBound (str): upper limit for uncertainty values
    r (Number): Optional; red
    g (Number): Optional; green
    b (Number): Optional; blue
 
Returns:
    bool: operation exit status
logviewSetAxeXMaxUserToHistoArray(*args, **kwargs)
logviewSetAxeXMaxUserToHistoArray(plotID: Number, v: str, max: Number) -> bool
 
[DEPRECATED] (use logViewSetAxeXMaxUserToHistoArray instead) Change the X axis user upper limits  for a histogram array variable in a logview
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    max (Number): bottom limit
 
Returns:
    bool: operation exit status
logviewSetAxeXMinUserToHistoArray(*args, **kwargs)
logviewSetAxeXMinUserToHistoArray(plotID: Number, v: str, min: Number) -> bool
 
[DEPRECATED] (use logViewSetAxeXMinUserToHistoArray instead) Change the X axis user lower limits  for a histogram array variable in a logview
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    min (Number): top limit
 
Returns:
    bool: operation exit status
logviewSetAxeXTypeToHistoArray(*args, **kwargs)
logviewSetAxeXTypeToHistoArray(plotID: Number, v: str, xat: int) -> bool
 
[DEPRECATED] (use logViewSetAxeXTypeToHistoArray instead) Change the X axis limits types for a histogram array variable in a logview
 
Args:
    plotID (Number): logview window ID
    v (str): variable name
    xat (int): X axis type {0 = 'VAR', 1 = 'USER'}
 
Returns:
    bool: operation exit status
macroKeyboardPress(*args, **kwargs)
macroKeyboardPress()
 
Simulate the keyboard
macroKeyboardRelease(*args, **kwargs)
macroKeyboardRelease()
 
Simulate the keyboard
macroKeyboardType(*args, **kwargs)
macroKeyboardType(keyboard_string: str)
 
Simulate the keyboard
 
Args:
    keyboard_string (str): Keyboard key
macroMouseLeftDown(*args, **kwargs)
macroMouseLeftDown()
 
Simulate the mouse left button getting down
macroMouseLeftUp(*args, **kwargs)
macroMouseLeftUp()
 
Simulate the mouse left button getting up
macroMouseMiddleDown(*args, **kwargs)
macroMouseMiddleDown()
 
Simulate the mouse middle button getting down
macroMouseMiddleUp(*args, **kwargs)
macroMouseMiddleUp()
 
Simulate the mouse middle button getting up
macroMouseMove(*args, **kwargs)
macroMouseMove()
 
Simulate the mouse movement
macroMouseRightDown(*args, **kwargs)
macroMouseRightDown()
 
Simulate the mouse right button getting down
macroMouseRightUp(*args, **kwargs)
macroMouseRightUp()
 
Simulate the mouse right button getting up
macroMouseWheel(*args, **kwargs)
macroMouseWheel()
 
Simulate the mouse wheel
macroObjectExists(*args, **kwargs)
macroObjectExists()
 
Return true if a widget exists and is visible (param: widgetDescriptor)
macroObjectHeight(*args, **kwargs)
macroObjectHeight()
 
(param: widgetDescriptor)
macroObjectLeft(*args, **kwargs)
macroObjectLeft()
 
(param: widgetDescriptor)
macroObjectTop(*args, **kwargs)
macroObjectTop()
 
(param: widgetDescriptor)
macroObjectWidth(*args, **kwargs)
macroObjectWidth()
 
(param: widgetDescriptor)
macroWait(*args, **kwargs)
macroWait()
 
Wait before the next action (in ms)
matrixBoxPlotByZoneOpen(*args, **kwargs)
matrixBoxPlotByZoneOpen(n: str, f: str=None) -> Number
 
Open an existing matrix box-plot by zone
 
Args:
    n (str): plot name
    f (str): Optional; folder
 
Returns:
    Number: plot ID
matrixBoxPlotOpen(*args, **kwargs)
matrixBoxPlotOpen(n: str, f: str=None) -> Number
 
Open an existing matrix box-plot
 
Args:
    n (str): plot name
    f (str): Optional; folder
 
Returns:
    Number: plot ID
matrixCreate(*args, **kwargs)
matrixCreate(n: str, nbl: Number=1, nbc: Number=2, t: str='', f: str='') -> Number
 
Open an empty matrix custom window
 
Args:
    n (str): matrix window name
    nbl (Number): Optional; number of lines of the matrix
    nbc (Number): Optional; number of columns of the matrix
    t (str): Optional; matrix title
    f (str): Optional; folder
 
Returns:
    Number: matrix window ID
matrixCrossPlotAddChart(*args, **kwargs)
matrixCrossPlotAddChart(plotID: Number, cn: str) -> bool
 
Add chart to the cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    cn (str): chart name
 
Returns:
    bool: operation exit status
matrixCrossPlotAddData(*args, **kwargs)
matrixCrossPlotAddData(plotID: Number, ds: list) -> bool
 
Add a dataset to a matrix cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    ds (list): dataset ID (wellName.datasetName)
 
Returns:
    bool: operation exit status
matrixCrossPlotAddZone(*args, **kwargs)
matrixCrossPlotAddZone(plotID: Number, z: str) -> bool
 
Add a zone in the selection to the matrix cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    z (str): zone name
 
Returns:
    bool: operation exit status
matrixCrossPlotCleanZonation(*args, **kwargs)
matrixCrossPlotCleanZonation(plotID: Number, d: str) -> bool
 
Remove the zonation dataset from the matrix cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    d (str): zonation dataset name
 
Returns:
    bool: operation exit status
matrixCrossPlotCleanZone(*args, **kwargs)
matrixCrossPlotCleanZone(plotID: Number, z: str) -> bool
 
Remove a zone in the selection from the matrix cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    z (str): zone name
 
Returns:
    bool: operation exit status
matrixCrossPlotCreate(*args, **kwargs)
matrixCrossPlotCreate(ml: list) -> Number
 
Create a new matrix cross-plot
 
Args:
    ml (list): mnemonic list
 
Returns:
    Number: cross-plot window ID
matrixCrossPlotDensityGridHorizontal(*args, **kwargs)
matrixCrossPlotDensityGridHorizontal(plotID: Number, type: int, xmin: Number=0, xmax: Number=0, dim: Number=50) -> bool
 
Set characteristics of X density grid
 
Args:
    plotID (Number): cross-plot window ID
    type (int): type {0 = 'VARIABLE', 1 = 'USER', 2 = 'FAMILY'}
    xmin (Number): Optional; X axis minimum
    xmax (Number): Optional; X axis maximum
    dim (Number): Optional; box dimension
 
Returns:
    bool: operation exit status
matrixCrossPlotDensityGridVertical(*args, **kwargs)
matrixCrossPlotDensityGridVertical(plotID: Number, type: int, ymin: Number=0, ymax: Number=0, dim: Number=50) -> bool
 
Set characteristics of Y density grid
 
Args:
    plotID (Number): cross-plot window ID
    type (int): type {0 = 'VARIABLE', 1 = 'USER', 2 = 'FAMILY'}
    ymin (Number): Optional; Y axis minimum
    ymax (Number): Optional; Y axis maximum
    dim (Number): Optional; box dimension
 
Returns:
    bool: operation exit status
matrixCrossPlotDensitySmooth(*args, **kwargs)
matrixCrossPlotDensitySmooth(plotID: Number, smooth: bool) -> bool
 
Display of smoothed density values
 
Args:
    plotID (Number): cross-plot window ID
    smooth (bool): 1 = smooth else 0
 
Returns:
    bool: operation exit status
matrixCrossPlotDensityType(*args, **kwargs)
matrixCrossPlotDensityType(plotID: Number, dst: bool) -> bool
 
Display of the matrix cross-plot in normal or density type
 
Args:
    plotID (Number): cross-plot window ID
    dst (bool): 1 = density display else 0
 
Returns:
    bool: operation exit status
matrixCrossPlotDuplicate(*args, **kwargs)
matrixCrossPlotDuplicate(plotID: Number) -> Number
 
Duplicate the matrix cross-plot
 
Args:
    plotID (Number): cross-plot window ID
 
Returns:
    Number: new plot id or -1
matrixCrossPlotIDFindByName(*args, **kwargs)
matrixCrossPlotIDFindByName(n: str) -> Number
 
Find the ID of a name-known cross-plot
 
Args:
    n (str): cross-plot window name
 
Returns:
    Number: cross-plot window ID
matrixCrossPlotOpen(*args, **kwargs)
matrixCrossPlotOpen(n: str, f: str=None) -> Number
 
Open an existing matrix cross-plot
 
Args:
    n (str): plot name
    f (str): Optional; folder
 
Returns:
    Number: plot ID
matrixCrossPlotRemoveDataset(*args, **kwargs)
matrixCrossPlotRemoveDataset(plotID: Number, ds: str) -> bool
 
Remove a dataset from a matrix cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    ds (str): dataset name
 
Returns:
    bool: operation exit status
matrixCrossPlotRemoveWell(*args, **kwargs)
matrixCrossPlotRemoveWell(plotID: Number, we: str) -> bool
 
Remove a well from a matrix cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    we (str): well name
 
Returns:
    bool: operation exit status
matrixCrossPlotSave(*args, **kwargs)
matrixCrossPlotSave(plotID: Number, n: str, f: str='') -> bool
 
Save the matrix cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    n (str): cross-plot name
    f (str): Optional; folder
 
Returns:
    bool: operation exit status
matrixCrossPlotSelectVar(*args, **kwargs)
matrixCrossPlotSelectVar(plotID: Number, we: str, ds: str, famId: Number, vr: str) -> bool
 
[DEPRECATED] (use matrixCrossPlotSelectVariable instead) Change the variable selected among one family's variables in a matrix cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    we (str): well name
    ds (str): dataset name
    famId (Number): ID of the family in which you wish to change variable
    vr (str): new variable name
 
Returns:
    bool: operation exit status
matrixCrossPlotSelectVariable(*args, **kwargs)
matrixCrossPlotSelectVariable(plotID: Number, we: str, ds: str, famId: Number, vr: str) -> bool
 
Change the variable selected among one family's variables in a matrix cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    we (str): well name
    ds (str): dataset name
    famId (Number): ID of the family in which you wish to change variable
    vr (str): new variable name
 
Returns:
    bool: operation exit status
matrixCrossPlotSetName(*args, **kwargs)
matrixCrossPlotSetName(plotID: Number, n: str) -> bool
 
Change the name of matrix cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    n (str): new cross-plot name
 
Returns:
    bool: operation exit status
matrixCrossPlotSetPaletteBoundaries(*args, **kwargs)
matrixCrossPlotSetPaletteBoundaries(plotID: Number, min: Number, max: Number) -> bool
 
Set the boundaries of the palette for a matrix cross plot.
 
Args:
    plotID (Number): plot window ID
    min (Number): minimum of the palette
    max (Number): maximum of the palette
 
Returns:
    bool: operation exit status
matrixCrossPlotSetXAxisInverse(*args, **kwargs)
matrixCrossPlotSetXAxisInverse(plotID: Number, xainv: bool) -> bool
 
Inverse the matrix cross-plot X axis
 
Args:
    plotID (Number): cross-plot window ID
    xainv (bool): 1 = inverse else 0
 
Returns:
    bool: operation exit status
matrixCrossPlotSetXAxisScale(*args, **kwargs)
matrixCrossPlotSetXAxisScale(plotID: Number, xasc: int) -> bool
 
Set the matrix cross-plot X axis scale
 
Args:
    plotID (Number): cross-plot window ID
    xasc (int): scale type {0 = 'LINEAR', 1 = 'LOGARITHMIC'}
 
Returns:
    bool: operation exit status
matrixCrossPlotSetXAxisType(*args, **kwargs)
matrixCrossPlotSetXAxisType(plotID: Number, xat: int) -> bool
 
Change the type of matrix cross-plot X axis
 
Args:
    plotID (Number): cross-plot window ID
    xat (int): X axis type {0 = 'VAR', 1 = 'USER', 2 = 'FAMILY'}
 
Returns:
    bool: operation exit status
matrixCrossPlotSetXAxisUnit(*args, **kwargs)
matrixCrossPlotSetXAxisUnit(plotID: Number, xau: str) -> bool
 
Change the unit of matrix cross-plot X axis
 
Args:
    plotID (Number): cross-plot window ID
    xau (str): X axis unit
 
Returns:
    bool: operation exit status
matrixCrossPlotSetXAxisUserLimits(*args, **kwargs)
matrixCrossPlotSetXAxisUserLimits(plotID: Number, xamin: Number, xamax: Number) -> bool
 
Set min & max values of matrix cross-plot X axis
 
Args:
    plotID (Number): cross-plot window ID
    xamin (Number): X axis minimum
    xamax (Number): X axis maximum
 
Returns:
    bool: operation exit status
matrixCrossPlotSetYAxisInverse(*args, **kwargs)
matrixCrossPlotSetYAxisInverse(plotID: Number, yainv: bool) -> bool
 
Inverse the matrix cross-plot Y axis
 
Args:
    plotID (Number): cross-plot window ID
    yainv (bool): 1 = inverse else 0
 
Returns:
    bool: operation exit status
matrixCrossPlotSetYAxisScale(*args, **kwargs)
matrixCrossPlotSetYAxisScale(plotID: Number, yasc: int) -> bool
 
Set the matrix cross-plot Y axis scale
 
Args:
    plotID (Number): cross-plot window ID
    yasc (int): scale type {0 = 'LINEAR', 1 = 'LOGARITHMIC'}
 
Returns:
    bool: operation exit status
matrixCrossPlotSetYAxisType(*args, **kwargs)
matrixCrossPlotSetYAxisType(plotID: Number, yat: int) -> bool
 
Change the type of matrix cross-plot Y axis
 
Args:
    plotID (Number): cross-plot window ID
    yat (int): Y axis type {0 = 'VAR', 1 = 'USER', 2 = 'FAMILY'}
 
Returns:
    bool: operation exit status
matrixCrossPlotSetYAxisUnit(*args, **kwargs)
matrixCrossPlotSetYAxisUnit(plotID: Number, yau: str) -> bool
 
Change the unit of matrix cross-plot Y axis
 
Args:
    plotID (Number): cross-plot window ID
    yau (str): Y axis unit
 
Returns:
    bool: operation exit status
matrixCrossPlotSetYAxisUserLimits(*args, **kwargs)
matrixCrossPlotSetYAxisUserLimits(plotID: Number, yamin: Number, yamax: Number) -> bool
 
Set min & max values of matrix cross-plot Y axis
 
Args:
    plotID (Number): cross-plot window ID
    yamin (Number): Y axis minimum
    yamax (Number): Y axis maximum
 
Returns:
    bool: operation exit status
matrixCrossPlotSetZonation(*args, **kwargs)
matrixCrossPlotSetZonation(plotID: Number, d: str) -> bool
 
Set the zonation dataset to the matrix cross-plot
 
Args:
    plotID (Number): cross-plot window ID
    d (str): zonation dataset name
 
Returns:
    bool: operation exit status
matrixDashBoardOpen(*args, **kwargs)
matrixDashBoardOpen(n: str, f: str=None) -> Number
 
Open an existing matrix dashboard
 
Args:
    n (str): plot name
    f (str): Optional; folder
 
Returns:
    Number: plot ID
matrixHistogramAddData(*args, **kwargs)
matrixHistogramAddData(plotID: Number, ds: list) -> bool
 
Add a dataset to a matrix histogram
 
Args:
    plotID (Number): histogram window ID
    ds (list): dataset ID (wellName.datasetName)
 
Returns:
    bool: operation exit status
matrixHistogramAddZone(*args, **kwargs)
matrixHistogramAddZone(plotID: Number, z: str) -> bool
 
Add a zone in the selection to the matrix histogram
 
Args:
    plotID (Number): histogram window ID
    z (str): zone name
 
Returns:
    bool: operation exit status
matrixHistogramCleanZonation(*args, **kwargs)
matrixHistogramCleanZonation(plotID: Number, d: str) -> bool
 
Remove the zonation dataset from the matrix histogram
 
Args:
    plotID (Number): histogram window ID
    d (str): zonation dataset name
 
Returns:
    bool: operation exit status
matrixHistogramCleanZone(*args, **kwargs)
matrixHistogramCleanZone(plotID: Number, z: str) -> bool
 
Remove a zone in the selection from the matrix histogram
 
Args:
    plotID (Number): histogram window ID
    z (str): zone name
 
Returns:
    bool: operation exit status
matrixHistogramCreate(*args, **kwargs)
matrixHistogramCreate(ml: list) -> Number
 
Create a new matrix histogram
 
Args:
    ml (list): mnemonic list
 
Returns:
    Number: cross-plot window ID
matrixHistogramDuplicate(*args, **kwargs)
matrixHistogramDuplicate(plotID: Number) -> Number
 
Duplicate the matrix histogram
 
Args:
    plotID (Number): histogram window ID
 
Returns:
    Number: new plot id or -1
matrixHistogramIDFindByName(*args, **kwargs)
matrixHistogramIDFindByName(n: str) -> Number
 
Find the ID of a name-known matrix histogram
 
Args:
    n (str): matrix histogram window name
 
Returns:
    Number: matrix histogram window ID
matrixHistogramOpen(*args, **kwargs)
matrixHistogramOpen(n: str, f: str=None) -> Number
 
Open an existing matrix histogram
 
Args:
    n (str): plot name
    f (str): Optional; folder
 
Returns:
    Number: plot ID
matrixHistogramRemoveDataset(*args, **kwargs)
matrixHistogramRemoveDataset(plotID: Number, ds: str) -> bool
 
Remove a dataset from a matrix histogram
 
Args:
    plotID (Number): histogram window ID
    ds (str): dataset name
 
Returns:
    bool: operation exit status
matrixHistogramRemoveWell(*args, **kwargs)
matrixHistogramRemoveWell(plotID: Number, we: str) -> bool
 
Remove a well from a matrix histogram
 
Args:
    plotID (Number): histogram window ID
    we (str): well name
 
Returns:
    bool: operation exit status
matrixHistogramSave(*args, **kwargs)
matrixHistogramSave(plotID: Number, n: str, f: str='') -> bool
 
Save the matrix histogram
 
Args:
    plotID (Number): matrix histogram window ID
    n (str): matrix histogram name
    f (str): Optional; folder
 
Returns:
    bool: operation exit status
matrixHistogramSelectVar(*args, **kwargs)
matrixHistogramSelectVar(plotID: Number, we: str, ds: str, famId: Number, vr: str) -> bool
 
[DEPRECATED] (use matrixHistogramSelectVariable instead) Change the variable selected among one family's variables in a matrix histogram
 
Args:
    plotID (Number): histogram window ID
    we (str): well name
    ds (str): dataset name
    famId (Number): ID of the family in which you wish to change variable
    vr (str): new variable name
 
Returns:
    bool: operation exit status
matrixHistogramSelectVariable(*args, **kwargs)
matrixHistogramSelectVariable(plotID: Number, we: str, ds: str, famId: Number, vr: str) -> bool
 
Change the variable selected among one family's variables in a matrix histogram
 
Args:
    plotID (Number): histogram window ID
    we (str): well name
    ds (str): dataset name
    famId (Number): ID of the family in which you wish to change variable
    vr (str): new variable name
 
Returns:
    bool: operation exit status
matrixHistogramSetFill(*args, **kwargs)
matrixHistogramSetFill(plotID: Number, fill: bool) -> bool
 
Fill or not the inside of the histograms with a color
 
Args:
    plotID (Number): matrix histogram window ID
    fill (bool): 1 = fill; 0 = don't fill
 
Returns:
    bool: operation exit status
matrixHistogramSetName(*args, **kwargs)
matrixHistogramSetName(plotID: Number, n: str) -> bool
 
Change the name of matrix histogram
 
Args:
    plotID (Number): matrix histogram window ID
    n (str): new matrix histogram name
 
Returns:
    bool: operation exit status
matrixHistogramSetZonation(*args, **kwargs)
matrixHistogramSetZonation(plotID: Number, d: str) -> bool
 
Set the zonation dataset to the matrix histogram
 
Args:
    plotID (Number): histogram window ID
    d (str): zonation dataset name
 
Returns:
    bool: operation exit status
matrixIDFindByName(*args, **kwargs)
matrixIDFindByName(n: str) -> Number
 
Find the ID of a name-known matrix custom-plot
 
Args:
    n (str): matrix custom-plot name
 
Returns:
    Number: matrix custom-plot window ID
matrixInsertPlot(*args, **kwargs)
matrixInsertPlot(matrixID: Number, plotID: Number, posx: Number=0, posy: Number=0, n: str) -> bool
 
Insert a plot in a matrix custom
 
Args:
    matrixID (Number): matrix window ID
    plotID (Number): plot window ID
    posx (Number): Optional; horizontal position of the plot in the matrix
    posy (Number): Optional; vertical position of the plot in the matrix
    n (str): plot name
 
Returns:
    bool: operation exit status
matrixPCAOpen(*args, **kwargs)
matrixPCAOpen(n: str, f: str=None) -> Number
 
Open an existing matrix PCA
 
Args:
    n (str): plot name
    f (str): Optional; folder
 
Returns:
    Number: plot ID
matrixPlotIDFindByName(*args, **kwargs)
matrixPlotIDFindByName(matrixID: Number, n: str) -> Number
 
Find the ID of a name-known plot of a matrix custom-plot
 
Args:
    matrixID (Number): matrix window ID
    n (str): plot name
 
Returns:
    Number: matrix custom-plot window ID
matrixSPLOMOpen(*args, **kwargs)
matrixSPLOMOpen(n: str, f: str=None) -> Number
 
Open an existing matrix SPLOM
 
Args:
    n (str): plot name
    f (str): Optional; folder
 
Returns:
    Number: plot ID
matrixSplomOpen(*args, **kwargs)
matrixSplomOpen(n: str, f: str=None) -> Number
 
[DEPRECATED] (use matrixSPLOMOpen instead) Open an existing matrix SPLOM
 
Args:
    n (str): plot name
    f (str): Optional; folder
 
Returns:
    Number: plot ID
objectList(*args, **kwargs)
objectList(o: str, f: str='') -> bool
 
Return the list of the objects
 
Args:
    o (str): object type (cross-plot,logView)
    f (str): Optional; folder
 
Returns:
    bool: operation exit status
paletteAddOrUpdateDiscreteValue(*args, **kwargs)
paletteAddOrUpdateDiscreteValue(paletteID: Number, patternID: Number, value: Number, color: str, description: str) -> bool
 
Add or update a discrete value to the palette.
 
Args:
    paletteID (Number): palette ID returned by the plot.paletteDiscreteCreateOrGet function
    patternID (Number): pattern ID returned by the plot.patternID function
    value (Number): discrete value
    color (str): hexadecimal color code to be assigned to the discrete value
    description (str): description to be assigned to the discrete value
 
Returns:
    bool: operation exit status
paletteDiscreteCreateOrGet(*args, **kwargs)
paletteDiscreteCreateOrGet(paletteName: str, storageLevel: str) -> Number
 
Create a discrete values palette at a given storage level or get the palette if this one already exists by its name at the given storage level.
 
Args:
    paletteName (str): name of the discrete values palette
    storageLevel (str): Techlog storage level where the palette is created ('project', 'company', 'user')
 
Returns:
    Number: returns a palette ID if the palette has been created or already exists by its name at the given storage level (returns None if the palette failed to be created)
paletteDiscreteID(*args, **kwargs)
paletteDiscreteID(paletteName: str, storageLevel: str) -> Number
 
Gets the palette by its name at the given storage level.
 
Args:
    paletteName (str): name of the discrete values palette
    storageLevel (str): Techlog storage level where the palette is created ('project', 'company', 'user')
 
Returns:
    Number: returns a palette ID if the palette already exists by its name at the given storage level (returns None if the palette does not exist)
paletteDiscreteValueGetColor(*args, **kwargs)
paletteDiscreteValueGetColor(paletteID: Number, value: Number) -> str
 
Gets a color assigned to a palette discrete value
 
Args:
    paletteID (Number): palette ID returned by the plot.paletteDiscreteCreateOrGet function
    value (Number): discrete value for which you want to get the color
 
Returns:
    str: returns an hexadecimal color code (returns None if no color assigned to the discrete value)
paletteDiscreteValueGetPatternName(*args, **kwargs)
paletteDiscreteValueGetPatternName(paletteID: Number, value: Number) -> str
 
Gets a pattern name assigned to a palette discrete value
 
Args:
    paletteID (Number): palette ID returned by the plot.paletteDiscreteCreateOrGet function
    value (Number): discrete value for which you want to get the pattern name
 
Returns:
    str: returns the pattern name with the format classification__patternName (returns None if no pattern assigned to the discrete value)
paletteDiscreteValueGetPatternStorageLevel(*args, **kwargs)
paletteDiscreteValueGetPatternStorageLevel(paletteID: Number, value: Number) -> str
 
Gets a pattern name assigned to a palette discrete value
 
Args:
    paletteID (Number): palette ID returned by the plot.paletteDiscreteCreateOrGet function
    value (Number): discrete value for which you want to get the pattern storage level
 
Returns:
    str: returns the pattern storage level (returns None if no pattern assigned to the discrete value)
patternID(*args, **kwargs)
patternID(patternClassification: str, patternName: str, patternStorageLevel: str) -> Number
 
Gets the patternID from a pattern name at a given storage level.
 
Args:
    patternClassification (str): classification of the pattern to be assigned to the discrete value
    patternName (str): name of the pattern to be assigned to the discrete value
    patternStorageLevel (str): Techlog storage level of the pattern ('techlog', 'project', 'company', 'user')
 
Returns:
    Number: returns a pattern ID if the pattern exists by its name at the given storage level (returns None if the pattern doesn't exist)
piePlotOpen(*args, **kwargs)
piePlotOpen(n: str, f: str='') -> Number
 
Open an existing pie plot
 
Args:
    n (str): pie plot name
    f (str): Optional; folder
 
Returns:
    Number: pie plot window ID
printCompleted(*args, **kwargs)
printCompleted(threadid: str) -> bool
 
Returns True if multithread print is completed
 
Args:
    threadid (str): the print thread name
 
Returns:
    bool: print completed
printPlot(*args, **kwargs)
printPlot(plotID: Number) -> bool
 
Print a plot
 
Args:
    plotID (Number): plot window ID
 
Returns:
    bool: operation exit status
printToFile(*args, **kwargs)
printToFile(plotID: Number, paperFormat: str, outputFormat: str, outputName: str, paperWidth: Number=0, paperHeight: Number=0, adjustWidthType: Number=0, adjustWidthValue: Number=-1, adjustHeightType: Number=0, adjustHeightValue: Number=-1, scale: Number=-1, officeCompatible: bool=False, resolution: Number=600) -> bool
 
Export the plot into a file
 
Args:
    plotID (Number): object ID
    paperFormat (str): 'A4', 'Letter'...
    outputFormat (str): '.jpg', '.cgm', '.emf', '.pdf'... or 'printer'
    outputName (str): file name (saved in Various folder) or printer name if output format is set to 'printer'
    paperWidth (Number): Optional; paper width in cm
    paperHeight (Number): Optional; paper width in cm
    adjustWidthType (Number): Optional; can be 'adjust to the page' (=0), 'fixed scale' (=1), 'keep proportions' (=2), 'custom' (=3)
    adjustWidthValue (Number): Optional; adjust width value in cm
    adjustHeightType (Number): Optional; can be 'adjust to n pages' (=0), 'fixed scale' (=1), 'keep proportions' (=2), 'custom' (=3)
    adjustHeightValue (Number): Optional; adjust height value in cm if adjust height is 'custom' or number of pages if adjust height is 'adjust to n pages'
    scale (Number): Optional; scale
    officeCompatible (bool): Optional; useful only with CGM format. must be set to true if the generated file is to be used in Microsoft Office applications such
    as Word, PowerPoint...
    resolution (Number): Optional; dpi resolution to print or export the file
 
Returns:
    bool: operation exit status
printToFileMultiThread(*args, **kwargs)
printToFileMultiThread(plotID: Number, paperFormat: str, outputFormat: str, outputName: str, paperWidth: Number=0, paperHeight: Number=0, adjustWidthType: Number=0, adjustWidthValue: Number=-1, adjustHeightType: Number=0, adjustHeightValue: Number=-1, scale: Number=-1, officeCompatible: bool=False, resolution: Number=600) -> str
 
Export the plot into a file, using a separate thread
 
Args:
    plotID (Number): object ID
    paperFormat (str): 'A4', 'Letter'...
    outputFormat (str): '.jpg', '.cgm', '.emf', '.pdf'... or 'printer'
    outputName (str): file name (saved in Various folder) or printer name if output format is set to 'printer'
    paperWidth (Number): Optional; paper width in cm
    paperHeight (Number): Optional; paper width in cm
    adjustWidthType (Number): Optional; can be 'adjust to the page' (=0), 'fixed scale' (=1), 'keep proportions' (=2), 'custom' (=3)
    adjustWidthValue (Number): Optional; adjust width value in cm
    adjustHeightType (Number): Optional; an be 'adjust to n pages' (=0), 'fixed scale' (=1), 'keep proportions' (=2), 'custom' (=3)
    adjustHeightValue (Number): Optional; adjust height value in cm if adjust height is 'custom', or number of pages if adjust height is 'adjust to n pages'
    scale (Number): Optional; scale
    officeCompatible (bool): Optional; seful only with CGM format. must be set to true if the generated file is to be used in Microsoft Office applications such
    as Word, PowerPoint...
    resolution (Number): Optional; resolution in dpi to print or export the file
 
Returns:
    str: thread name
reportEditorAddItem(*args, **kwargs)
reportEditorAddItem(reN: int, pN: int, inS: str, speS: str, itNE: int) -> int
 
Add an item into an existing page
 
Args:
    reN (int): report editor ID
    pN (int): page ID
    inS (str): depends on item type
        Saved items : item name as in your project browser
        Others items : desired item name in your report browser
    speS (str): depends on item type
        Saved items : folder name : Project, User, Company or Techlog
        Generic items : generic item description (text displayed over your item in report)
        Text item : text content (can contain HTML content if compliant with Qt's rich text engine)
        Documentation : qt-project.org/doc/qt-4.8/richtext-html-subset.html
        Table of item : title of the table of in your report page
    itNE (int): item type = { 0 - Image, 1 - Layout, 2 - Layout Template, 3 - Crossplot, 4 - Crossplot MW,
        6 - Crossplot AA, 7 - Crossplot Template, 8 - Histogram, 9 - Histogram MW, 10 - Histogram Template,
        11 - Stereonet, 12 - Lineplot, 13 - Header, 14 - Text, 15 - Generic Header,
        16 - Generic Layout, 17 - Generic Crossplot, 18 - Generic Histogram, 19 - Generic Stereonet, 20 - Generic Lineplot,
        21 - Generic Image, 22 - Generic Text, 23 - Ternary, 24 - Walkout, 25 - Cumulative Dip,
        26 - Single Depth, 27 - Generic Ternary, 28 - Generic Walkout, 29 - Generic Cumulative Dip, 30 - Generic Single Depth,
        31 - Table of Contents, 32 - Table of Figures, 33 - Tables of Tables, 34 - Crossplot AVA, 35 - Waveform,
        36 - Generic Waveform, 37 - Wellbore Centrid Grid, 38 - Generic Wellbore Centrid Grid, 39 - Borehole Section, 40 - Generic Borehole Section,
        41 - Cross section profile plot, 42 - Cross section profile plot template, 43 - Generic cross section profile plot,
        44 - Axial section profile plot, 45 - Axial section profile plot template, 46 - Generic axial section profile plot}
 
Returns:
    int: Success : item ID, else Exception
reportEditorAddItemToMasterPage(*args, **kwargs)
reportEditorAddItemToMasterPage(reN: Number, sN: Number, inS: str, speS: str, itNE: int) -> Number
 
Add an item to an existing master page:
 
Args:
    reN (Number): report editor ID
    sN (Number): section ID
    inS (str): item name
    speS (str): depends on item type
        Image item : folder name : Project, User, Company or Techlog
        Text item : text content (can contain HTML content if compliant with Qt's rich text engine)
        Documentation : qt-project.org/doc/qt-4.8/richtext-html-subset.html
    itNE (int): item type = { 0 - Image, 1 - Text}
 
Returns:
    Number: Success : item ID, else Exception
reportEditorAddLineItem(*args, **kwargs)
reportEditorAddLineItem(reN: Number, pN: Number, x1N: Number, y1N: Number, x2N: Number, y2N: Number) -> Number
 
Add a line item in a page
 
Args:
    reN (Number): report editor ID
    pN (Number): page ID
    x1N (Number): begin point horizontal position in current unit
    y1N (Number): begin point vertical position in current unit
    x2N (Number): end point horizontal position in current unit
    y2N (Number): end point vertical position in current unit
 
Returns:
    Number: Success : item ID, else Exception
reportEditorAddLineItemInMasterPage(*args, **kwargs)
reportEditorAddLineItemInMasterPage(reN: Number, sN: Number, x1N: Number, y1N: Number, x2N: Number, y2N: Number) -> Number
 
Add a line item in a master page
 
Args:
    reN (Number): report editor ID
    sN (Number): section ID
    x1N (Number): begin point horizontal position in current unit
    y1N (Number): begin point vertical position in current unit
    x2N (Number): end point horizontal position in current unit
    y2N (Number): end point vertical position in current unit
 
Returns:
    Number: Success : item ID, else Exception
reportEditorAddPage(*args, **kwargs)
reportEditorAddPage(reN: Number, snN: Number, pnS: str='Page X') -> Number
 
Add a page to an existing section
 
Args:
    reN (Number): report editor ID
    snN (Number): section ID
    pnS (str): Optional; page name
 
Returns:
    Number: Success : page ID, else Exception
reportEditorAddRectItem(*args, **kwargs)
reportEditorAddRectItem(reN: Number, pN: Number, xN: Number, yN: Number, wN: Number, hN: Number) -> Number
 
Add a rectangle item in a page
 
Args:
    reN (Number): report editor ID
    pN (Number): page ID
    xN (Number): horizontal position in current unit
    yN (Number): vertical position in current unit
    wN (Number): width in current unit
    hN (Number): height in current unit
 
Returns:
    Number: Success : item ID, else Exception
reportEditorAddRectItemInMasterPage(*args, **kwargs)
reportEditorAddRectItemInMasterPage(reN: Number, sN: Number, xN: Number, yN: Number, wN: Number, hN: Number) -> Number
 
Add a rectangle item in a master page
 
Args:
    reN (Number): report editor ID
    sN (Number): section ID
    xN (Number): horizontal position in current unit
    yN (Number): vertical position in current unit
    wN (Number): width in current unit
    hN (Number): height in current unit
 
Returns:
    Number: Success : item ID, else Exception
reportEditorAddSection(*args, **kwargs)
reportEditorAddSection(reN: Number, snS: str) -> Number
 
Add a section to your report
 
Args:
    reN (Number): report editor ID
    snS (str): section name
 
Returns:
    Number: Success : section ID, else Exception
reportEditorAddSpecialItemToMasterPage(*args, **kwargs)
reportEditorAddSpecialItemToMasterPage(reN: Number, sN: Number, inS: str, hpN: Number, vpN: Number) -> Number
 
Add special item to the master page
Only page number available at the moment
 
Args:
    reN (Number): report editor ID
    sN (Number): section ID
    inS (str): item name in report browser
    hpN (Number): horizontal position in current unit
    vpN (Number): vertical position in current unit
 
Returns:
    Number: Success : item ID, else Exception
reportEditorAddTable(*args, **kwargs)
reportEditorAddTable(reN: Number, ptN: Number, rcN: Number, ccN: Number, rhN: Number=1, cwN: Number=1, xN: Number=0, yN: Number=0) -> Number
 
Add a table to the report
 
Args:
    reN (Number): report editor ID
    ptN (Number): page ID
    rcN (Number): row count
    ccN (Number): column count
    rhN (Number): Optional; row height in current unit
    cwN (Number): Optional; column width in current unit
    xN (Number): Optional; horizontal position in current unit
    yN (Number): Optional; vertical position in current unit
 
Returns:
    Number: Success : table ID, else Exception
reportEditorAdjustItemToPage(*args, **kwargs)
reportEditorAdjustItemToPage(reN: Number, iN: Number, aB: bool) -> bool
 
Adjust an item to the page width
 
Args:
    reN (Number): report editor ID
    iN (Number): item ID
    aB (bool): adjusted to the page width
 
Returns:
    bool: Success : True, else Exception
reportEditorApplyTo(*args, **kwargs)
reportEditorApplyTo(reN: Number, wS: str, dS: str='') -> bool
 
Apply a dataset or well to your report
 
Args:
    reN (Number): report editor ID
    wS (str): well name
    dS (str): Optional; dataset name
 
Returns:
    bool: Success : True, else Exception
reportEditorChangeItemPage(*args, **kwargs)
reportEditorChangeItemPage(reN: Number, iN: Number, pN: Number) -> bool
 
Move an item to an other page
 
Args:
    reN (Number): report editor ID
    iN (Number): item ID
    pN (Number): page ID
 
Returns:
    bool: Success : True, else Exception
reportEditorClose(*args, **kwargs)
reportEditorClose(reN: Number) -> bool
 
Close the report editor
 
Args:
    reN (Number): report editor ID
 
Returns:
    bool: Success : True, else Exception
reportEditorCreate(*args, **kwargs)
reportEditorCreate() -> Number
 
Create a report editor
 
Returns:
    Number: report editor ID
reportEditorDeleteItem(*args, **kwargs)
reportEditorDeleteItem(reN: Number, iN: Number) -> bool
 
Delete an item of the report
 
Args:
    reN (Number): report editor ID
    iN (Number): item ID
 
Returns:
    bool: Success : True, else Exception
reportEditorDeleteItemInMasterPage(*args, **kwargs)
reportEditorDeleteItemInMasterPage(reN: Number, iN: Number) -> bool
 
Delete an item of the report
 
Args:
    reN (Number): report editor ID
    iN (Number): item ID
 
Returns:
    bool: Success : True, else Exception
reportEditorDeletePage(*args, **kwargs)
reportEditorDeletePage(reN: Number, pN: Number) -> bool
 
Delete a page of the report
 
Args:
    reN (Number): report editor ID
    pN (Number): page ID
 
Returns:
    bool: Success : True, else Exception
reportEditorDeleteSection(*args, **kwargs)
reportEditorDeleteSection(reN: Number, sN: Number) -> bool
 
Delete a section in the report
 
Args:
    reN (Number): report editor ID
    sN (Number): section ID
 
Returns:
    bool: Success : True, else Exception
reportEditorHeaderLinkToLayout(*args, **kwargs)
reportEditorHeaderLinkToLayout(reN: Number, hN: Number, lN: Number) -> bool
 
Apply layout properties to a header
 
Args:
    reN (Number): report editor ID
    hN (Number): header ID
    lN (Number): layout ID
 
Returns:
    bool: Success : True, else Exception
reportEditorInsertPage(*args, **kwargs)
reportEditorInsertPage(reN: Number, sN: Number, iN: Number, pnS: str='Page n') -> Number
 
Insert a page in an existing section
 
Args:
    reN (Number): report editor ID
    sN (Number): section ID
    iN (Number): index (0 to n - 1)
    pnS (str): Optional; page name
 
Returns:
    Number: Success : page ID, else Exception
reportEditorInsertSection(*args, **kwargs)
reportEditorInsertSection(reN: Number, iN: Number, snS: str='Section n') -> Number
 
Insert a section in the report
 
Args:
    reN (Number): report editor ID
    iN (Number): index (0 to n - 1)
    snS (str): Optional; section name
 
Returns:
    Number: Success : section ID, else Exception
reportEditorItemApplyTo(*args, **kwargs)
reportEditorItemApplyTo(reN: Number, iN: Number, dS: str='') -> bool
 
Apply a Dataset or Well to a report item
 
Args:
    reN (Number): report editor ID
    iN (Number): item ID 3. wS [string]: well name
    dS (str): Optional; dataset name
 
Returns:
    bool: Success : True, else Exception
reportEditorItemImageKeepProportions(*args, **kwargs)
reportEditorItemImageKeepProportions(reN: Number, iN: Number, kpB: bool) -> bool
 
Set the keepProportions property of an image item
 
Args:
    reN (Number): report editor ID
    iN (Number): image item ID
    kpB (bool): keeps proportions
 
Returns:
    bool: Success : True, else Exception
reportEditorItemSetAlignment(*args, **kwargs)
reportEditorItemSetAlignment(reN: Number, iN: Number, aNE: int) -> bool
 
Set item alignment
 
Args:
    reN (Number): report editor ID
    iN (Number): item ID
    aNE (int): alignment = {0 - Left, 1 - Center, 2 - Right, 3 - Justify}
 
Returns:
    bool: Success : True, else Exception
reportEditorItemSetBackgroundColor(*args, **kwargs)
reportEditorItemSetBackgroundColor(reN: Number, iN: Number, bcS: str, aB: bool=True) -> bool
 
Set item's background color
Support Qt's color system
Exemple : #RGB #RRGGBB #RRRGGGBBB #RRRRGGGGBBBB (each of R, G, and B is a single hex digit)
Exemple : steelblue gainsboro (www.w3.org/TR/SVG/types.html#ColorKeywords)
 
Args:
    reN (Number): report editor ID
    iN (Number): item ID
    bcS (str): background color
    aB (bool): Optional; activate background color
 
Returns:
    bool: Success : True, else Exception
reportEditorItemSetFontColor(*args, **kwargs)
reportEditorItemSetFontColor(reN: Number, itN: Number, fcS: str) -> bool
 
Set item's text content font color
Support Qt's color system
Exemple : #RGB #RRGGBB #RRRGGGBBB #RRRRGGGGBBBB (each of R, G, and B is a single hex digit)
Exemple : steelblue gainsboro (www.w3.org/TR/SVG/types.html#ColorKeywords)
 
Args:
    reN (Number): report editor ID
    itN (Number): item ID
    fcS (str): font color
 
Returns:
    bool: Success : True, else Exception
reportEditorItemSetFontFamily(*args, **kwargs)
reportEditorItemSetFontFamily(reN: Number, itN: Number, ffS: str) -> bool
 
Set item's font family
Check available families in the report editor toolbar
 
Args:
    reN (Number): report editor ID
    itN (Number): item ID
    ffS (str): font family
 
Returns:
    bool: Success : True, else Exception
reportEditorItemSetFontSize(*args, **kwargs)
reportEditorItemSetFontSize(reN: Number, itN: Number, fsN: Number) -> bool
 
Set item's font size
 
Args:
    reN (Number): report editor ID
    itN (Number): item ID
    fsN (Number): font size
 
Returns:
    bool: Success : True, else Exception
reportEditorItemSetFontStyle(*args, **kwargs)
reportEditorItemSetFontStyle(reN: Number, itN: Number, fsNE: int, aB: bool) -> bool
 
Set item's font style
 
Args:
    reN (Number): report editor ID
    itN (Number): item ID
    fsNE (int): font style = {0 - Bold, 1 - Italic, 2 - Underline}
    aB (bool): apply or remove chosen style
 
Returns:
    bool: Success : True, else Exception
reportEditorItemSetHeight(*args, **kwargs)
reportEditorItemSetHeight(reN: Number, iN: Number, hN: Number) -> bool
 
Set item's height attribute
 
Args:
    reN (Number): report editor ID
    iN (Number): item ID
    hN (Number): height in current unit
 
Returns:
    bool: Success : True, else Exception
reportEditorItemSetHighlightColor(*args, **kwargs)
reportEditorItemSetHighlightColor(reN: Number, itN: Number, fcS: str) -> bool
 
Set item's text content highlight color
Support Qt's color system
Exemple : #RGB #RRGGBB #RRRGGGBBB #RRRRGGGGBBBB (each of R, G, and B is a single hex digit)
Exemple : steelblue gainsboro (www.w3.org/TR/SVG/types.html#ColorKeywords)
 
Args:
    reN (Number): report editor ID
    itN (Number): item ID
    fcS (str): highlight color
 
Returns:
    bool: Success : True, else Exception
reportEditorItemSetLockState(*args, **kwargs)
reportEditorItemSetLockState(reN: Number, iN: Number, lsNE: int) -> bool
 
Set item lock state
 
Args:
    reN (Number): report editor ID
    iN (Number): item ID
    lsNE (int): lock state = {0 - No lock, 1 - Lock Position, 2 - Lock Position & Content}
 
Returns:
    bool: Success : True, else Exception
reportEditorItemSetOrientation(*args, **kwargs)
reportEditorItemSetOrientation(reN: Number, iN: Number, oNE: int) -> bool
 
Set item orientation
 
Args:
    reN (Number): report editor ID
    iN (Number): item ID
    oNE (int): orientation = {0 - 0deg, 1 - 90deg, 2 - 180deg, 3 - 270deg}
 
Returns:
    bool: Success : True, else Exception
reportEditorItemSetWidth(*args, **kwargs)
reportEditorItemSetWidth(reN: Number, iN: Number, wN: Number) -> bool
 
Set item's width attribute
 
Args:
    reN (Number): report editor ID
    iN (Number): item ID
    wN (Number): width in current unit
 
Returns:
    bool: Success : True, else Exception
reportEditorItemShowInTableOfContents(*args, **kwargs)
reportEditorItemShowInTableOfContents(reN: Number, iN: Number, sB: bool, inS: str='default') -> bool
 
Show item in table of contents
 
Args:
    reN (Number): report editor ID
    iN (Number): item ID
    sB (bool): visible
    inS (str): Optional; item name in table of contents
 
Returns:
    bool: Success : True, else Exception
reportEditorItemShowInTableOfFigures(*args, **kwargs)
reportEditorItemShowInTableOfFigures(reN: Number, iN: Number, sB: bool, inS: str='default') -> bool
 
Show item in table of figures
 
Args:
    reN (Number): report editor ID
    iN (Number): item ID
    sB (bool): visible
    inS (str): Optional; item name in table of figures
 
Returns:
    bool: Success : True, else Exception
reportEditorItemShowInTableOfTables(*args, **kwargs)
reportEditorItemShowInTableOfTables(reN: Number, iN: Number, sB: bool, inS: str='default') -> bool
 
Show item in table of tables
 
Args:
    reN (Number): report editor ID
    iN (Number): item ID
    sB (bool): visible
    inS (str): Optional; item name in table of tables
 
Returns:
    bool: Success : True, else Exception
reportEditorItemTextAutoAdjustHeight(*args, **kwargs)
reportEditorItemTextAutoAdjustHeight(reN: Number, iN: Number, aahB: bool) -> bool
 
Auto adjust item text's height
 
Args:
    reN (Number): report editor ID
    iN (Number): item ID
    aahB (bool): auto adjust height
 
Returns:
    bool: Success : True, else Exception
reportEditorItemTextSetText(*args, **kwargs)
reportEditorItemTextSetText(reN: Number, itN: Number, tcS: str) -> bool
 
Set item text's content
Can contain HTML content if compliant with Qt's rich text engine
Documentation : qt-project.org/doc/qt-4.8/richtext-html-subset.html
 
Args:
    reN (Number): report editor ID
    itN (Number): item text ID
    tcS (str): text content
 
Returns:
    bool: Success : True, else Exception
reportEditorLayoutApplyReferenceLimitation(*args, **kwargs)
reportEditorLayoutApplyReferenceLimitation(reN: Number, lN: Number, top: Number, bottom: Number) -> Number
 
Applies a depth limitation on a logview
 
Args:
    reN (Number): report editor ID
    lN (Number): layout ID
    top (Number): top reference limitation
    bottom (Number): bottom reference limitation
 
Returns:
    Number: Success : True, else Exception
reportEditorLayoutSetScale(*args, **kwargs)
reportEditorLayoutSetScale(reN: Number, lN: Number, svN: Number) -> bool
 
Set the layout's scale
 
Args:
    reN (Number): report editor ID
    lN (Number): layout ID
    svN (Number): scale value
 
Returns:
    bool: Success : True, else Exception
reportEditorLayoutShowTrackHeaderAtBottom(*args, **kwargs)
reportEditorLayoutShowTrackHeaderAtBottom(reN: Number, lN: Number, thvB: bool) -> bool
 
Show the layout's track header at bottom
 
Args:
    reN (Number): report editor ID
    lN (Number): layout ID
    thvB (bool): visible
 
Returns:
    bool: Success : True, else Exception
reportEditorListItems(*args, **kwargs)
reportEditorListItems(reportEditorId: int, itemType: int) -> int
 
Return the list of item ids in the given report id(be careful some types are equals, example histogram and Generic histogram)
 
Args:
    reportEditorId (int): report editor ID
    itemType (int): item type = { 0 - Image, 1 - Layout, 2 - Layout Template, 3 - Crossplot, 4 - Crossplot MW,
                                        6 - Crossplot AA, 7 - Crossplot Template, 8 - Histogram, 9 - Histogram MW, 10 - Histogram Template,
                                        11 - Stereonet, 12 - Lineplot, 13 - Header, 14 - Text, 15 - Generic Header,
                                        16 - Generic Layout, 17 - Generic Crossplot, 18 - Generic Histogram, 19 - Generic Stereonet, 20 - Generic Lineplot,
                                        21 - Generic Image, 22 - Generic Text, 23 - Ternary, 24 - Walkout, 25 - Cumulative Dip,
                                        26 - Single Depth, 27 - Generic Ternary, 28 - Generic Walkout, 29 - Generic Cumulative Dip, 30 - Generic Single Depth,
                                        31 - Table of Contents, 32 - Table of Figures, 33 - Tables of Tables, 34 - Crossplot AVA, 35 - Waveform,
                                        36 - Generic Waveform, 37 - Wellbore Centrid Grid, 38 - Generic Wellbore Centrid Grid, 39 - Borehole Section, 40 - Generic Borehole Section,
                                        41 - Cross section profile plot, 42 - Cross section profile plot template, 43 - Generic cross section profile plot,
                                        44 - Axial section profile plot, 45 - Axial section profile plot template, 46 - Generic axial section profile plot}
 
Returns:
    int: Success : list of item ids, else Exception
reportEditorListPages(*args, **kwargs)
reportEditorListPages(reportEditorId: int, sectionId: int) -> int
 
Return the list of page ids in the given report id for a specific section
 
Args:
    reportEditorId (int): report editor ID
    sectionId (int): section ID
 
Returns:
    int: Success : list of page ids, else Exception
reportEditorListSections(*args, **kwargs)
reportEditorListSections(reportEditorId: int) -> int
 
Return the list of section ids in the given report id
 
Args:
    reportEditorId (int): report editor ID
 
Returns:
    int: Success : list of section ids, else Exception
reportEditorMoveItem(*args, **kwargs)
reportEditorMoveItem(reN: Number, iN: Number, xN: Number, yN: Number) -> bool
 
Move an item of the report
 
Args:
    reN (Number): report editor ID
    iN (Number): item ID
    xN (Number): horizontal position in current unit
    yN (Number): vertical position in current unit
 
Returns:
    bool: Success : True, else Exception
reportEditorMoveItemInMasterPage(*args, **kwargs)
reportEditorMoveItemInMasterPage(reN: Number, iN: Number, xN: Number, yN: Number) -> bool
 
Move an item of the report
 
Args:
    reN (Number): report editor ID
    iN (Number): item ID
    xN (Number): horizontal position in current unit
    yN (Number): vertical position in current unit
 
Returns:
    bool: Success : True, else Exception
reportEditorNew(*args, **kwargs)
reportEditorNew(reN: Number) -> bool
 
Create a new report document
 
Args:
    reN (Number): report editor ID
 
Returns:
    bool: Success : True, else Exception
reportEditorOpen(*args, **kwargs)
reportEditorOpen(file: str, interactive: bool=True) -> Number
 
Open a report editor
If it is a template, popup dialog asks user to choose well and dataset to apply
unless interactive parameter is set to False
 
Args:
    file (str): file name to open
    interactive (bool): Optional; True to have interactive dialog else False
 
Returns:
    Number: report editor ID
reportEditorPageDuplicateWithID(*args, **kwargs)
reportEditorPageDuplicateWithID(reN: Number, epN: Number, sN: Number, npS: str='Page n') -> Number
 
Duplicate a page of the report with IDs
 
Args:
    reN (Number): report editor ID
    epN (Number): source page ID
    sN (Number): destination section ID (section to insert duplicated page)
    npS (str): Optional; duplicated page name
 
Returns:
    Number: Success : page ID, else Exception
reportEditorPageDuplicateWithName(*args, **kwargs)
reportEditorPageDuplicateWithName(reN: Number, esN: str, epN: str, sN: str, npS: str='Page n') -> Number
 
Duplicate a page of the report with names
 
Args:
    reN (Number): report editor ID
    esN (str): source section name
    epN (str): source page name
    sN (str): destination section name (section to insert duplicated page)
    npS (str): Optional; duplicated page name
 
Returns:
    Number: Success : page ID, else Exception
reportEditorPrint(*args, **kwargs)
reportEditorPrint(reN: Number) -> bool
 
Print a report document
 
Args:
    reN (Number): report editor ID
 
Returns:
    bool: Success : True, else Exception
reportEditorPrintIntoPDF(*args, **kwargs)
reportEditorPrintIntoPDF(reN: Number, fnS: str) -> bool
 
Print a report document into a PDF
 
Args:
    reN (Number): report editor ID
    fnS (str): report name
 
Returns:
    bool: Success : True, else Exception
reportEditorPrintIntoTiff(*args, **kwargs)
reportEditorPrintIntoTiff(reN: Number, fnS: str) -> bool
 
Print a report document into a Tiff file
 
Args:
    reN (Number): report editor ID
    fnS (str): report name
 
Returns:
    bool: Success : True, else Exception
reportEditorRenameItem(*args, **kwargs)
reportEditorRenameItem(reN: Number, iN: Number, inS: str) -> bool
 
Rename an item in the report
 
Args:
    reN (Number): report editor ID
    iN (Number): item ID
    inS (str): item name
 
Returns:
    bool: Success : True, else Exception
reportEditorRenamePage(*args, **kwargs)
reportEditorRenamePage(reN: Number, pN: Number, pnS: str) -> bool
 
Rename a page in the report
 
Args:
    reN (Number): report editor ID
    pN (Number): page ID
    pnS (str): page name
 
Returns:
    bool: Success : True, else Exception
reportEditorRenameSection(*args, **kwargs)
reportEditorRenameSection(reN: Number, sN: Number, snS: str) -> bool
 
Rename a section in the report
 
Args:
    reN (Number): report editor ID
    sN (Number): section ID
    snS (str): section name
 
Returns:
    bool: Success : True, else Exception
reportEditorSave(*args, **kwargs)
reportEditorSave(reN: Number, rnS: str, fnSE: str) -> bool
 
Save a report
 
Args:
    reN (Number): report editor ID
    rnS (str): report name
    fnSE (str): folder name = {'Project', 'User', 'Company', 'Techlog'}
 
Returns:
    bool: Success : True, else Exception
reportEditorSaveAsTemplate(*args, **kwargs)
reportEditorSaveAsTemplate(reN: Number, rnS: str, fnSE: str) -> bool
 
Save a report as a template
 
Args:
    reN (Number): report editor ID
    rnS (str): report name
    fnSE (str): folder name = {'Project', 'User', 'Company', 'Techlog'}
 
Returns:
    bool: Success : True, else Exception
reportEditorSectionSetMasterPage(*args, **kwargs)
reportEditorSectionSetMasterPage(reN: Number, s1N: Number, s2N: Number) -> bool
 
Set the master page of a section with an existing one
 
Args:
    reN (Number): report editor ID
    s1N (Number): section ID (masterpage to copy)
    s2N (Number): section ID (masterpage to set)
 
Returns:
    bool: Success : True, else Exception
reportEditorSetHorizontalMargin(*args, **kwargs)
reportEditorSetHorizontalMargin(reN: Number, sN: Number, mhN: Number) -> bool
 
Set top and bottom margin of a section
 
Args:
    reN (Number): report editor ID
    sN (Number): section ID
    mhN (Number): margin height in current unit
 
Returns:
    bool: Success : True, else Exception
reportEditorSetItemGeneric(*args, **kwargs)
reportEditorSetItemGeneric(reN: Number, itN: Number) -> bool
 
Transform an item to a generic one
 
Args:
    reN (Number): report editor ID
    itN (Number): item ID
 
Returns:
    bool: Success : True, else Exception
reportEditorSetPaperFormat(*args, **kwargs)
reportEditorSetPaperFormat(reN: Number, fNE: int) -> bool
 
Set the paper format of the report
 
Args:
    reN (Number): report editor ID
    fNE (int): paper format = { 0 - A4, 1 - B5, 2 - Letter, 3 - Legal, 4 - Executive, 5 - A0,
                                                6 - A1, 7 - A2, 8 - A3, 9 - A5, 10 - A6,
                                                11 - A7, 12 - A8, 13 - A9, 14 - B0, 15 - B1,
                                                16 - B10, 17 - B2, 18 - B3, 19 - B4, 20 - B6,
                                                21 - B7, 22 - B8, 23 - B9, 24 - C5E, 25 - Comm10E,
                                                26 - DLE, 27 - Folio, 28 - Ledger, 29 - Tabloid, 30 - Custom
 
Returns:
    bool: Success : True, else Exception
reportEditorSetRelativeItem(*args, **kwargs)
reportEditorSetRelativeItem(reN: Number, iN: Number, piN: Number) -> bool
 
Set an item relative to another one
 
Args:
    reN (Number): report editor ID
    iN (Number): item ID
    piN (Number): parent item ID
 
Returns:
    bool: Success : True, else Exception
reportEditorSetVerticalMargin(*args, **kwargs)
reportEditorSetVerticalMargin(reN: Number, sN: Number, mwN: Number) -> bool
 
Set left and right margin of a section
 
Args:
    reN (Number): report editor ID
    sN (Number): section ID
    mwN (Number): margin width in current unit
 
Returns:
    bool: Success : True, else Exception
reportEditorSetVisibleItem(*args, **kwargs)
reportEditorSetVisibleItem(reN: Number, iN: Number, vB: bool) -> bool
 
Set visibility of an item in the given editor
 
Args:
    reN (Number): report editor ID
    iN (Number): item ID
    vB (bool): visible
 
Returns:
    bool: Success : True, else Exception
reportEditorSetVisiblePage(*args, **kwargs)
reportEditorSetVisiblePage(reN: Number, pN: Number, vB: bool) -> bool
 
Set visibility of a page
 
Args:
    reN (Number): report editor ID
    pN (Number): page ID
    vB (bool): visible
 
Returns:
    bool: Success : True, else Exception
reportEditorSetVisibleSection(*args, **kwargs)
reportEditorSetVisibleSection(reN: Number, sN: Number, vB: bool) -> bool
 
Set visibility of a section
 
Args:
    reN (Number): report editor ID
    sN (Number): section ID
    vB (bool): visible
 
Returns:
    bool: Success : True, else Exception
reportEditorShowMargin(*args, **kwargs)
reportEditorShowMargin(reN: Number, mvB: bool) -> bool
 
Set margin visibility of the report
 
Args:
    reN (Number): report editor ID
    mvB (bool): visible
 
Returns:
    bool: Success : True, else Exception
reportEditorTableAddColumn(*args, **kwargs)
reportEditorTableAddColumn(reN: Number, tN: Number) -> bool
 
Add a column to the table
 
Args:
    reN (Number): report editor ID
    tN (Number): table ID
 
Returns:
    bool: Success : True, else Exception
reportEditorTableAddRow(*args, **kwargs)
reportEditorTableAddRow(reN: Number, tN: Number) -> bool
 
Add a row to a table
 
Args:
    reN (Number): report editor ID
    tN (Number): table ID
 
Returns:
    bool: Success : True, else Exception
reportEditorTableCellMerge(*args, **kwargs)
reportEditorTableCellMerge(reN: Number, tN: Number, firN: Number, ficN: Number, lirN: Number, licN: Number) -> bool
 
Merge multiple cells with indexes
 
Args:
    reN (Number): report editor ID
    tN (Number): table ID
    firN (Number): first row index
    ficN (Number): first column index
    lirN (Number): last row index
    licN (Number): last column index
 
Returns:
    bool: Success : True, else Exception
reportEditorTableCellSetAlignment(*args, **kwargs)
reportEditorTableCellSetAlignment(reN: Number, iN: Number, riN: Number, ciN: Number, aNE: int) -> bool
 
Set table cell's alignment
 
Args:
    reN (Number): report editor ID
    iN (Number): table ID
    riN (Number): row index
    ciN (Number): column index
    aNE (int): alignment = {0 - Left, 1 - Center, 2 - Right, 3 - Justify}
 
Returns:
    bool: Success : True, else Exception
reportEditorTableCellSetBackgroundColor(*args, **kwargs)
reportEditorTableCellSetBackgroundColor(reN: Number, tN: Number, riN: Number, ciN: Number, bcS: str) -> bool
 
Set table cell's background color
Support Qt's color system
Exemple : #RGB #RRGGBB #RRRGGGBBB #RRRRGGGGBBBB (each of R, G, and B is a single hex digit)
Exemple : steelblue gainsboro (www.w3.org/TR/SVG/types.html#ColorKeywords)
 
Args:
    reN (Number): report editor ID
    tN (Number): table ID
    riN (Number): row index
    ciN (Number): column index
    bcS (str): background color
 
Returns:
    bool: Success : True, else Exception
reportEditorTableCellSetFontColor(*args, **kwargs)
reportEditorTableCellSetFontColor(reN: Number, tN: Number, riN: Number, ciN: Number, fcS: str) -> bool
 
Set table cell's font color
Support Qt's color system
Exemple : #RGB #RRGGBB #RRRGGGBBB #RRRRGGGGBBBB (each of R, G, and B is a single hex digit)
Exemple : steelblue gainsboro (www.w3.org/TR/SVG/types.html#ColorKeywords)
 
Args:
    reN (Number): report editor ID
    tN (Number): table ID
    riN (Number): row index
    ciN (Number): column index
    fcS (str): font color
 
Returns:
    bool: Success : True, else Exception
reportEditorTableCellSetFontFamily(*args, **kwargs)
reportEditorTableCellSetFontFamily(reN: Number, tN: Number, riN: Number, ciN: Number, fcS: str) -> bool
 
Set table cell's font family
Check available families in the report editor toolbar
 
Args:
    reN (Number): report editor ID
    tN (Number): table ID
    riN (Number): row index
    ciN (Number): column index
    fcS (str): font family
 
Returns:
    bool: Success : True, else Exception
reportEditorTableCellSetFontSize(*args, **kwargs)
reportEditorTableCellSetFontSize(reN: Number, tN: Number, riN: Number, ciN: Number, fsN: Number) -> bool
 
Set table cell's font size
 
Args:
    reN (Number): report editor ID
    tN (Number): table ID
    riN (Number): row index
    ciN (Number): column index
    fsN (Number): font size
 
Returns:
    bool: Success : True, else Exception
reportEditorTableCellSetFontStyle(*args, **kwargs)
reportEditorTableCellSetFontStyle(reN: Number, tN: Number, riN: Number, ciN: Number, fsNE: int, aB: bool) -> bool
 
Set table cell's font style
 
Args:
    reN (Number): report editor ID
    tN (Number): table ID
    riN (Number): row index
    ciN (Number): column index
    fsNE (int): font style = {0 - Bold, 1 - Italic, 2 - Underline}
    aB (bool): apply or remove chosen style
 
Returns:
    bool: Success : True, else Exception
reportEditorTableCellSetHighlightColor(*args, **kwargs)
reportEditorTableCellSetHighlightColor(reN: Number, tN: Number, riN: Number, ciN: Number, hcS: str) -> bool
 
Set table cell's highlight color
Support Qt's color system
Exemple : #RGB #RRGGBB #RRRGGGBBB #RRRRGGGGBBBB (each of R, G, and B is a single hex digit)
Exemple : steelblue gainsboro (www.w3.org/TR/SVG/types.html#ColorKeywords)
 
Args:
    reN (Number): report editor ID
    tN (Number): table ID
    riN (Number): row index
    ciN (Number): column index
    hcS (str): highlight color
 
Returns:
    bool: Success : True, else Exception
reportEditorTableCellSetOrientation(*args, **kwargs)
reportEditorTableCellSetOrientation(reN: Number, tN: Number, riN: Number, ciN: Number, oNE: int) -> bool
 
Set table cell's text orientation
 
Args:
    reN (Number): report editor ID
    tN (Number): table ID
    riN (Number): row index
    ciN (Number): column index
    oNE (int): orientation = {0 - 0deg, 1 - 90deg, 2 - 180deg, 3 - 270deg}
 
Returns:
    bool: Success : True, else Exception
reportEditorTableCellSetText(*args, **kwargs)
reportEditorTableCellSetText(reN: Number, tN: Number, riN: Number, ciN: Number, tcS: str) -> bool
 
Set table cell's content
Can contain HTML content if compliant with Qt's rich text engine
Documentation : qt-project.org/doc/qt-4.8/richtext-html-subset.html
 
Args:
    reN (Number): report editor ID
    tN (Number): table ID
    riN (Number): row index
    ciN (Number): column index
    tcS (str): text content
 
Returns:
    bool: Success : True, else Exception
reportEditorTableDeleteColumn(*args, **kwargs)
reportEditorTableDeleteColumn(reN: Number, tN: Number, ciN: Number) -> bool
 
Delete a column in a table
 
Args:
    reN (Number): report editor ID
    tN (Number): table ID
    ciN (Number): column index (0 to n - 1)
 
Returns:
    bool: Success : True, else Exception
reportEditorTableDeleteRow(*args, **kwargs)
reportEditorTableDeleteRow(reN: Number, tN: Number, riN: Number) -> bool
 
Delete a row in a table
 
Args:
    reN (Number): report editor ID
    tN (Number): table ID
    riN (Number): row index (0 to n - 1)
 
Returns:
    bool: Success : True, else Exception
reportEditorTableInsertColumn(*args, **kwargs)
reportEditorTableInsertColumn(reN: Number, tN: Number, ciN: Number) -> bool
 
Insert a column in a table
 
Args:
    reN (Number): report editor window ID
    tN (Number): report object ID of the table
    ciN (Number): column index (0 to n - 1)
 
Returns:
    bool: Success : True, else Exception
reportEditorTableInsertRow(*args, **kwargs)
reportEditorTableInsertRow(reN: Number, tN: Number, riN: Number) -> bool
 
Insert a row in a table
 
Args:
    reN (Number): report editor ID
    tN (Number): table ID
    riN (Number): row index (0 to n - 1)
 
Returns:
    bool: Success : True, else Exception
reportEditorTableResizeColumn(*args, **kwargs)
reportEditorTableResizeColumn(reN: Number, tN: Number, ciN: Number, chN: Number) -> bool
 
Resize a column of a table
 
Args:
    reN (Number): report editor ID
    tN (Number): table ID
    ciN (Number): column index index (0 to n - 1)
    chN (Number): column width in current unit
 
Returns:
    bool: Success : True, else Exception
reportEditorTableResizeRow(*args, **kwargs)
reportEditorTableResizeRow(reN: Number, tN: Number, riN: Number, rhN: Number) -> bool
 
Resize a row of a table
 
Args:
    reN (Number): report editor ID
    tN (Number): table ID
    riN (Number): row index index (0 to n - 1)
    rhN (Number): row height in current unit
 
Returns:
    bool: Success : True, else Exception
reportEditorTableSetBorder(*args, **kwargs)
reportEditorTableSetBorder(reN: Number, tN: Number, bsN: Number, bcS: str) -> bool
 
Set the border of a table
Support Qt's color system
Exemple : #RGB #RRGGBB #RRRGGGBBB #RRRRGGGGBBBB (each of R, G, and B is a single hex digit)
Exemple : steelblue gainsboro (www.w3.org/TR/SVG/types.html#ColorKeywords)
 
Args:
    reN (Number): report editor ID
    tN (Number): table ID
    bsN (Number): border size
    bcS (str): border color
 
Returns:
    bool: Success : True, else Exception
resizeWidget(*args, **kwargs)
resizeWidget(plotID: Number, width: Number=1024, height: Number=768) -> bool
 
Resize a widget
 
Args:
    plotID (Number): window ID
    width (Number): Optional; window new Width
    height (Number): Optional; window new Height
 
Returns:
    bool: operation exit status
saveAsImage(*args, **kwargs)
saveAsImage(plotID: Number, n: str, f: str, ff: str='', mustCut: bool=False) -> bool
 
Save a cross-plot, an histogram or a logview as image
 
Args:
    plotID (Number): plot window ID
    n (str): name
    f (str): format
    ff (str): Optional; folder
    mustCut (bool): Optional; mustCut
 
Returns:
    bool: operation exit status
setBenchmarkContext(*args, **kwargs)
setBenchmarkContext(context: str)
 
set benchmark context value
 
Args:
    context (str): name
 
Returns:
setBenchmarkIteration(*args, **kwargs)
setBenchmarkIteration(iteration: Number)
 
set benchmark context value
 
Args:
    iteration (Number): number
 
Returns:
setLegendVisible(*args, **kwargs)
setLegendVisible(ID: Number, isLegendVisible: bool)
 
Display or hide the legend of the plot.
 
Args:
    ID (Number): plot widget ID
    isLegendVisible (bool): True to display the legend of the plot, else False.
setPaletteToWidget(*args, **kwargs)
setPaletteToWidget(plotID: Number, palName: str) -> bool
 
Change a palette of an existing widget
 
Args:
    plotID (Number): plot window ID
    palName (str): palette name
 
Returns:
    bool: operation exit status
spectrumAddZone(*args, **kwargs)
spectrumAddZone(plotID: Number, z: str) -> bool
 
Add a zone in the selection to the spectrum
 
Args:
    plotID (Number): spectrum window ID
    z (str): zone name
 
Returns:
    bool: operation exit status
spectrumApplyTo(*args, **kwargs)
spectrumApplyTo(plotID: Number, ds: list) -> list
 
Apply the spectrum to a data set list
 
Args:
    plotID (Number): spectrum window ID
    ds (list): dataset ID (wellName.datasetName)
 
Returns:
    list: list of plotID
spectrumCleanZonation(*args, **kwargs)
spectrumCleanZonation(plotID: Number, d: str) -> bool
 
Remove the zonation dataset from the spectrum - any display of zone must previously have been cancelled
 
Args:
    plotID (Number): spectrum window ID
    d (str): zonation dataset name
 
Returns:
    bool: operation exit status
spectrumCleanZone(*args, **kwargs)
spectrumCleanZone(plotID: Number, z: str) -> bool
 
Remove a zone in the selection from the spectrum
 
Args:
    plotID (Number): spectrum window ID
    z (str): zone name
 
Returns:
    bool: operation exit status
spectrumCreate(*args, **kwargs)
spectrumCreate(n: str, vl: list=None, f: str='') -> Number
 
Create a new spectrum
 
Args:
    n (str): spectrum window name
    vl (list): Optional; variable list
    f (str): Optional; filter variable ID
 
Returns:
    Number: spectrum window ID
spectrumDeleteColor(*args, **kwargs)
spectrumDeleteColor(plotID: Number) -> bool
 
Delete the color variable of a spectrum
 
Args:
    plotID (Number): spectrum window ID
 
Returns:
    bool: operation exit status
spectrumDeleteVariables(*args, **kwargs)
spectrumDeleteVariables(plotID: Number) -> bool
 
Delete the variable of the spectrum
 
Args:
    plotID (Number): spectrum window ID
 
Returns:
    bool: operation exit status
spectrumDuplicate(*args, **kwargs)
spectrumDuplicate(plotID: Number) -> Number
 
Duplicate the spectrum
 
Args:
    plotID (Number): spectrum window ID
 
Returns:
    Number: new plot id or -1
spectrumGetIdByName(*args, **kwargs)
spectrumGetIdByName(n: str) -> Number
 
Find the ID of a name-known spectrum
 
Args:
    n (str): spectrum name
 
Returns:
    Number: spectrum window ID
spectrumLockPalette(*args, **kwargs)
spectrumLockPalette(plotID: Number, locked: bool) -> bool
 
Lock palette of the spectrum
 
Args:
    plotID (Number): spectrum window ID
    locked (bool): True if locked, False else
 
Returns:
    bool: operation exit status
spectrumLockTitle(*args, **kwargs)
spectrumLockTitle(plotID: Number, locked: bool) -> bool
 
Lock title of the spectrum
 
Args:
    plotID (Number): spectrum window ID
    locked (bool): True if locked, False else
 
Returns:
    bool: operation exit status
spectrumMultiWellAddData(*args, **kwargs)
spectrumMultiWellAddData(plotID: Number, ds: list) -> bool
 
Add a dataset to a multi well spectrum
 
Args:
    plotID (Number): spectrum window ID
    ds (list): dataset ID (wellName.datasetName)
 
Returns:
    bool: operation exit status
spectrumMultiWellAddZone(*args, **kwargs)
spectrumMultiWellAddZone(plotID: Number, z: str) -> bool
 
Add a zone in the selection to the spectrum
 
Args:
    plotID (Number): spectrum window ID
    z (str): zone name
 
Returns:
    bool: operation exit status
spectrumMultiWellCleanZonation(*args, **kwargs)
spectrumMultiWellCleanZonation(plotID: Number, d: str) -> bool
 
Remove the zonation dataset from the spectrum - any display of zone must previously have been cancelled
 
Args:
    plotID (Number): spectrum window ID
    d (str): zonation dataset name
 
Returns:
    bool: operation exit status
spectrumMultiWellCleanZone(*args, **kwargs)
spectrumMultiWellCleanZone(plotID: Number, z: str) -> bool
 
Remove a zone in the selection from the spectrum
 
Args:
    plotID (Number): spectrum window ID
    z (str): zone name
 
Returns:
    bool: operation exit status
spectrumMultiWellCreate(*args, **kwargs)
spectrumMultiWellCreate(vl: list, c: str='', f: str='') -> Number
 
Create a new multi-well spectrum
 
Args:
    vl (list): variable list
    c (str): Optional; color variable ID
    f (str): Optional; filter variable ID
 
Returns:
    Number: spectrum window ID
spectrumMultiWellDuplicate(*args, **kwargs)
spectrumMultiWellDuplicate(plotID: Number) -> Number
 
Duplicate the spectrum
 
Args:
    plotID (Number): spectrum window ID
 
Returns:
    Number: new plot id or -1
spectrumMultiWellGetIdByName(*args, **kwargs)
spectrumMultiWellGetIdByName(n: str) -> Number
 
Find the ID of a name-known spectrum
 
Args:
    n (str): spectrum name
 
Returns:
    Number: spectrum window ID
spectrumMultiWellOpen(*args, **kwargs)
spectrumMultiWellOpen(n: str, f: str='') -> bool
 
Open an existing spectrum
 
Args:
    n (str): spectrum name
    f (str): Optional; folder
 
Returns:
    bool: operation exit status
spectrumMultiWellRemoveDataset(*args, **kwargs)
spectrumMultiWellRemoveDataset(plotID: Number, ds: str) -> bool
 
Remove a dataset from a multi well spectrum
 
Args:
    plotID (Number): spectrum window ID
    ds (str): dataset name
 
Returns:
    bool: operation exit status
spectrumMultiWellRemoveWell(*args, **kwargs)
spectrumMultiWellRemoveWell(plotID: Number, we: str) -> bool
 
Remove a well from a multi well spectrum
 
Args:
    plotID (Number): spectrum window ID
    we (str): well name
 
Returns:
    bool: operation exit status
spectrumMultiWellSave(*args, **kwargs)
spectrumMultiWellSave(plotID: Number, n: str, f: str='') -> bool
 
Save the spectrum
 
Args:
    plotID (Number): spectrum window ID
    n (str): spectrum window name
    f (str): Optional; folder
 
Returns:
    bool: operation exit status
spectrumMultiWellSelectVar(*args, **kwargs)
spectrumMultiWellSelectVar(plotID: Number, we: str, ds: str, famId: Number, vr: str) -> bool
 
[DEPRECATED] (use spectrumMultiWellSelectVariable instead) Change the variable selected among one family's variables in a multi well spectrum
 
Args:
    plotID (Number): spectrum window ID
    we (str): well name
    ds (str): dataset name
    famId (Number): ID of the family in which you wish to change variable
    vr (str): new variable name
 
Returns:
    bool: operation exit status
spectrumMultiWellSelectVariable(*args, **kwargs)
spectrumMultiWellSelectVariable(plotID: Number, we: str, ds: str, famId: Number, vr: str) -> bool
 
Change the variable selected among one family's variables in a multi well spectrum
 
Args:
    plotID (Number): spectrum window ID
    we (str): well name
    ds (str): dataset name
    famId (Number): ID of the family in which you wish to change variable
    vr (str): new variable name
 
Returns:
    bool: operation exit status
spectrumMultiWellSetAxisInverse(*args, **kwargs)
spectrumMultiWellSetAxisInverse(plotID: Number, v: str, inv: bool) -> bool
 
Inverse a spectrum variable scale
 
Args:
    plotID (Number): spectrum window ID
    v (str): variable name
    inv (bool): True if inversed, False else
 
Returns:
    bool: operation exit status
spectrumMultiWellSetAxisScale(*args, **kwargs)
spectrumMultiWellSetAxisScale(plotID: Number, v: str, sc: int) -> bool
 
Change a spectrum variable Y axis scale
 
Args:
    plotID (Number): spectrum window ID
    v (str): variable name
    sc (int): scale type {0 = 'LINEAR', 1 = 'LOGARITHMIC'}
 
Returns:
    bool: operation exit status
spectrumMultiWellSetAxisType(*args, **kwargs)
spectrumMultiWellSetAxisType(plotID: Number, v: str, t: int) -> bool
 
Change the type of a spectrum variable Y axis
 
Args:
    plotID (Number): spectrum window ID
    v (str): variable name
    t (int): X axis type {0 = 'VAR', 1 = 'USER', 2 = 'FAMILY'}
 
Returns:
    bool: operation exit status
spectrumMultiWellSetAxisUnit(*args, **kwargs)
spectrumMultiWellSetAxisUnit(plotID: Number, v: str, u: str) -> bool
 
Change the unit of a spectrum variable Y axis
 
Args:
    plotID (Number): spectrum window ID
    v (str): variable name
    u (str): X axis unit
 
Returns:
    bool: operation exit status
spectrumMultiWellSetAxisUserLimits(*args, **kwargs)
spectrumMultiWellSetAxisUserLimits(plotID: Number, v: str, min: Number, max: Number) -> bool
 
Set min & max values of a spectrum variable Y axis
 
Args:
    plotID (Number): spectrum window ID
    v (str): variable name
    min (Number): X axis minimum
    max (Number): X axis maximum
 
Returns:
    bool: operation exit status
spectrumMultiWellSetName(*args, **kwargs)
spectrumMultiWellSetName(plotID: Number, n: str) -> bool
 
Change the name of the spectrum
 
Args:
    plotID (Number): spectrum window ID
    n (str): new spectrum window name
 
Returns:
    bool: operation exit status
spectrumMultiWellSetPaletteBoundaries(*args, **kwargs)
spectrumMultiWellSetPaletteBoundaries(plotID: Number, min: Number, max: Number) -> bool
 
Set the boundaries of the palette for a multi-well spectrum plot.
 
Args:
    plotID (Number): plot window ID
    min (Number): minimum of the palette
    max (Number): maximum of the palette
 
Returns:
    bool: operation exit status
spectrumMultiWellSetZonation(*args, **kwargs)
spectrumMultiWellSetZonation(plotID: Number, d: str) -> bool
 
Set the zonation dataset to the spectrum
 
Args:
    plotID (Number): spectrum window ID
    d (str): zonation dataset name
 
Returns:
    bool: operation exit status
spectrumOpen(*args, **kwargs)
spectrumOpen(n: str, f: str='') -> bool
 
Open an existing spectrum
 
Args:
    n (str): spectrum name
    f (str): Optional; folder
 
Returns:
    bool: operation exit status
spectrumSave(*args, **kwargs)
spectrumSave(plotID: Number, n: str, f: str='') -> bool
 
Save the spectrum
 
Args:
    plotID (Number): spectrum window ID
    n (str): spectrum window name
    f (str): Optional; folder
 
Returns:
    bool: operation exit status
spectrumSelectFilter(*args, **kwargs)
spectrumSelectFilter(plotID: Number, FilterValues: list) -> bool
 
Select the filter values
 
Args:
    plotID (Number): spectrum window ID
    FilterValues (list): filter values
 
Returns:
    bool: operation exit status
spectrumSetAxisInverse(*args, **kwargs)
spectrumSetAxisInverse(plotID: Number, v: str, inv: bool) -> bool
 
Inverse a spectrum variable scale
 
Args:
    plotID (Number): spectrum window ID
    v (str): variable name
    inv (bool): True if inversed, False else
 
Returns:
    bool: operation exit status
spectrumSetAxisScale(*args, **kwargs)
spectrumSetAxisScale(plotID: Number, v: str, sc: int) -> bool
 
Change a spectrum variable axis scale
 
Args:
    plotID (Number): spectrum window ID
    v (str): variable name
    sc (int): scale type {0 = 'LINEAR', 1 = 'LOGARITHMIC'}
 
Returns:
    bool: operation exit status
spectrumSetAxisType(*args, **kwargs)
spectrumSetAxisType(plotID: Number, v: str, t: int) -> bool
 
Change the type of a spectrum variable axis
 
Args:
    plotID (Number): spectrum window ID
    v (str): variable name
    t (int): axis type {0 = 'VAR', 1 = 'USER', 2 = 'FAMILY'}
 
Returns:
    bool: operation exit status
spectrumSetAxisUnit(*args, **kwargs)
spectrumSetAxisUnit(plotID: Number, v: str, u: str) -> bool
 
Change the unit of a spectrum variable axis
 
Args:
    plotID (Number): spectrum window ID
    v (str): variable name
    u (str): axis unit
 
Returns:
    bool: operation exit status
spectrumSetAxisUserLimits(*args, **kwargs)
spectrumSetAxisUserLimits(plotID: Number, v: str, min: Number, max: Number) -> bool
 
Set min & max values of a spectrum variable axis
 
Args:
    plotID (Number): spectrum window ID
    v (str): variable name
    min (Number): axis minimum
    max (Number): axis maximum
 
Returns:
    bool: operation exit status
spectrumSetColor(*args, **kwargs)
spectrumSetColor(plotID: Number, color: str) -> bool
 
Set the color variable of the spectrum
 
Args:
    plotID (Number): spectrum window ID
    color (str): variable name
 
Returns:
    bool: operation exit status
spectrumSetDatum(*args, **kwargs)
spectrumSetDatum(plotID: Number, lim: bool, min: Number=0, max: Number=0) -> bool
 
Change the reference limitation on spectrum
 
Args:
    plotID (Number): spectrum window ID
    lim (bool): True for user's limitation, False else
    min (Number): Optional; top limit
    max (Number): Optional; bottom limit
 
Returns:
    bool: operation exit status
spectrumSetFilter(*args, **kwargs)
spectrumSetFilter(plotID: Number, f: str) -> bool
 
Set the variable as a filter
 
Args:
    plotID (Number): spectrum window ID
    f (str): variable filter
 
Returns:
    bool: operation exit status
spectrumSetName(*args, **kwargs)
spectrumSetName(plotID: Number, n: str) -> bool
 
Change the name of the spectrum
 
Args:
    plotID (Number): spectrum window ID
    n (str): new spectrum window name
 
Returns:
    bool: operation exit status
spectrumSetPaletteBoundaries(*args, **kwargs)
spectrumSetPaletteBoundaries(plotID: Number, min: Number, max: Number) -> bool
 
Set the boundaries of the palette for a spectrum plot.
 
Args:
    plotID (Number): plot window ID
    min (Number): minimum of the palette
    max (Number): maximum of the palette
 
Returns:
    bool: operation exit status
spectrumSetVariablesList(*args, **kwargs)
spectrumSetVariablesList(plotID: Number, vn: list) -> bool
 
Set the variable list to the spectrum
 
Args:
    plotID (Number): spectrum window ID
    vn (list): variable list
 
Returns:
    bool: operation exit status
spectrumSetZonation(*args, **kwargs)
spectrumSetZonation(plotID: Number, d: str) -> bool
 
Set the zonation dataset to the spectrum
 
Args:
    plotID (Number): spectrum window ID
    d (str): zonation dataset name
 
Returns:
    bool: operation exit status
starPlotOpen(*args, **kwargs)
starPlotOpen(n: str, f: str='') -> bool
 
Open an existing star plot
 
Args:
    n (str): star plot name
    f (str): Optional; folder
 
Returns:
    bool: operation exit status
stereonetAddZone(*args, **kwargs)
stereonetAddZone(plotID: Number, z: str) -> bool
 
Add a zone in the selection to the stereonet
 
Args:
    plotID (Number): stereonet window ID
    z (str): zone name
 
Returns:
    bool: operation exit status
stereonetApplyTo(*args, **kwargs)
stereonetApplyTo(plotID: Number, ds: list) -> list
 
Apply the stereonet to a data set list
 
Args:
    plotID (Number): stereonet window ID
    ds (list): dataset ID (wellName.datasetName)
 
Returns:
    list: list of plotID
stereonetCleanZonation(*args, **kwargs)
stereonetCleanZonation(plotID: Number, d: str) -> bool
 
Remove the zonation dataset from the stereonet - any display of zone must previously be cancelled
 
Args:
    plotID (Number): stereonet window ID
    d (str): zonation dataset name
 
Returns:
    bool: operation exit status
stereonetCleanZone(*args, **kwargs)
stereonetCleanZone(plotID: Number, z: str) -> bool
 
Remove a zone in the selection from the stereonet
 
Args:
    plotID (Number): stereonet window ID
    z (str): zone name
 
Returns:
    bool: operation exit status
stereonetColorMode(*args, **kwargs)
stereonetColorMode(plotID: Number, dm: int) -> bool
 
Display of the color mode on stereonet
 
Args:
    plotID (Number): stereonet window ID
    dm (int): color mode{0 = 'TYPE_PALET', 1 = 'TYPE_WELL', 2 = 'TYPE_ZONATION'}
 
Returns:
    bool: operation exit status
stereonetCreate(*args, **kwargs)
stereonetCreate(n: str, dip: str='', azimuth: str='', color: str='', filter: str='') -> Number
 
Create a new stereonet
 
Args:
    n (str): stereonet window name
    dip (str): Optional; variable name
    azimuth (str): Optional; variable name
    color (str): Optional; variable name
    filter (str): Optional; variable name
 
Returns:
    Number: stereonet window ID
stereonetDeleteAzimuth(*args, **kwargs)
stereonetDeleteAzimuth(plotID: Number) -> bool
 
Delete the azimuth variable of a stereonet
 
Args:
    plotID (Number): stereonet window ID
 
Returns:
    bool: operation exit status
stereonetDeleteColor(*args, **kwargs)
stereonetDeleteColor(plotID: Number) -> bool
 
Delete the color variable of a stereonet
 
Args:
    plotID (Number): stereonet window ID
 
Returns:
    bool: operation exit status
stereonetDeleteDip(*args, **kwargs)
stereonetDeleteDip(plotID: Number) -> bool
 
Delete the dip variable of a stereonet
 
Args:
    plotID (Number): stereonet window ID
 
Returns:
    bool: operation exit status
stereonetDeleteFilter(*args, **kwargs)
stereonetDeleteFilter(plotID: Number) -> bool
 
Delete the filter variable of a stereonet
 
Args:
    plotID (Number): stereonet window ID
 
Returns:
    bool: operation exit status
stereonetDensityGridX(*args, **kwargs)
stereonetDensityGridX(plotID: Number, dgx: Number) -> bool
 
Set the density grid X size on stereonet
 
Args:
    plotID (Number): stereonet window ID
    dgx (Number): size value
 
Returns:
    bool: operation exit status
stereonetDensityGridY(*args, **kwargs)
stereonetDensityGridY(plotID: Number, dgy: Number) -> bool
 
Set the density grid Y size on stereonet
 
Args:
    plotID (Number): stereonet window ID
    dgy (Number): size value
 
Returns:
    bool: operation exit status
stereonetDensityMethod(*args, **kwargs)
stereonetDensityMethod(plotID: Number, dm: int) -> bool
 
Display of the density method on stereonet
 
Args:
    plotID (Number): stereonet window ID
    dm (int): density method {0 = 'DENSITY_CONTOUR_KAMB', 1 = 'DENSITY_CONTOUR_1_PERCENT_AREA'}
 
Returns:
    bool: operation exit status
stereonetDensityOpacityActivate(*args, **kwargs)
stereonetDensityOpacityActivate(plotID: Number, doa: bool) -> bool
 
Set if the density opacity is activate or not on stereonet
 
Args:
    plotID (Number): stereonet window ID
    doa (bool): 1 = activate, else 0
 
Returns:
    bool: operation exit status
stereonetDensityOpacityValue(*args, **kwargs)
stereonetDensityOpacityValue(plotID: Number, dov: Number) -> bool
 
Set the density opacity value on stereonet
 
Args:
    plotID (Number): stereonet window ID
    dov (Number): opacity value
 
Returns:
    bool: operation exit status
stereonetDensitySigma(*args, **kwargs)
stereonetDensitySigma(plotID: Number, sig: Number) -> bool
 
Set the density sigma on stereonet
 
Args:
    plotID (Number): stereonet window ID
    sig (Number): sigma value
 
Returns:
    bool: operation exit status
stereonetDensitySmoothMode(*args, **kwargs)
stereonetDensitySmoothMode(plotID: Number, dsm: int) -> bool
 
Set the density smooth mode on stereonet
 
Args:
    plotID (Number): stereonet window ID
    dsm (int): density smooth mode {0 = 'DENSITY_SMOOTH_NONE', 1 = 'DENSITY_SMOOTH_AREA', 2 = 'DENSITY_SMOOTH_AREA_SQUARE'}
 
Returns:
    bool: operation exit status
stereonetDensityType(*args, **kwargs)
stereonetDensityType(plotID: Number, dst: bool=False) -> bool
 
Display of the stereonet in normal or density type
 
Args:
    plotID (Number): stereonet window ID
    dst (bool): Optional; 1 = density display, else 0
 
Returns:
    bool: operation exit status
stereonetDensityValue(*args, **kwargs)
stereonetDensityValue(plotID: Number, value: bool, percent: bool=False) -> bool
 
Display of data density values
 
Args:
    plotID (Number): stereonet window ID
    value (bool): 1 = display of density value else 0
    percent (bool): Optional; 1 = display in percent else 0
 
Returns:
    bool: operation exit status
stereonetDisplayType(*args, **kwargs)
stereonetDisplayType(plotID: Number, dt: int) -> bool
 
Change the display type on stereonet
 
Args:
    plotID (Number): stereonet window ID
    dt (int): display type {0 = 'TYPE_POLAR', 1 = 'TYPE_ROSE', 2 = 'TYPE_SCHMIDT', 3 = 'TYPE_WULFF'}
 
Returns:
    bool: operation exit status
stereonetDuplicate(*args, **kwargs)
stereonetDuplicate(plotID: Number) -> Number
 
Duplicate the stereonet
 
Args:
    plotID (Number): stereonet window ID
 
Returns:
    Number: new plot id or -1
stereonetGetIdByName(*args, **kwargs)
stereonetGetIdByName(n: str) -> Number
 
Find the ID of a name-known stereonet
 
Args:
    n (str): stereonet name
 
Returns:
    Number: stereonet window ID
stereonetGetInteractionGreatCircles(*args, **kwargs)
stereonetGetInteractionGreatCircles(plotID: Number) -> list
 
Get the list of poles for great circles by interaction on a stereonet
 
Args:
    plotID (Number): stereonet window ID
 
Returns:
    list: list of azimuth,dip tuples
stereonetGridStep(*args, **kwargs)
stereonetGridStep(plotID: Number, gs: Number) -> bool
 
Change the grid step on stereonet
 
Args:
    plotID (Number): stereonet window ID
    gs (Number): grid step in [6, 10, 12, 20, 30, 36]
 
Returns:
    bool: operation exit status
stereonetGridType(*args, **kwargs)
stereonetGridType(plotID: Number, gt: int) -> bool
 
Change the grid type on stereonet
 
Args:
    plotID (Number): stereonet window ID
    gt (int): grid type {0 = 'NONE', 1 = 'SIMPLE', 2 = 'FULL'}
 
Returns:
    bool: operation exit status
stereonetHistogramAlpha(*args, **kwargs)
stereonetHistogramAlpha(plotID: Number, a: Number) -> bool
 
Set the histogram opacity on stereonet
 
Args:
    plotID (Number): stereonet window ID
    a (Number): alpha
 
Returns:
    bool: operation exit status
stereonetHistogramColor(*args, **kwargs)
stereonetHistogramColor(plotID: Number, r: Number, g: Number, b: Number) -> bool
 
Set the histogram color on stereonet
 
Args:
    plotID (Number): stereonet window ID
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
stereonetHistogramColour(*args, **kwargs)
stereonetHistogramColour(plotID: Number, r: Number, g: Number, b: Number) -> bool
 
[DEPRECATED] (use stereonetHistogramColor instead) Set the histogram color on stereonet
 
Args:
    plotID (Number): stereonet window ID
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
stereonetHistogramCumulated(*args, **kwargs)
stereonetHistogramCumulated(plotID: Number, c: bool=True) -> bool
 
Set if the histogram is cumulated or not on stereonet
 
Args:
    plotID (Number): stereonet window ID
    c (bool): Optional; 1 = cumulated, else 0
 
Returns:
    bool: operation exit status
stereonetHistogramGraduation(*args, **kwargs)
stereonetHistogramGraduation(plotID: Number, grad: Number) -> bool
 
Set the histogram graduation on stereonet
 
Args:
    plotID (Number): stereonet window ID
    grad (Number): graduation value
 
Returns:
    bool: operation exit status
stereonetHistogramLimitType(*args, **kwargs)
stereonetHistogramLimitType(plotID: Number, lt: int) -> bool
 
Set the histogram limit type on stereonet
 
Args:
    plotID (Number): stereonet window ID
    lt (int): limit type {0 = 'VAR', 1 = 'USER'}
 
Returns:
    bool: operation exit status
stereonetHistogramMode(*args, **kwargs)
stereonetHistogramMode(plotID: Number, hm: int) -> bool
 
Set the histogram mode on stereonet
 
Args:
    plotID (Number): stereonet window ID
    hm (int): histogram mode {0 = 'HISTO_BY_VARIABLE', 1 = 'HISTO_BY_FILTER', 2 = 'HISTO_BY_ZONE'}
 
Returns:
    bool: operation exit status
stereonetHistogramNormalized(*args, **kwargs)
stereonetHistogramNormalized(plotID: Number, n: bool=True) -> bool
 
Set if the histogram is normalized or not on stereonet
 
Args:
    plotID (Number): stereonet window ID
    n (bool): Optional; 1 = normalized, else 0
 
Returns:
    bool: operation exit status
stereonetHistogramUserMax(*args, **kwargs)
stereonetHistogramUserMax(plotID: Number, uvm: Number) -> bool
 
Set the histogram user maximum value on stereonet
 
Args:
    plotID (Number): stereonet window ID
    uvm (Number): maximum value
 
Returns:
    bool: operation exit status
stereonetHistogramUserMin(*args, **kwargs)
stereonetHistogramUserMin(plotID: Number, uvm: Number) -> bool
 
Set the histogram user minimum value on stereonet
 
Args:
    plotID (Number): stereonet window ID
    uvm (Number): minimum value
 
Returns:
    bool: operation exit status
stereonetHistogramUserMinMax(*args, **kwargs)
stereonetHistogramUserMinMax(plotID: Number, uvmin: Number, uvmax: Number) -> bool
 
Set the histogram user minimum and maximum value on stereonet
 
Args:
    plotID (Number): stereonet window ID
    uvmin (Number): minimum value
    uvmax (Number): maximum value
 
Returns:
    bool: operation exit status
stereonetLockTitle(*args, **kwargs)
stereonetLockTitle(plotID: Number, locked: bool) -> bool
 
Lock title of the stereonet
 
Args:
    plotID (Number): stereonet window ID
    locked (bool): True if locked, False else
 
Returns:
    bool: operation exit status
stereonetMarkersAlpha(*args, **kwargs)
stereonetMarkersAlpha(plotID: Number, a: Number) -> bool
 
Set the makers opacity on stereonet
 
Args:
    plotID (Number): stereonet window ID
    a (Number): alpha
 
Returns:
    bool: operation exit status
stereonetMarkersColor(*args, **kwargs)
stereonetMarkersColor(plotID: Number, r: Number, g: Number, b: Number) -> bool
 
Set the makers color on stereonet
 
Args:
    plotID (Number): stereonet window ID
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
stereonetMarkersColour(*args, **kwargs)
stereonetMarkersColour(plotID: Number, r: Number, g: Number, b: Number) -> bool
 
[DEPRECATED] (use stereonetMarkersColor instead) Set the makers color on stereonet
 
Args:
    plotID (Number): stereonet window ID
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
stereonetMarkersSize(*args, **kwargs)
stereonetMarkersSize(plotID: Number, s: Number) -> bool
 
Set the makers size on stereonet
 
Args:
    plotID (Number): stereonet window ID
    s (Number): size
 
Returns:
    bool: operation exit status
stereonetOpen(*args, **kwargs)
stereonetOpen(n: str, f: str='') -> bool
 
Open an existing stereonet
 
Args:
    n (str): stereonet name
    f (str): Optional; folder
 
Returns:
    bool: operation exit status
stereonetProjectionHemisphere(*args, **kwargs)
stereonetProjectionHemisphere(plotID: Number, ph: int) -> bool
 
Change the projection hemisphere on stereonet
 
Args:
    plotID (Number): stereonet window ID
    ph (int): projection hemisphere {0 = 'LOWER_HEMISPHERE', 1 = 'UPPER_HEMISPHERE'}
 
Returns:
    bool: operation exit status
stereonetProjectionType(*args, **kwargs)
stereonetProjectionType(plotID: Number, pt: int) -> bool
 
Change the projection type on stereonet
 
Args:
    plotID (Number): stereonet window ID
    pt (int): projection type {0 = 'TYPE_LINE', 1 = 'TYPE_PLANE', 2 = 'TYPE_POLE', 3 = 'TYPE_PLANE_AND_POLE'}
 
Returns:
    bool: operation exit status
stereonetRoseType(*args, **kwargs)
stereonetRoseType(plotID: Number, rt: int) -> bool
 
Change the rose type on stereonet
 
Args:
    plotID (Number): stereonet window ID
    rt (int): rose type {0 = 'ROSE_AZIMUTH', 1 = 'ROSE_AZIMUTH_MIRROR', 2 = 'ROSE_STRIKE', 3 = 'ROSE_NONE'}
 
Returns:
    bool: operation exit status
stereonetSave(*args, **kwargs)
stereonetSave(plotID: Number, n: str, f: str='') -> bool
 
Save the stereonet
 
Args:
    plotID (Number): stereonet window ID
    n (str): stereonet window name
    f (str): Optional; folder
 
Returns:
    bool: operation exit status
stereonetSelectFilter(*args, **kwargs)
stereonetSelectFilter(plotID: Number, FilterValues: list) -> bool
 
Select the filter values
 
Args:
    plotID (Number): stereonet window ID
    FilterValues (list): filter values
 
Returns:
    bool: operation exit status
stereonetSetAzimuth(*args, **kwargs)
stereonetSetAzimuth(plotID: Number, azimuth: str) -> bool
 
Set the azimuth variable of a stereonet
 
Args:
    plotID (Number): stereonet window ID
    azimuth (str): variable name
 
Returns:
    bool: operation exit status
stereonetSetColor(*args, **kwargs)
stereonetSetColor(plotID: Number, color: str) -> bool
 
Set the color variable of a stereonet
 
Args:
    plotID (Number): stereonet window ID
    color (str): variable name
 
Returns:
    bool: operation exit status
stereonetSetDip(*args, **kwargs)
stereonetSetDip(plotID: Number, dip: str) -> bool
 
Set the dip variable of a stereonet
 
Args:
    plotID (Number): stereonet window ID
    dip (str): variable name
 
Returns:
    bool: operation exit status
stereonetSetFilter(*args, **kwargs)
stereonetSetFilter(plotID: Number, filter: str) -> bool
 
Set the filter variable of a stereonet
 
Args:
    plotID (Number): stereonet window ID
    filter (str): variable name
 
Returns:
    bool: operation exit status
stereonetSetInteractionGreatCircles(*args, **kwargs)
stereonetSetInteractionGreatCircles(plotID: Number, displayGreatCircles: bool)
 
display or not great circles by interaction on a stereonet
 
Args:
    plotID (Number): stereonet window ID
    displayGreatCircles (bool): display great circles by iteration
stereonetSetName(*args, **kwargs)
stereonetSetName(plotID: Number, n: str) -> bool
 
Change the name of the stereonet
 
Args:
    plotID (Number): stereonet window ID
    n (str): new stereonet plot windows name
 
Returns:
    bool: operation exit status
stereonetSetPaletteBoundaries(*args, **kwargs)
stereonetSetPaletteBoundaries(plotID: Number, min: Number, max: Number) -> bool
 
Set the boundaries of the palette for a stereonet plot.
 
Args:
    plotID (Number): plot window ID
    min (Number): minimum of the palette
    max (Number): maximum of the palette
 
Returns:
    bool: operation exit status
stereonetSetZonation(*args, **kwargs)
stereonetSetZonation(plotID: Number, d: str) -> bool
 
Set the zonation dataset to the stereonet
 
Args:
    plotID (Number): stereonet window ID
    d (str): zonation dataset name
 
Returns:
    bool: operation exit status
ternaryPlotCreate(*args, **kwargs)
ternaryPlotCreate(n: str, xn: str='', yn: str='', zn: str='', c: str='', f: str='') -> Number
 
Create a new ternary plot
 
Args:
    n (str): ternary plot window name
    xn (str): Optional; bottom axis variable name
    yn (str): Optional; left axis variable name
    zn (str): Optional; right axis variable name
    c (str): Optional; color variable name
    f (str): Optional; filter variable name
 
Returns:
    Number: ternary plot window ID
ternaryPlotDeleteBottomAxe(*args, **kwargs)
ternaryPlotDeleteBottomAxe(plotID: Number) -> bool
 
Delete the bottom axis variable of an existing ternary plot
 
Args:
    plotID (Number): ternary plot window ID
 
Returns:
    bool: operation exit status
ternaryPlotDeleteColor(*args, **kwargs)
ternaryPlotDeleteColor(plotID: Number) -> bool
 
Delete the color variable of an existing ternary plot
 
Args:
    plotID (Number): ternary plot window ID
 
Returns:
    bool: operation exit status
ternaryPlotDeleteFilter(*args, **kwargs)
ternaryPlotDeleteFilter(plotID: Number) -> bool
 
Delete the filter of an existing ternary plot
 
Args:
    plotID (Number): ternary plot window ID
 
Returns:
    bool: operation exit status
ternaryPlotDeleteLeftAxe(*args, **kwargs)
ternaryPlotDeleteLeftAxe(plotID: Number) -> bool
 
Delete the left axis variable of an existing ternary plot
 
Args:
    plotID (Number): ternary plot window ID
 
Returns:
    bool: operation exit status
ternaryPlotDeleteRightAxe(*args, **kwargs)
ternaryPlotDeleteRightAxe(plotID: Number) -> bool
 
Delete the right axis variable of an existing ternary plot
 
Args:
    plotID (Number): ternary plot window ID
 
Returns:
    bool: operation exit status
ternaryPlotDuplicate(*args, **kwargs)
ternaryPlotDuplicate(plotID: Number) -> Number
 
Duplicate an existing ternary plot
 
Args:
    plotID (Number): ternary plot window ID
 
Returns:
    Number: new plot id or -1
ternaryPlotIDFindByName(*args, **kwargs)
ternaryPlotIDFindByName(n: str) -> Number
 
Find the ID of a name-known ternary plot
 
Args:
    n (str): ternary plot window name
 
Returns:
    Number: ternary plot window ID
ternaryPlotOpen(*args, **kwargs)
ternaryPlotOpen(n: str, f: str='') -> Number
 
Open an existing ternary plot
 
Args:
    n (str): ternary plot name
    f (str): Optional; folder
 
Returns:
    Number: plot ID
ternaryPlotSave(*args, **kwargs)
ternaryPlotSave(plotID: Number, n: str, f: str='') -> bool
 
Save the ternary plot
 
Args:
    plotID (Number): ternary plot window ID
    n (str): ternary plot name
    f (str): Optional; folder
 
Returns:
    bool: operation exit status
ternaryPlotSelectFilter(*args, **kwargs)
ternaryPlotSelectFilter(plotID: Number, FilterValues: list) -> bool
 
Select the filter values
 
Args:
    plotID (Number): ternary plot window ID
    FilterValues (list): filter values
 
Returns:
    bool: operation exit status
ternaryPlotSetBottomAxe(*args, **kwargs)
ternaryPlotSetBottomAxe(plotID: Number, var: str) -> bool
 
Set the variable for the bottom axis in a ternary plot
 
Args:
    plotID (Number): ternary plot window ID
    var (str): bottom axis variable name
 
Returns:
    bool: operation exit status
ternaryPlotSetColor(*args, **kwargs)
ternaryPlotSetColor(plotID: Number, var: str) -> bool
 
Set the variable for the color axis in a ternary plot
 
Args:
    plotID (Number): ternary plot window ID
    var (str): color variable name
 
Returns:
    bool: operation exit status
ternaryPlotSetFilter(*args, **kwargs)
ternaryPlotSetFilter(plotID: Number, var: str) -> bool
 
Set the variable for the filter in a ternary plot
 
Args:
    plotID (Number): ternary plot window ID
    var (str): filter variable name
 
Returns:
    bool: operation exit status
ternaryPlotSetLeftAxe(*args, **kwargs)
ternaryPlotSetLeftAxe(plotID: Number, var: str) -> bool
 
Set the variable for the left axis in a ternary plot
 
Args:
    plotID (Number): ternary plot window ID
    var (str): left axis variable name
 
Returns:
    bool: operation exit status
ternaryPlotSetPaletteBoundaries(*args, **kwargs)
ternaryPlotSetPaletteBoundaries(plotID: Number, min: Number, max: Number) -> bool
 
Set the boundaries of the palette for a ternary plot.
 
Args:
    plotID (Number): plot window ID
    min (Number): minimum of the palette
    max (Number): maximum of the palette
 
Returns:
    bool: operation exit status
ternaryPlotSetRightAxe(*args, **kwargs)
ternaryPlotSetRightAxe(plotID: Number, var: str) -> bool
 
Set the variable for the right axis in a ternary plot
 
Args:
    plotID (Number): ternary plot window ID
    var (str): right axis variable name
 
Returns:
    bool: operation exit status
vue3DCreate(*args, **kwargs)
vue3DCreate() -> Number
 
Create an 3D vue instance
 
Returns:
    Number: plot ID
vue3DCreateReservoir(*args, **kwargs)
vue3DCreateReservoir(plotID: Number, point_list: float, color: int, LineThickness: int) -> bool
 
Create 3D box to represent reservoir
 
Args:
    plotID (Number): plot window ID
    point_list (float): list of points in format XYZ
    color (int): color
    LineThickness (int): thickness of line
 
Returns:
    bool: operation exit status
vue3DCreateWBCG(*args, **kwargs)
vue3DCreateWBCG(plotID: Number, wellname: str, dataset: str, variables: list, orientation: Number)
 
Create a new WBCG inside 3DVue
 
Args:
    plotID (Number): plot window ID
    wellname (str): name of well
    dataset (str): name of dataset
    variables (list): name of variable you want to use
    orientation (Number): 0 - Top of hole, 1 - To the North, 2 - Undefined
vue3DOpen(*args, **kwargs)
vue3DOpen(n: str, f: str=None) -> Number
 
Open an existing 3D vue
 
Args:
    n (str): plot name
    f (str): Optional; folder
 
Returns:
    Number: plot ID
vue3DRemoveReservoir(*args, **kwargs)
vue3DRemoveReservoir(plotID: Number) -> bool
 
Remove reservoir representation
 
Args:
    plotID (Number): plot window ID
 
Returns:
    bool: operation exit status
vue3DSave(*args, **kwargs)
vue3DSave(plotID: Number, filename: str)
 
Save 3DVue
 
Args:
    plotID (Number): plot window ID
    filename (str): filename (warning override automatic)
walkoutPlotAddZone(*args, **kwargs)
walkoutPlotAddZone(plotID: Number, z: str) -> bool
 
Add a zone in the selection to the walkout-plot
 
Args:
    plotID (Number): plot window ID
    z (str): zone name
 
Returns:
    bool: operation exit status
walkoutPlotApplyTo(*args, **kwargs)
walkoutPlotApplyTo(plotID: Number, ds: list) -> list
 
Apply the walkout-plot to a data set list
 
Args:
    plotID (Number): plot window ID
    ds (list): dataset ID (wellName.datasetName)
 
Returns:
    list: list of plotID
walkoutPlotCleanZonation(*args, **kwargs)
walkoutPlotCleanZonation(plotID: Number, d: str) -> bool
 
Remove the zonation dataset from the walkout-plot - any display of zone must previously be cancelled
 
Args:
    plotID (Number): plot window ID
    d (str): zonation dataset name
 
Returns:
    bool: operation exit status
walkoutPlotCleanZone(*args, **kwargs)
walkoutPlotCleanZone(plotID: Number, z: str) -> bool
 
Remove a zone in the selection from the walkout-plot
 
Args:
    plotID (Number): plot window ID
    z (str): zone name
 
Returns:
    bool: operation exit status
walkoutPlotCreate(*args, **kwargs)
walkoutPlotCreate(n: str, dip: str='', azimuth: str='', color: str='', filter: str='') -> Number
 
Create a new walkout-plot
 
Args:
    n (str): plot window name
    dip (str): Optional; variable name
    azimuth (str): Optional; variable name
    color (str): Optional; variable name
    filter (str): Optional; variable name
 
Returns:
    Number: plot window ID
walkoutPlotDeleteAzimuth(*args, **kwargs)
walkoutPlotDeleteAzimuth(plotID: Number) -> bool
 
Delete the azimuth variable of a walkout-plot
 
Args:
    plotID (Number): plot window ID
 
Returns:
    bool: operation exit status
walkoutPlotDeleteColor(*args, **kwargs)
walkoutPlotDeleteColor(plotID: Number) -> bool
 
Delete the color variable of a walkout-plot
 
Args:
    plotID (Number): plot window ID
 
Returns:
    bool: operation exit status
walkoutPlotDeleteDip(*args, **kwargs)
walkoutPlotDeleteDip(plotID: Number) -> bool
 
Delete the dip variable of a walkout-plot
 
Args:
    plotID (Number): plot window ID
 
Returns:
    bool: operation exit status
walkoutPlotDeleteFilter(*args, **kwargs)
walkoutPlotDeleteFilter(plotID: Number) -> bool
 
Delete the filter variable of a walkout-plot
 
Args:
    plotID (Number): plot window ID
 
Returns:
    bool: operation exit status
walkoutPlotDuplicate(*args, **kwargs)
walkoutPlotDuplicate(plotID: Number) -> Number
 
Duplicate the walkout-plot
 
Args:
    plotID (Number): plot window ID
 
Returns:
    Number: new plot id or -1
walkoutPlotGetIdByName(*args, **kwargs)
walkoutPlotGetIdByName(n: str) -> Number
 
Find the ID of a name-known walkout-plot
 
Args:
    n (str): plot name
 
Returns:
    Number: plot window ID
walkoutPlotLockTitle(*args, **kwargs)
walkoutPlotLockTitle(plotID: Number, locked: bool) -> bool
 
Lock title of the walkout-plot
 
Args:
    plotID (Number): plot window ID
    locked (bool): True if locked, False else
 
Returns:
    bool: operation exit status
walkoutPlotOpen(*args, **kwargs)
walkoutPlotOpen(n: str, f: str=None) -> Number
 
Open an existing walkout-plot
 
Args:
    n (str): plot name
    f (str): Optional; folder
 
Returns:
    Number: plot ID
walkoutPlotOpenCumulativeDipPlot(*args, **kwargs)
walkoutPlotOpenCumulativeDipPlot(plotID: Number) -> Number
 
Open a cumulative dip plot
 
Args:
    plotID (Number): walkout-plot window ID
 
Returns:
    Number: cumulative dip-plot window ID
walkoutPlotSave(*args, **kwargs)
walkoutPlotSave(plotID: Number, n: str, f: str='') -> bool
 
Save the walkout-plot
 
Args:
    plotID (Number): plot window ID
    n (str): file name
    f (str): Optional; folder
 
Returns:
    bool: operation exit status
walkoutPlotSelectFilter(*args, **kwargs)
walkoutPlotSelectFilter(plotID: Number, FilterValues: list) -> bool
 
Select the filter values
 
Args:
    plotID (Number): plot window ID
    FilterValues (list): filter values
 
Returns:
    bool: operation exit status
walkoutPlotSetAutomaticAdjustment(*args, **kwargs)
walkoutPlotSetAutomaticAdjustment(plotID: Number, b: bool) -> bool
 
Set the automatic adjustment on walkout-plot
 
Args:
    plotID (Number): plot window ID
    b (bool): True for automatic adjustment, False else
 
Returns:
    bool: operation exit status
walkoutPlotSetAzimuth(*args, **kwargs)
walkoutPlotSetAzimuth(plotID: Number, azimuth: str) -> bool
 
Set the azimuth variable of a walkout-plot
 
Args:
    plotID (Number): plot window ID
    azimuth (str): variable name
 
Returns:
    bool: operation exit status
walkoutPlotSetColor(*args, **kwargs)
walkoutPlotSetColor(plotID: Number, color: str) -> bool
 
Set the color variable of a walkout-plot
 
Args:
    plotID (Number): plot window ID
    color (str): variable name
 
Returns:
    bool: operation exit status
walkoutPlotSetColorMode(*args, **kwargs)
walkoutPlotSetColorMode(plotID: Number, mode: str='BY PALETTE') -> bool
 
Set the color mode on walkout-plot
 
Args:
    plotID (Number): plot window ID
    mode (str): Optional; color mode {'BY PALETTE', 'BY SOURCE', 'BY ZONE'}
 
Returns:
    bool: operation exit status
walkoutPlotSetColourMode(*args, **kwargs)
walkoutPlotSetColourMode(plotID: Number, mode: str='BY PALETTE') -> bool
 
[DEPRECATED] (use walkoutPlotSetColorMode instead) Set the color mode on walkout-plot
 
Args:
    plotID (Number): plot window ID
    mode (str): Optional; color mode {'BY PALETTE', 'BY SOURCE', 'BY ZONE'}
 
Returns:
    bool: operation exit status
walkoutPlotSetContoursMargin(*args, **kwargs)
walkoutPlotSetContoursMargin(plotID: Number, i: Number) -> bool
 
Set the contours margin on walkout-plot
 
Args:
    plotID (Number): plot window ID
    i (Number): margin in pixels
 
Returns:
    bool: operation exit status
walkoutPlotSetDatum(*args, **kwargs)
walkoutPlotSetDatum(plotID: Number, lim: bool, ymin: Number=0, ymax: Number) -> bool
 
Change the reference limitation on walkout-plot
 
Args:
    plotID (Number): plot window ID
    lim (bool): 0 for 'whole datum' / 1 for 'user values'
    ymin (Number): Optional; top limitation
    ymax (Number): bottom limitation
 
Returns:
    bool: operation exit status
walkoutPlotSetDepthGapColor(*args, **kwargs)
walkoutPlotSetDepthGapColor(plotID: Number, r: Number, g: Number, b: Number) -> bool
 
Set the color of the depth gap on walkout-plot
 
Args:
    plotID (Number): plot window ID
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
walkoutPlotSetDepthGapLength(*args, **kwargs)
walkoutPlotSetDepthGapLength(plotID: Number, i: Number) -> bool
 
Set the length of the depth gap on walkout-plot
 
Args:
    plotID (Number): plot window ID
    i (Number): length
 
Returns:
    bool: operation exit status
walkoutPlotSetDepthGapThickness(*args, **kwargs)
walkoutPlotSetDepthGapThickness(plotID: Number, f: Number) -> bool
 
Set the thickness of the depth gap on walkout-plot
 
Args:
    plotID (Number): plot window ID
    f (Number): thickness
 
Returns:
    bool: operation exit status
walkoutPlotSetDepthGapThreshold(*args, **kwargs)
walkoutPlotSetDepthGapThreshold(plotID: Number, f: Number) -> bool
 
Set the threshold of the depth gap on walkout-plot
 
Args:
    plotID (Number): plot window ID
    f (Number): threshold value
 
Returns:
    bool: operation exit status
walkoutPlotSetDepthGapVisible(*args, **kwargs)
walkoutPlotSetDepthGapVisible(plotID: Number, b: bool) -> bool
 
Set the visibility of the depth gap on walkout-plot
 
Args:
    plotID (Number): plot window ID
    b (bool): value
 
Returns:
    bool: operation exit status
walkoutPlotSetDip(*args, **kwargs)
walkoutPlotSetDip(plotID: Number, dip: str) -> bool
 
Set the dip variable of a walkout-plot
 
Args:
    plotID (Number): plot window ID
    dip (str): variable name
 
Returns:
    bool: operation exit status
walkoutPlotSetFilter(*args, **kwargs)
walkoutPlotSetFilter(plotID: Number, filter: str) -> bool
 
Set the filter variable of a walkout-plot
 
Args:
    plotID (Number): plot window ID
    filter (str): variable name
 
Returns:
    bool: operation exit status
walkoutPlotSetMarkersColor(*args, **kwargs)
walkoutPlotSetMarkersColor(plotID: Number, r: Number, g: Number, b: Number) -> bool
 
Set the makers color on walkout-plot
 
Args:
    plotID (Number): plot window ID
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
walkoutPlotSetMarkersColour(*args, **kwargs)
walkoutPlotSetMarkersColour(plotID: Number, r: Number, g: Number, b: Number) -> bool
 
[DEPRECATED] (use walkoutPlotSetMarkersColor instead) Set the makers color on walkout-plot
 
Args:
    plotID (Number): plot window ID
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
walkoutPlotSetMarkersSize(*args, **kwargs)
walkoutPlotSetMarkersSize(plotID: Number, s: Number) -> bool
 
Set the makers size on walkout-plot
 
Args:
    plotID (Number): plot window ID
    s (Number): size
 
Returns:
    bool: operation exit status
walkoutPlotSetName(*args, **kwargs)
walkoutPlotSetName(plotID: Number, n: str) -> bool
 
Change the name of the walkout-plot
 
Args:
    plotID (Number): plot window ID
    n (str): new plot windows name
 
Returns:
    bool: operation exit status
walkoutPlotSetReferentialBorderColor(*args, **kwargs)
walkoutPlotSetReferentialBorderColor(plotID: Number, r: Number, g: Number, b: Number) -> bool
 
Set the border color of the referential on walkout-plot
 
Args:
    plotID (Number): plot window ID
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
walkoutPlotSetReferentialColor(*args, **kwargs)
walkoutPlotSetReferentialColor(plotID: Number, r: Number, g: Number, b: Number) -> bool
 
Set the color of the referential on walkout-plot
 
Args:
    plotID (Number): plot window ID
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
walkoutPlotSetReferentialFont(*args, **kwargs)
walkoutPlotSetReferentialFont(plotID: Number, fontName: str, fontSize: Number, fontBold: bool=False, fontItalic: bool=False, fontUnderline: bool=False, fontStrikeOut: bool=False) -> bool
 
Set the font of the referential on walkout-plot
 
Args:
    plotID (Number): plot window ID
    fontName (str): name of the family font
    fontSize (Number): size of the font
    fontBold (bool): Optional; font in bold or not
    fontItalic (bool): Optional; font in italic or not
    fontUnderline (bool): Optional; underline font or not
    fontStrikeOut (bool): Optional; strike out font or not
 
Returns:
    bool: operation exit status
walkoutPlotSetReferentialPosition(*args, **kwargs)
walkoutPlotSetReferentialPosition(plotID: Number, x: Number, y: Number) -> bool
 
Set the position of the referential on walkout-plot
 
Args:
    plotID (Number): plot window ID
    x (Number): x position
    y (Number): y position
 
Returns:
    bool: operation exit status
walkoutPlotSetReferentialSize(*args, **kwargs)
walkoutPlotSetReferentialSize(plotID: Number, f: Number) -> bool
 
Set the size of the referential on walkout-plot
 
Args:
    plotID (Number): plot window ID
    f (Number): size
 
Returns:
    bool: operation exit status
walkoutPlotSetReferentialVisible(*args, **kwargs)
walkoutPlotSetReferentialVisible(plotID: Number, b: bool) -> bool
 
Set the visibility of the referential on walkout-plot
 
Args:
    plotID (Number): plot window ID
    b (bool): value
 
Returns:
    bool: operation exit status
walkoutPlotSetVectorMeanByInteractionVisible(*args, **kwargs)
walkoutPlotSetVectorMeanByInteractionVisible(plotID: Number, b: bool) -> bool
 
Set the visibility of the 'by interaction' mean vector on walkout-plot
 
Args:
    plotID (Number): plot window ID
    b (bool): value
 
Returns:
    bool: operation exit status
walkoutPlotSetVectorMeanGlobalVisible(*args, **kwargs)
walkoutPlotSetVectorMeanGlobalVisible(plotID: Number, b: bool) -> bool
 
Set the visibility of the global mean vector on walkout-plot
 
Args:
    plotID (Number): plot window ID
    b (bool): value
 
Returns:
    bool: operation exit status
walkoutPlotSetWalkoutType(*args, **kwargs)
walkoutPlotSetWalkoutType(plotID: Number, type: str='AZIMUTH') -> bool
 
Set the walkout type of the walkout-plot
 
Args:
    plotID (Number): plot window ID
    type (str): Optional; walkout type {'AZIMUTH', 'EAST STRIKE', 'WEST STRIKE'}
 
Returns:
    bool: operation exit status
walkoutPlotSetZonation(*args, **kwargs)
walkoutPlotSetZonation(plotID: Number, d: str) -> bool
 
Set the zonation dataset to the walkout-plot
 
Args:
    plotID (Number): plot window ID
    d (str): zonation dataset name
 
Returns:
    bool: operation exit status
waveformDuplicate(*args, **kwargs)
waveformDuplicate(plotId: Number) -> Number
 
Duplicate an existing waveform
 
Args:
    plotId (Number): plot ID
 
Returns:
    Number: plot ID
waveformOpen(*args, **kwargs)
waveformOpen(n: str, f: str=None) -> Number
 
Open an existing waveform
 
Args:
    n (str): plot name
    f (str): Optional; folder
 
Returns:
    Number: plot ID
waveformSpectrumOpen(*args, **kwargs)
waveformSpectrumOpen(plotID: Number) -> Number
 
Open a spectrum plot from a waveform
 
Args:
    plotID (Number): waveform plot window ID
 
Returns:
    Number: plot ID
wellTrajectory2DAddSet(*args, **kwargs)
wellTrajectory2DAddSet(plotID: Number, wName: str, setName: str) -> bool
 
Add a dataset to an existing 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    wName (str): well name
    setName (str): dataset name
 
Returns:
    bool: operation exit status
wellTrajectory2DAddVariable(*args, **kwargs)
wellTrajectory2DAddVariable(plotID: Number, wName: str, setName: str, vName: str) -> bool
 
Add a variable to an existing 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    wName (str): well name
    setName (str): dataset name
    vName (str): variable name
 
Returns:
    bool: operation exit status
wellTrajectory2DAddWell(*args, **kwargs)
wellTrajectory2DAddWell(plotID: Number, wName: str) -> bool
 
Add a well to an existing 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    wName (str): well name
 
Returns:
    bool: operation exit status
wellTrajectory2DAddZone(*args, **kwargs)
wellTrajectory2DAddZone(plotID: Number, zone: str) -> bool
 
Add Zone in a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    zone (str): zone name
 
Returns:
    bool: operation exit status
wellTrajectory2DChangeZonation(*args, **kwargs)
wellTrajectory2DChangeZonation(plotID: Number, setZonation: str) -> bool
 
Set the zonation dataset of a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    setZonation (str): dataset zonation name
 
Returns:
    bool: operation exit status
wellTrajectory2DCleanZonation(*args, **kwargs)
wellTrajectory2DCleanZonation(plotID: Number, setZonation: str) -> bool
 
Clean the zonation dataset of a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    setZonation (str): dataset zonation name
 
Returns:
    bool: operation exit status
wellTrajectory2DCleanZone(*args, **kwargs)
wellTrajectory2DCleanZone(plotID: Number, zone: str) -> bool
 
Clean Zone in a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    zone (str): zone name
 
Returns:
    bool: operation exit status
wellTrajectory2DCreate(*args, **kwargs)
wellTrajectory2DCreate(n: str, var1: str=None, var2: str=None, var3: str=None) -> Number
 
Create a new 2D well trajectory
 
Args:
    n (str): plot name
    var1 (str): Optional; variable 1 name
    var2 (str): Optional; variable 2 name
    var3 (str): Optional; variable 3 name
 
Returns:
    Number: plot ID
wellTrajectory2DDuplicate(*args, **kwargs)
wellTrajectory2DDuplicate(plotID: Number) -> bool
 
Duplicate the 2D well trajectory
 
Args:
    plotID (Number): plot window ID
 
Returns:
    bool: operation exit status
wellTrajectory2DOpen(*args, **kwargs)
wellTrajectory2DOpen(n: str, f: str=None) -> Number
 
Open an existing 2D well trajectory
 
Args:
    n (str): plot name
    f (str): Optional; folder
 
Returns:
    Number: plot ID
wellTrajectory2DRemoveSet(*args, **kwargs)
wellTrajectory2DRemoveSet(plotID: Number, setName: str) -> bool
 
Remove a dataset from an existing 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    setName (str): dataset name
 
Returns:
    bool: operation exit status
wellTrajectory2DRemoveVariable(*args, **kwargs)
wellTrajectory2DRemoveVariable(plotID: Number, vName: str) -> bool
 
Remove a variable from an existing 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    vName (str): variable name
 
Returns:
    bool: operation exit status
wellTrajectory2DRemoveWell(*args, **kwargs)
wellTrajectory2DRemoveWell(plotID: Number, wName: str) -> bool
 
Remove a well from an existing 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    wName (str): well name
 
Returns:
    bool: operation exit status
wellTrajectory2DSave(*args, **kwargs)
wellTrajectory2DSave(plotID: Number, n: str, f: str='') -> bool
 
Save the 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    n (str): file name
    f (str): Optional; folder
 
Returns:
    bool: operation exit status
wellTrajectory2DSetAutoAdjust(*args, **kwargs)
wellTrajectory2DSetAutoAdjust(plotID: Number, b: bool) -> bool
 
Set the automatic adjustment of a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    b (bool): automatic adjustment if True
 
Returns:
    bool: operation exit status
wellTrajectory2DSetBoreholeCaliper(*args, **kwargs)
wellTrajectory2DSetBoreholeCaliper(plotID: Number, wellName: str, setName: str, variableName: str) -> bool
 
set the caliper variable
 
Args:
    plotID (Number): plot window ID
    wellName (str): well name
    setName (str): dataset name
    variableName (str): variable name
 
Returns:
    bool: operation exit status
wellTrajectory2DSetBoreholeDisplayType(*args, **kwargs)
wellTrajectory2DSetBoreholeDisplayType(plotID: Number, n: str) -> bool
 
Set the display mode for borehole radius
 
Args:
    plotID (Number): plot window ID
    n (str): display mode for the borehole can be {"None", "Constant radius", "Caliper"}
                "Constant radius" displays a borehole around trajectory with a constant radius
                "Caliper" displays a borehole around the trajectoy from a caliper variableradius
 
Returns:
    bool: operation exit status
wellTrajectory2DSetBoreholeGlobalRadius(*args, **kwargs)
wellTrajectory2DSetBoreholeGlobalRadius(plotID: Number, radius: Number) -> bool
 
Set the global radius in Inches
 
Args:
    plotID (Number): plot window ID
    radius (Number): global radius in Inches
 
Returns:
    bool: operation exit status
wellTrajectory2DSetClassificationObjectColor(*args, **kwargs)
wellTrajectory2DSetClassificationObjectColor(plotID: Number, numObject: Number, r: Number, g: Number, b: Number) -> bool
 
Set the color of one object of the classification of a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    numObject (Number): index of the object in the classification
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
wellTrajectory2DSetClassificationObjectLength(*args, **kwargs)
wellTrajectory2DSetClassificationObjectLength(plotID: Number, numObject: Number, length: Number) -> bool
 
Set the length of one object of the classification of a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    numObject (Number): index of the object in the classification
    length (Number): length value
 
Returns:
    bool: operation exit status
wellTrajectory2DSetClassificationObjectVisibility(*args, **kwargs)
wellTrajectory2DSetClassificationObjectVisibility(plotID: Number, numObject: Number, b: bool) -> bool
 
Set the visiblity of one object of the classification of a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    numObject (Number): index of the object in the classification
    b (bool): object visible if True
 
Returns:
    bool: operation exit status
wellTrajectory2DSetGlobalClassificationVisibility(*args, **kwargs)
wellTrajectory2DSetGlobalClassificationVisibility(plotID: Number, b: bool) -> bool
 
Set the global visiblity of the classification of a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    b (bool): all object of the classification visible if True
 
Returns:
    bool: operation exit status
wellTrajectory2DSetKeepProportion(*args, **kwargs)
wellTrajectory2DSetKeepProportion(plotID: Number, b: bool) -> bool
 
Set the space proportion of a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    b (bool): keep proportion if True
 
Returns:
    bool: operation exit status
wellTrajectory2DSetReferenceTrackFont(*args, **kwargs)
wellTrajectory2DSetReferenceTrackFont(plotID: Number, fontName: str, fontSize: Number, fontBold: bool=False, fontItalic: bool=False, fontUnderline: bool=False, fontStrikeOut: bool=False) -> bool
 
Set the font of the reference track of a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    fontName (str): name of the family font
    fontSize (Number): size of the font
    fontBold (bool): Optional; font in bold or not
    fontItalic (bool): Optional; font in italic or not
    fontUnderline (bool): Optional; underline font or not
    fontStrikeOut (bool): Optional; strike out font or not
 
Returns:
    bool: operation exit status
wellTrajectory2DSetReferenceTrackShift(*args, **kwargs)
wellTrajectory2DSetReferenceTrackShift(plotID: Number, gap: Number) -> bool
 
Set the gap of the reference track of a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    gap (Number): shift value
 
Returns:
    bool: operation exit status
wellTrajectory2DSetReferenceTrackSize(*args, **kwargs)
wellTrajectory2DSetReferenceTrackSize(plotID: Number, size: Number) -> bool
 
Set the size of the reference track of a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    size (Number): size value
 
Returns:
    bool: operation exit status
wellTrajectory2DSetReferenceTrackSpacing(*args, **kwargs)
wellTrajectory2DSetReferenceTrackSpacing(plotID: Number, step: Number) -> bool
 
Set the spacing of the reference track of a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    step (Number): spacing value
 
Returns:
    bool: operation exit status
wellTrajectory2DSetReferenceTrackUnit(*args, **kwargs)
wellTrajectory2DSetReferenceTrackUnit(plotID: Number, unit: str) -> bool
 
Set the unit of the reference track of a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    unit (str): reference track unit
 
Returns:
    bool: operation exit status
wellTrajectory2DSetReferenceTrackVisible(*args, **kwargs)
wellTrajectory2DSetReferenceTrackVisible(plotID: Number, b: bool) -> bool
 
Set the visibility of the reference track of a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    b (bool): reference track visible if True
 
Returns:
    bool: operation exit status
wellTrajectory2DSetTrajectoryLineOfSection(*args, **kwargs)
wellTrajectory2DSetTrajectoryLineOfSection(plotID: Number, f: Number) -> bool
 
Set the line of section value of the trajectory of a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    f (Number): strike angle value
 
Returns:
    bool: operation exit status
wellTrajectory2DSetTrajectoryThickness(*args, **kwargs)
wellTrajectory2DSetTrajectoryThickness(plotID: Number, thickness: Number) -> bool
 
Set the thickness of the trajectory of a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    thickness (Number): thickness value
 
Returns:
    bool: operation exit status
wellTrajectory2DSetTrajectoryType(*args, **kwargs)
wellTrajectory2DSetTrajectoryType(plotID: Number, type: str='PROJECTED') -> bool
 
Set the type of the trajectory of a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    type (str): Optional; {"TOP_VIEW", "PROJECTED", "CURTAIN_SECTION"}
 
Returns:
    bool: operation exit status
wellTrajectory2DSetTrajectoryVisible(*args, **kwargs)
wellTrajectory2DSetTrajectoryVisible(plotID: Number, b: bool) -> bool
 
Set the visibility of the trajectory of a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    b (bool): trajectory visible if True
 
Returns:
    bool: operation exit status
wellTrajectory2DSetVar1(*args, **kwargs)
wellTrajectory2DSetVar1(plotID: Number, wName: str, setName: str, vName: str) -> bool
 
Set the first variable of a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    wName (str): well name
    setName (str): dataset name
    vName (str): variable name
 
Returns:
    bool: operation exit status
wellTrajectory2DSetVar1Amplitude(*args, **kwargs)
wellTrajectory2DSetVar1Amplitude(plotID: Number, amplitude: Number) -> bool
 
Set the amplitude of the first variable of a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    amplitude (Number): amplitude value
 
Returns:
    bool: operation exit status
wellTrajectory2DSetVar1AreaFillColor(*args, **kwargs)
wellTrajectory2DSetVar1AreaFillColor(plotID: Number, r: Number, g: Number, b: Number) -> bool
 
Set the area fill color of the first variable of a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
wellTrajectory2DSetVar1AreaFillMode(*args, **kwargs)
wellTrajectory2DSetVar1AreaFillMode(plotID: Number, mode: str='COLOR') -> bool
 
Set the area fill mode of the first variable of a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    mode (str): Optional; {'NONE', 'PALETTE', 'COLOR'}
 
Returns:
    bool: operation exit status
wellTrajectory2DSetVar1OnTheRight(*args, **kwargs)
wellTrajectory2DSetVar1OnTheRight(plotID: Number, onTheRight: bool) -> bool
 
Put the first variable of a 2D well trajectory on the right of the trajectory or not
 
Args:
    plotID (Number): plot window ID
    onTheRight (bool): on the right if True, else on the left
 
Returns:
    bool: operation exit status
wellTrajectory2DSetVar1Set(*args, **kwargs)
wellTrajectory2DSetVar1Set(plotID: Number, setName: str) -> bool
 
Set the dataset of the first variable of a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    setName (str): dataset name
 
Returns:
    bool: operation exit status
wellTrajectory2DSetVar1Shift(*args, **kwargs)
wellTrajectory2DSetVar1Shift(plotID: Number, gap: Number) -> bool
 
Set the shift of the first variable of a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    gap (Number): shift value
 
Returns:
    bool: operation exit status
wellTrajectory2DSetVar2(*args, **kwargs)
wellTrajectory2DSetVar2(plotID: Number, wName: str, setName: str, vName: str) -> bool
 
Set the second variable of a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    wName (str): well name
    setName (str): dataset name
    vName (str): variable name
 
Returns:
    bool: operation exit status
wellTrajectory2DSetVar2Amplitude(*args, **kwargs)
wellTrajectory2DSetVar2Amplitude(plotID: Number, amplitude: Number) -> bool
 
Set the amplitude of the second variable of a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    amplitude (Number): amplitude value
 
Returns:
    bool: operation exit status
wellTrajectory2DSetVar2AreaFillColor(*args, **kwargs)
wellTrajectory2DSetVar2AreaFillColor(plotID: Number, r: Number, g: Number, b: Number) -> bool
 
Set the area fill color of the second variable of a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
wellTrajectory2DSetVar2AreaFillMode(*args, **kwargs)
wellTrajectory2DSetVar2AreaFillMode(plotID: Number, mode: str='COLOR') -> bool
 
Set the area fill mode of the second variable of a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    mode (str): Optional; {'NONE', 'PALETTE', 'COLOR'}
 
Returns:
    bool: operation exit status
wellTrajectory2DSetVar2OnTheRight(*args, **kwargs)
wellTrajectory2DSetVar2OnTheRight(plotID: Number, onTheRight: bool) -> bool
 
Put the second variable of a 2D well trajectory on the right of the trajectory or not
 
Args:
    plotID (Number): plot window ID
    onTheRight (bool): on the right if True, else on the left
 
Returns:
    bool: operation exit status
wellTrajectory2DSetVar2Set(*args, **kwargs)
wellTrajectory2DSetVar2Set(plotID: Number, setName: str) -> bool
 
Set the dataset of the second variable of a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    setName (str): dataset name
 
Returns:
    bool: operation exit status
wellTrajectory2DSetVar2Shift(*args, **kwargs)
wellTrajectory2DSetVar2Shift(plotID: Number, gap: Number) -> bool
 
Set the shift of the second variable of a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    gap (Number): shift value
 
Returns:
    bool: operation exit status
wellTrajectory2DSetVarDip(*args, **kwargs)
wellTrajectory2DSetVarDip(plotID: Number, wName: str, setName: str, vName: str) -> bool
 
[DEPRECATED] (use wellTrajectory2DSetVariableDip instead) Set the dip variable of a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    wName (str): well name
    setName (str): dataset name
    vName (str): variable name
 
Returns:
    bool: operation exit status
wellTrajectory2DSetVarDipGlobalColor(*args, **kwargs)
wellTrajectory2DSetVarDipGlobalColor(plotID: Number, r: Number, g: Number, b: Number) -> bool
 
[DEPRECATED] (use wellTrajectory2DSetVariableDipGlobalColor instead) Set the global color of the dip variable of a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
wellTrajectory2DSetVarDipGlobalLength(*args, **kwargs)
wellTrajectory2DSetVarDipGlobalLength(plotID: Number, length: Number) -> bool
 
[DEPRECATED] (use wellTrajectory2DSetVariableDipGlobalLength instead) Set the global length of the dip variable of a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    length (Number): global length value
 
Returns:
    bool: operation exit status
wellTrajectory2DSetVarDipMarker(*args, **kwargs)
wellTrajectory2DSetVarDipMarker(plotID: Number, marker: str='NONE') -> bool
 
[DEPRECATED] (use wellTrajectory2DSetVariableDipMarker instead) Set the marker of the dip variable of a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    marker (str): Optional; {'NONE', 'POINTS'}
 
Returns:
    bool: operation exit status
wellTrajectory2DSetVarDipThickness(*args, **kwargs)
wellTrajectory2DSetVarDipThickness(plotID: Number, thickness: Number) -> bool
 
[DEPRECATED] (use wellTrajectory2DSetVariableDipThickness instead) Set the thickness of the dip variable of a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    thickness (Number): thickness value
 
Returns:
    bool: operation exit status
wellTrajectory2DSetVarDipUseDipColor(*args, **kwargs)
wellTrajectory2DSetVarDipUseDipColor(plotID: Number, b: bool) -> bool
 
[DEPRECATED] (use wellTrajectory2DSetVariableDipUseDipColor instead) Set the use dip color of the dip variable of a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    b (bool): use dip color if True
 
Returns:
    bool: operation exit status
wellTrajectory2DSetVarDipUseDipLength(*args, **kwargs)
wellTrajectory2DSetVarDipUseDipLength(plotID: Number, b: bool) -> bool
 
[DEPRECATED] (use wellTrajectory2DSetVariableDipUseDipLength instead) Set the use dip length of the dip variable of a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    b (bool): use dip length if True
 
Returns:
    bool: operation exit status
wellTrajectory2DSetVariableDip(*args, **kwargs)
wellTrajectory2DSetVariableDip(plotID: Number, wName: str, setName: str, vName: str) -> bool
 
Set the dip variable of a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    wName (str): well name
    setName (str): dataset name
    vName (str): variable name
 
Returns:
    bool: operation exit status
wellTrajectory2DSetVariableDipGlobalColor(*args, **kwargs)
wellTrajectory2DSetVariableDipGlobalColor(plotID: Number, r: Number, g: Number, b: Number) -> bool
 
Set the global color of the dip variable of a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    r (Number): red
    g (Number): green
    b (Number): blue
 
Returns:
    bool: operation exit status
wellTrajectory2DSetVariableDipGlobalLength(*args, **kwargs)
wellTrajectory2DSetVariableDipGlobalLength(plotID: Number, length: Number) -> bool
 
Set the global length of the dip variable of a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    length (Number): global length value
 
Returns:
    bool: operation exit status
wellTrajectory2DSetVariableDipMarker(*args, **kwargs)
wellTrajectory2DSetVariableDipMarker(plotID: Number, marker: str='NONE') -> bool
 
Set the marker of the dip variable of a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    marker (str): Optional; {'NONE', 'POINTS'}
 
Returns:
    bool: operation exit status
wellTrajectory2DSetVariableDipThickness(*args, **kwargs)
wellTrajectory2DSetVariableDipThickness(plotID: Number, thickness: Number) -> bool
 
Set the thickness of the dip variable of a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    thickness (Number): thickness value
 
Returns:
    bool: operation exit status
wellTrajectory2DSetVariableDipUseDipColor(*args, **kwargs)
wellTrajectory2DSetVariableDipUseDipColor(plotID: Number, b: bool) -> bool
 
Set the use dip color of the dip variable of a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    b (bool): use dip color if True
 
Returns:
    bool: operation exit status
wellTrajectory2DSetVariableDipUseDipLength(*args, **kwargs)
wellTrajectory2DSetVariableDipUseDipLength(plotID: Number, b: bool) -> bool
 
Set the use dip length of the dip variable of a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    b (bool): use dip length if True
 
Returns:
    bool: operation exit status
wellTrajectory2DSetXAxisInverse(*args, **kwargs)
wellTrajectory2DSetXAxisInverse(plotID: Number, b: bool) -> bool
 
Set the x axis inverse of a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    b (bool): inversed x axis if True
 
Returns:
    bool: operation exit status
wellTrajectory2DSetXAxisType(*args, **kwargs)
wellTrajectory2DSetXAxisType(plotID: Number, type: str='VAR') -> bool
 
Set the x axis type of a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    type (str): Optional; {'USER', 'VAR'}
 
Returns:
    bool: operation exit status
wellTrajectory2DSetXAxisUserLimits(*args, **kwargs)
wellTrajectory2DSetXAxisUserLimits(plotID: Number, min: Number, max: Number) -> bool
 
Set the x axis user limits of a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    min (Number): min user
    max (Number): max user
 
Returns:
    bool: operation exit status
wellTrajectory2DSetXYUnit(*args, **kwargs)
wellTrajectory2DSetXYUnit(plotID: Number, unit: str) -> bool
 
Set the unit of x axis and y axis of a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    unit (str): unit value
 
Returns:
    bool: operation exit status
wellTrajectory2DSetYAxisType(*args, **kwargs)
wellTrajectory2DSetYAxisType(plotID: Number, type: str='VAR') -> bool
 
Set the y axis type of a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    type (str): Optional; {'USER', 'VAR'}
 
Returns:
    bool: operation exit status
wellTrajectory2DSetYAxisUserLimits(*args, **kwargs)
wellTrajectory2DSetYAxisUserLimits(plotID: Number, min: Number, max: Number) -> bool
 
Set the y axis user limits of a 2D well trajectory
 
Args:
    plotID (Number): plot window ID
    min (Number): min user
    max (Number): max user
 
Returns:
    bool: operation exit status
wellboreCentricGridOpen(*args, **kwargs)
wellboreCentricGridOpen(n: str, f: str=None) -> Number
 
Open an existing wellbore centric grid plot
 
Args:
    n (str): plot name
    f (str): Optional; folder
 
Returns:
    Number: plot ID
